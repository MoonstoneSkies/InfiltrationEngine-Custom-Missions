<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX0007E30C93F040C1B3F5BBF290F06F4B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngineTools</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXC8FCB6BF4C214CBE84AD890A762F648E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeSearch</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1C39F9C9A0F4429F87FD229A1AA5266D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable
local OnChange = Actor.OnChange
local Watch = Actor.Watch

local module = {}

local ROW_HEIGHT = 20

local SearchText = State("")
local SearchResults = Derived(function(text)
	if #text < 3 or not workspace:FindFirstChild("DebugMission") then
		return {}
	end
	local results = {}

	local missionModule = require(workspace.DebugMission.MissionSetup:Clone())
	local match = {}

	local function searchTable(prefix, tbl)
		for field, value in tbl do
			if value == "" then
				continue
			end
			if typeof(value) == "string" then
				if (typeof(field) == "string" and field:lower():match(text)) or value:lower():match(text) then
					local entry = if prefix then `{prefix}.{field}` else field
					match[entry] = value
				end
			elseif typeof(value) == "table" then
				local entry = if prefix then `{prefix}.{field}` else field
				searchTable(entry, value)
			end
		end
	end
	searchTable(nil, missionModule)

	if next(match) then
		results[workspace.DebugMission.MissionSetup] = match
		match = {}
	end

	for _, instance in workspace.DebugMission:GetDescendants() do
		local attributes = instance:GetAttributes()
		if not next(attributes) then
			continue
		end

		for k, v in attributes do
			if v ~= "" and k:lower() == text or typeof(v) == "string" and v:lower():match(text) then
				match[k] = tostring(v)
			end
		end

		if next(match) then
			results[instance] = match
			match = {}
		end
	end
	return results
end, SearchText)

module.PropMarkers = {}
local function ClearPropMarkers()
	for _, p in module.PropMarkers do
		p:Destroy()
	end
	module.PropMarkers = {}
end
local function UpdatePropMarkers(list)
	ClearPropMarkers()
	for k in list do
		if k:IsA("BasePart") then
			table.insert(
				module.PropMarkers,
				Create("BillboardGui", {
					Archivable = false,
					Parent = game:GetService("CoreGui"),
					Adornee = k,
					Size = UDim2.new(0, 20, 0, 20),
					AlwaysOnTop = true,
				}, {
					Create("Frame", {
						Size = UDim2.new(0, 20, 0, 20),
						BorderSizePixel = 0,
						BackgroundColor3 = Color3.new(1, 1, 1),
					}, {
						Create("UICorner", {
							CornerRadius = UDim.new(0.5, 0),
						}),
					}),
				})
			)
		end
	end
end
Watch(UpdatePropMarkers, SearchResults)

local function ListEntry(instance, fields)
	local fieldCount = 0
	local contents = {
		Create("TextLabel", {
			Size = UDim2.new(0, 200, 0, ROW_HEIGHT),
			Position = UDim2.new(0, 0, 0, 0),
			Text = instance.Name,
			BackgroundTransparency = 1,
			TextColor3 = Color3.new(1, 1, 1),
		}),
	}

	for k, v in fields do
		table.insert(
			contents,
			Create(
				"TextLabel",
				{
					Size = UDim2.new(0, 200, 0, ROW_HEIGHT),
					Position = UDim2.new(0, 200, 0, ROW_HEIGHT * fieldCount),
					Text = k,
					TextXAlignment = Enum.TextXAlignment.Right,
					BackgroundTransparency = 1,
					TextColor3 = Color3.new(1, 1, 1),
				},
				Create("UIPadding", {
					PaddingRight = UDim.new(0, 10),
				})
			)
		)
		table.insert(
			contents,
			Create("TextLabel", {
				Size = UDim2.new(0, 0, 0, ROW_HEIGHT),
				Position = UDim2.new(0, 400, 0, ROW_HEIGHT * fieldCount),
				AutomaticSize = Enum.AutomaticSize.X,
				Text = tostring(v):gsub("\n", "   "),
				BackgroundTransparency = 0.6,
				TextColor3 = Color3.new(1, 1, 1),
				BackgroundColor3 = Color3.new(0, 0, 0),
				TextXAlignment = Enum.TextXAlignment.Left,
				BorderSizePixel = 0,
			}, {
				Create("UIPadding", {
					PaddingRight = UDim.new(0, 10),
					PaddingLeft = UDim.new(0, 10),
				}),
			})
		)
		fieldCount += 1
	end

	local layoutOrder = 0
	if instance.Name ~= "MissionSetup" then
		layoutOrder = 1000 * string.byte(instance.Name:lower(), 1, 1) + string.byte(instance.Name:lower(), 2, 2)
	end

	return Create("TextButton", {
		Size = UDim2.new(0, 400, 0, fieldCount * ROW_HEIGHT),
		Text = "",
		BackgroundTransparency = 0.3,
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = layoutOrder,
		Activated = function()
			game.Selection:Set({ instance })
		end,
	}, contents)
end

local lastTextChange = 0
function module.Init(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true
	UpdatePropMarkers(SearchResults._Value)

	local searchBox
	searchBox = Create("TextBox", {
		Size = UDim2.new(0, 200, 0, ROW_HEIGHT),
		PlaceholderText = "Search Attribute",
		BackgroundTransparency = 0.5,
		BorderSizePixel = 0,
		BackgroundColor3 = Color3.new(),
		PlaceholderColor3 = Color3.new(0.8, 0.8, 0.8),
		TextColor3 = Color3.new(1, 1, 1),
		Text = SearchText._Value,
		ClearTextOnFocus = false,
		[OnChange("Text")] = function()
			lastTextChange += 1
			local clock = lastTextChange
			task.delay(1, function()
				if clock == lastTextChange then
					SearchText:set(searchBox.Text:lower())
				end
			end)
		end,
		FocusLost = function()
			SearchText:set(searchBox.Text)
		end,
	})

	module.UI = Create("ScreenGui", {
		Parent = game.CoreGui,
		Archivable = false,
	}, {
		Create("Frame", {
			Size = UDim2.new(1, -100, 1, -100),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			AnchorPoint = Vector2.new(0.5, 0.5),
			BackgroundTransparency = 1,
		}, {
			searchBox,
			Create("ScrollingFrame", {
				Size = UDim2.new(1, 0, 1, -ROW_HEIGHT * 1.5),
				Position = UDim2.new(0, 0, 1, 0),
				AnchorPoint = Vector2.new(0, 1),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				CanvasSize = UDim2.new(0, 0, 0, 0),
				AutomaticCanvasSize = Enum.AutomaticSize.Y,
			}, {
				Create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
				}),
				DerivedTable(ListEntry, SearchResults),
			}),
		}),
	})
end

function module.Clean()
	module.Active = false
	ClearPropMarkers()
	if module.UI then
		module.UI:Destroy()
		module.UI = nil
	end
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{42E710CB-5069-4AEB-8C6F-2DC5C1DC8F0E}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX0D837F3BFD0E4C11AF20F8E1E3BB0937">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">CombatMap</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX0EE87A31F5494BEEB88588215F6FEC94">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local UIS = game:GetService("UserInputService")

local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local module = {}

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable

local DrawnModel = nil
local InputConnection = nil
local CurrentMap = nil

local BLUE = Color3.new(0, 0, 0.8)
local BLACK = Color3.fromRGB(0, 0, 0)
local WHITE = Color3.new(1, 1, 1)

local function DrawLine(p0, p1, color)
	local p = Instance.new("Part")
	p.Size = Vector3.new(1, 1, (p0 - p1).Magnitude)
	p.CFrame = CFrame.new((p0 + p1) / 2, p0)
	p.Color = color
	p.CastShadow = false
	return p
end

local function GetLinkId(id0, id1)
	if id0 < id1 then
		return id0 .. "|" .. id1
	end
	return id1 .. "|" .. id0
end

local function GetNodeId(node)
	local nodeId = node:GetAttribute("Id")
	if nodeId then return nodeId end

	warn(`Node {node.Name} missing Id attribute, reusing name as Id`)
	node:SetAttribute("Id", node.Name)
	return node.Name
end

local function ToggleNodeLink(node1, node2)
	local node1Links = HttpService:JSONDecode(node1:GetAttribute("LinkedIds") or "[]")
	local node2Links = HttpService:JSONDecode(node2:GetAttribute("LinkedIds") or "[]")

	local idx = table.find(node1Links, GetNodeId(node2))
	if idx == nil then
		table.insert(node1Links, GetNodeId(node2))
		table.insert(node2Links, GetNodeId(node1))
	else
		table.remove(node1Links, idx)
		table.remove(node2Links, table.find(node2Links, GetNodeId(node1)))
	end

	node1:SetAttribute("LinkedIds", HttpService:JSONEncode(node1Links))
	node2:SetAttribute("LinkedIds", HttpService:JSONEncode(node2Links))
end

local function InputNodeName(box)
	-- Need intermediate event to avoid error with FocusLost event order
	local event = Instance.new("BindableEvent")
	local nodeName = nil

	box.Visible = true
	box:CaptureFocus()
	box.Text = ""
	box.FocusLost:Once(function(enterPressed, _)
		if enterPressed then
			nodeName = box.Text
		end
		box.Visible = false
		event:Fire()
	end)

	event.Event:Wait()
	event:Destroy()
	return nodeName
end

function module.Init(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	print("       Left Click Link - Toggle Link Blocked")
	print("       Left Click Node - Select Combat Flow Node")
	print("CTRL + Left Click Node - Connect Selected Node To Clicked Node")
	print("       Space - Add Node With Automatic ID")
	print("CTRL + Space - Add Node With Manual ID")

	local nodeNameBox
	nodeNameBox = Create("TextBox", {
		Text = "",
		Size = UDim2.new(0, 300, 0, 30),
		Position = UDim2.new(0, 50, 0, 80),
		BorderSizePixel = 0,
		ClearTextOnFocus = true,
		BackgroundColor3 = Color3.new(1, 1, 1),
		BackgroundTransparency = 0.5,
		Visible = false,
	})

	module.UI = Create("ScreenGui", {
		Parent = game:GetService("CoreGui"),
		Archivable = false,
	}, {
		nodeNameBox
	})

	if workspace.DebugMission:FindFirstChild("CombatFlowMap") then
		VisibilityToggle.TempReveal(workspace.DebugMission.CombatFlowMap)
	end

	local function RedrawMap(id)
		if DrawnModel then
			DrawnModel:Destroy()
			DrawnModel = nil
		end

		DrawnModel = Instance.new("Model")
		DrawnModel.Parent = workspace

		local part = CurrentMap[id]
		local used = {}
		local blocked = part:GetAttribute("BlockedLinks") or "{}"
		blocked = game:GetService("HttpService"):JSONDecode(blocked)

		local FilteredLinks = {}

		local distLeft = {
			[id] = 3,
		}
		local expandFrom = { id }

		while #expandFrom > 0 do
			local checkId = expandFrom[1]
			table.remove(expandFrom, 1)

			local part = CurrentMap:FindFirstChild(checkId)
			local linkTo = HttpService:JSONDecode(part:GetAttribute("LinkedIds") or "[]")

			local deadLinks = {}
			for _, targetId in linkTo do
				local linkName = GetLinkId(checkId, targetId)

				if DrawnModel:FindFirstChild(linkName) ~= nil then
					-- Node link already exists, don't create a second one
					continue
				end

				local linkPart = CurrentMap:FindFirstChild(targetId)
				if linkPart == nil then
					deadLinks[#deadLinks+1] = targetId
					continue
				end

				local p = DrawLine(part.Position, linkPart.Position, BLUE)
				p.Parent = DrawnModel
				p.Name = linkName

				if blocked[linkName] then
					p.Color = BLACK
				else
					table.insert(FilteredLinks, targetId)
					if distLeft[checkId] > 1 and not distLeft[targetId] then
						table.insert(expandFrom, targetId)
					end
				end
				distLeft[targetId] = distLeft[checkId] - 1
			end

			-- Remove links to now-deleted nodes
			for _, dead in pairs(deadLinks) do
				warn(`Found dead link to "{dead}" on node {checkId}, removing...`)
				table.remove(linkTo, table.find(linkTo, dead))
			end
			part:SetAttribute("LinkedIds", HttpService:JSONEncode(linkTo))
		end

		part:SetAttribute("FilteredLinks", HttpService:JSONEncode(FilteredLinks))
		part.Color = BLACK
	end

	local castParams = RaycastParams.new()
	castParams.FilterType = Enum.RaycastFilterType.Include
	InputConnection = UIS.InputBegan:Connect(function(input, processed)
		-- Only act on relevant inputs
		local inputIsAdd = input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space
		local inputIsMouse = input.UserInputType == Enum.UserInputType.MouseButton1
		local inputIsValid = inputIsAdd or inputIsMouse

		if not inputIsValid then return end

		-- If the mouse button being pressed was to interact with UI, do nothing
		if processed then return end

		local part = mouse.Target
		
		if part == nil then
			game.Selection:Set({})
			if DrawnModel then
				DrawnModel:Destroy()
				DrawnModel = nil
			end
			return
		end
		
		local wasCtrlPressed = input:IsModifierKeyDown(Enum.ModifierKey.Ctrl)
		local partIsFlowNode = part:IsDescendantOf(workspace.DebugMission.CombatFlowMap)

		if inputIsAdd and partIsFlowNode then
			-- Probably a mistake - why would you add a flow node directly beside another flow node?
			return
		elseif inputIsAdd then
			local flowElem = game.Selection:Get()[1]
			local flowElemValid = flowElem ~= nil and flowElem:IsDescendantOf(workspace.DebugMission.CombatFlowMap) and (flowElem:IsA("Model") or flowElem:IsA("Part"))

			if not flowElemValid then
				warn("Select a Combat Flow Map or a to-be-connected flow node before attempting to add a new flow node!")
				return
			end

			local flowMap = if flowElem:IsA("Model") then flowElem else flowElem.Parent
			CurrentMap = flowMap

			local newNode = Instance.new("Part")
			newNode.Parent = flowMap
			newNode.Size = Vector3.new(5,5,5)
			newNode.Anchored = true
			newNode.Color = Color3.new(0,0,0)
			newNode.CastShadow = false
			newNode.Transparency = 0.5
			newNode.TopSurface = Enum.SurfaceType.Smooth
			newNode.BottomSurface = Enum.SurfaceType.Smooth

			-- Offset from surface by 5 studs to avoid being half clipped into walls/floors
			castParams.FilterDescendantsInstances = { mouse.Target.Parent }
			local surfaceNormal = workspace:Raycast(mouse.UnitRay.Origin, mouse.UnitRay.Direction*1000, castParams).Normal or Vector3.FromNormalId(mouse.TargetSurface)
			newNode.Position = mouse.Hit.Position + (surfaceNormal*5)

			local manualName = input:IsModifierKeyDown(Enum.ModifierKey.Ctrl)
			local newNodeName = if manualName then InputNodeName(nodeNameBox) else HttpService:GenerateGUID(false)
			newNodeName = newNodeName or ""
			newNodeName = newNodeName:gsub("^%s", ""):gsub("%s$", "")

			if flowMap:FindFirstChild(newNodeName) ~= nil then
				warn("Cannot create flow node with duplicate Id!")
				return
			end

			if #newNodeName < 1 then
				newNode:Destroy() -- Destroy preview
				return
			end

			newNode.Transparency = 0
			newNode.Name = newNodeName
			newNode:SetAttribute("Id", newNode.Name)

			if flowElem:IsA("Part") then
				-- If flow node was selected before adding, connect to it
				ToggleNodeLink(newNode, flowElem)
			end

			game.Selection:Set({ newNode })

			RedrawMap(GetNodeId(newNode))

			return
		end

		if partIsFlowNode and not wasCtrlPressed then
			CurrentMap = part.Parent

			for _, p in CurrentMap:GetChildren() do
				p.Name = p:GetAttribute("Id")
				if p.Name == part.Name and p ~= part then
					-- Duplicate part IDs, emit warn
					warn(`Encountered Combat Flow Nodes with duplicate ID of {p.Name} - combat flow may behave unexpectedly`)
				end
			end

			local id = part:GetAttribute("Id")
			game.Selection:Set({ part })

			RedrawMap(id)
		elseif partIsFlowNode and wasCtrlPressed then
			local firstNode = game.Selection:Get()[1]

			-- Current selection isn't flow node, do nothing
			if not firstNode:IsDescendantOf(workspace.DebugMission.CombatFlowMap) then return end

			-- Both are flow nodes but are from different maps so can't join them
			if firstNode.Parent ~= part.Parent then warn(`Attempt to join combat flow nodes {firstNode.Name} and {part.Name} from differing flow maps!`) return end

			ToggleNodeLink(firstNode, part)

			RedrawMap(firstNode:GetAttribute("Id")) -- Sets FilteredLinks
		elseif part.Name:match("|") and #part.Name >= 3 then
			local node = game.Selection:Get()[1]
			local blocked = node:GetAttribute("BlockedLinks") or "{}"
			blocked = game:GetService("HttpService"):JSONDecode(blocked)

			local beingBlocked = not blocked[part.Name]
			blocked[part.Name] = if beingBlocked then true else nil

			node:SetAttribute("BlockedLinks", HttpService:JSONEncode(blocked))

			RedrawMap(node.Name)
		else
			local id0, id1 = part.Name:match("|")

			if DrawnModel then
				DrawnModel:Destroy()
				DrawnModel = nil
			end
		end
	end)
end

function module.Clean()
	if DrawnModel then
		DrawnModel:Destroy()
		DrawnModel = nil
	end

	if InputConnection then
		InputConnection:Disconnect()
		InputConnection = nil
	end

	module.Active = false

	if module.UI then
		module.UI:Destroy()
		module.UI = nil
	end
end

return module

]]></ProtectedString>
					<string name="ScriptGuid">{F1A0E11E-7750-4013-B5DA-9C642C9D67A7}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX9298E8940D824525ACBCCD2079152B03">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">DoorAccess</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX76F0D9D8A9C946BE86F1D187DD87A6CE">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--!strict

local UserInputService = game:GetService("UserInputService")

local Button = require(script.Parent.Parent.Util.Button)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

local module = {}
module.Active = false
module.DoorState = {}

local RESTRICTIONS_LIST = {
	"Never",
	"Combat",
	"BasicKeycard",
	"SecurityKeycard",
	"MasterKeycard",
	"MRKey",
	"MasterKey",
	"SecurityBadge",
	"LeadSecurityBadge",
	"ITBadge",
}

type DoorData = {
	Base: Part?,
	Side: number?,
	Restrictions: { [number]: string },
	Recover: boolean,
	Locked: boolean,
	IgnoreWhenOpen: boolean,
	IgnoreWhenUnlocked: boolean,
	IgnoreWhenBroken: boolean,
	Display: Part?,
}

local DEFAULT_DOOR_STATE: DoorData = {
	Restrictions = {},
	Recover = false,
	Locked = false,
	IgnoreWhenOpen = false,
	IgnoreWhenUnlocked = false,
	IgnoreWhenBroken = false,
}

module.UIState = State(DEFAULT_DOOR_STATE)
function module:UpdateSelectedState(key: string, value: any)
	local newData = {}
	for k, v in pairs(self.UIState._Value) do
		newData[k] = if k ~= key then v else value
	end
	self.UIState:set(newData)
end

-- Data Load/Unload
function module:GetDoorsFromLevel()
	local doors = {}
	local props = workspace.DebugMission.Props:GetChildren()
	for _, part in pairs(props) do
		if string.match(part.Name, "^Door") then
			table.insert(doors, part)
		end
	end
	return doors
end

function module:ReadData(part: Part, side: number)
	local atr = part:GetAttributes()
	local req = atr["PathReq" .. side]
	local data: DoorData = {
		Base = part,
		Side = side,
		Restrictions = {},
		Locked = atr[side == 1 and "LockFront" or "LockBack"],
		Recover = atr.PathRecover and atr.PathRecover % (side + side) >= side or false,
		IgnoreWhenOpen = atr.PathIgnoreOpen and atr.PathIgnoreOpen % (side + side) >= side or false,
		IgnoreWhenUnlocked = atr.PathIgnoreUnlocked and atr.PathIgnoreUnlocked % (side + side) >= side or false,
		IgnoreWhenBroken = atr.PathIgnoreBroken and atr.PathIgnoreBroken % (side + side) >= side or false,
	}
	if req then
		for s in req:gmatch("(%a+)") do
			table.insert(data.Restrictions, s)
		end
	end
	return data
end

local function setBitMaskValue(mask: number, bit: number, enabled: boolean)
	local n = if mask % (bit + bit) >= bit then mask - bit else mask
	if enabled then
		n += bit
	end
	return n
end

function module:WriteData(part: Part, side: number, data: DoorData)
	local atr = part:GetAttributes()
	local req = table.concat(data.Restrictions, " ")
	part:SetAttribute("PathReq" .. side, if req ~= "" then req else nil)

	part:SetAttribute(side == 1 and "LockFront" or "LockBack", data.Locked)

	local recover = setBitMaskValue(atr.PathRecover or 0, side, data.Recover)
	part:SetAttribute("PathRecover", if recover ~= 0 then recover else nil)

	local ignoreOpen = setBitMaskValue(atr.PathIgnoreOpen or 0, side, data.IgnoreWhenOpen)
	part:SetAttribute("PathIgnoreOpen", if ignoreOpen ~= 0 then ignoreOpen else nil)

	local ignoreUnlocked = setBitMaskValue(atr.PathIgnoreUnlocked or 0, side, data.IgnoreWhenUnlocked)
	part:SetAttribute("PathIgnoreUnlocked", if ignoreUnlocked ~= 0 then ignoreUnlocked else nil)

	local ignoreBroken = setBitMaskValue(atr.PathIgnoreBroken or 0, side, data.IgnoreWhenBroken)
	part:SetAttribute("PathIgnoreBroken", if ignoreBroken ~= 0 then ignoreBroken else nil)

	local newData = self:ReadData(part, side)
	newData.Display = self.DoorState[part][side].Display
	self.DoorState[part][side] = newData
	self:UpdateDisplayedData(newData)
end

-- Display
local COLOR_MAP = {
	Unrestricted = Color3.new(0, 0.8, 0),
	Recovery = Color3.new(0, 0.8, 0),
	Unlocked = Color3.new(0, 0.8, 0),
	Combat = Color3.new(0.8, 0, 0),
	Never = Color3.new(0.8, 0, 0),
	Locked = Color3.new(0.8, 0, 0),
}

function module:UpdateDisplayedData(data: DoorData)
	if data.Display then
		data.Display:Destroy()
		data.Display = nil
	end

	local listItems = {}
	table.insert(listItems, data.Locked and "Locked" or "Unlocked")

	if #data.Restrictions == 0 then
		table.insert(listItems, "Unrestricted")
	else
		table.insert(listItems, table.concat(data.Restrictions, " - "))
	end

	if data.Recover then
		table.insert(listItems, "Recovery")
	end

	if data.IgnoreWhenOpen then
		table.insert(listItems, "Ignore When Open")
	end

	if data.IgnoreWhenUnlocked then
		table.insert(listItems, "Ignore When Unlocked")
	end

	if data.IgnoreWhenBroken then
		table.insert(listItems, "Ignore When Broken")
	end

	for index, item in pairs(listItems) do
		listItems[index] = Create("TextLabel", {
			Text = item,
			TextColor3 = COLOR_MAP[item] or Color3.new(1, 1, 1),
			Font = Enum.Font.SciFi,
			TextSize = 42,
			AutomaticSize = Enum.AutomaticSize.XY,
			Size = UDim2.new(0, 0, 0, 0),
			BackgroundTransparency = 1,
			TextWrapped = true,
		})
	end

	if data.Base then
		data.Display = Create("Part", {
			CFrame = data.Base.CFrame * CFrame.Angles(0, data.Side == 2 and math.pi or 0, 0) * CFrame.new(0, 0, -0.5),
			Size = Vector3.new(4, 4, 0.2),
			Parent = workspace,
			Material = Enum.Material.Glass,
			Color = Color3.new(0, 0, 0),
		}, {
			Create("SurfaceGui", {
				PixelsPerStud = 25,
			}, {
				Create("Frame", {
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 1,
				}, {
					Create("UIListLayout", {
						VerticalAlignment = Enum.VerticalAlignment.Center,
						HorizontalAlignment = Enum.HorizontalAlignment.Center,
						Padding = UDim.new(0, 10),
					}),
					listItems,
				}),
			}),
		})
	end
end

-- Input Processing
module.ProcessInput = function(io: InputObject)
	if io.UserInputState == Enum.UserInputState.Begin then
		local door, side = module:GetHoveredDoor()
		if io.UserInputType == Enum.UserInputType.MouseButton1 then
			if door and side then
				print("Overwrite")
				module:WriteData(door, side, module.UIState._Value)
			end
		elseif io.KeyCode == Enum.KeyCode.F or io.KeyCode == Enum.KeyCode.C then
			if door and side then
				print("Copy door data")
				module.UIState:set(module:ReadData(door, side))
			else
				print("Clearing door data")
				module.UIState:set(DEFAULT_DOOR_STATE)
			end
		end
	end
end

function module:GetHoveredDoor(): (Part?, number?)
	local part = self.Mouse.Target
	if part and part:IsA("Part") and self.DoorState[part] then
		local hit = self.Mouse.Hit.Position
		local rel = part.CFrame:PointToObjectSpace(hit)
		return part, if rel.Z < 0 then 1 else 2
	end
	return nil, nil
end

-- UI setup
function module:InitUI()
	local buttons = {
		Button({
			Text = "Locked",
			Enabled = Derived(function(data: DoorData)
				return data.Locked
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("Locked", not self.UIState._Value.Locked)
			end,
		}),
		Button({
			Text = "Recovery",
			Enabled = Derived(function(data: DoorData)
				return data.Recover
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("Recover", not self.UIState._Value.Recover)
			end,
		}),
		Button({
			Text = "Ignore When Open",
			Enabled = Derived(function(data: DoorData)
				return data.IgnoreWhenOpen
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("IgnoreWhenOpen", not self.UIState._Value.IgnoreWhenOpen)
			end,
		}),
		Button({
			Text = "Ignore When Unlocked",
			Enabled = Derived(function(data: DoorData)
				return data.IgnoreWhenUnlocked
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("IgnoreWhenUnlocked", not self.UIState._Value.IgnoreWhenUnlocked)
			end,
		}),
		Button({
			Text = "Ignore When Broken",
			Enabled = Derived(function(data: DoorData)
				return data.IgnoreWhenBroken
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("IgnoreWhenBroken", not self.UIState._Value.IgnoreWhenBroken)
			end,
		}),
	}

	for index, text in pairs(RESTRICTIONS_LIST) do
		table.insert(
			buttons,
			Button({
				Text = text,
				Enabled = Derived(function(data: DoorData)
					for _, restriction in pairs(data.Restrictions) do
						if restriction == text then
							return true
						end
					end
					return false
				end, module.UIState),
				Activated = function()
					local wasRemoved = false
					local copy = {}
					for _, restriction in pairs(module.UIState._Value.Restrictions) do
						if restriction ~= text then
							table.insert(copy, restriction)
						else
							wasRemoved = true
						end
					end
					if not wasRemoved then
						table.insert(copy, text)
					end
					self:UpdateSelectedState("Restrictions", copy)
				end,
			})
		)
	end

	self.UI = Create("ScreenGui", {
		Parent = game:GetService("CoreGui"),
		Archivable = false,
		Name = "DoorAccessConfig",
	}, {
		Create("Frame", {
			Position = UDim2.new(1, -20, 1, -20),
			AnchorPoint = Vector2.new(1, 1),
			Size = UDim2.new(0, 200, 0, 200),
			BackgroundTransparency = 1,
		}, {
			Create("UIListLayout", {
				VerticalAlignment = Enum.VerticalAlignment.Bottom,
				HorizontalAlignment = Enum.HorizontalAlignment.Left,
			}),
			buttons,
		}),
	})
end

function module:CleanUI()
	if self.UI then
		self.UI:Destroy()
		self.UI = nil
	end
end

-- Init/Cleanup
module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	local self = module
	self.Mouse = mouse

	for _, door in pairs(self:GetDoorsFromLevel()) do
		self.DoorState[door] = {
			self:ReadData(door, 1),
			self:ReadData(door, 2),
		}
		self:UpdateDisplayedData(self.DoorState[door][1])
		self:UpdateDisplayedData(self.DoorState[door][2])
	end

	self:InitUI()

	self.InputEvent = UserInputService.InputBegan:Connect(module.ProcessInput)
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	local self = module

	self.InputEvent:Disconnect()
	self.InputEvent = nil

	for _, list in pairs(self.DoorState) do
		for _, data in pairs(list) do
			if data.Display then
				data.Display:Destroy()
			end
		end
	end
	self.DoorState = {}

	self:CleanUI()
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{56C78C82-74E1-4A4D-B58C-BC1A8BF9B7D2}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBXB5F876EB89E94563992F3BD8B2B0AF6A">
			<Properties>
				<ProtectedString name="Source"><![CDATA[-- Infiltration Engine Tooling created by Cishshato
-- Modified by GhfjSpero
-- All Rights Reserved

local toolbar = plugin:CreateToolbar("Infiltration Engine Tools")
local MeadowMapButton = toolbar:CreateButton("Meadow Map", "Meadow Map", "rbxassetid://13749858361")
local DoorAccessButton = toolbar:CreateButton("Door Access", "Door Access", "rbxassetid://72317736899762")
local PropBarrierButton = toolbar:CreateButton("Prop Barrier", "Prop Barrier", "rbxassetid://119815023380659")
local PropPreviewButton = toolbar:CreateButton("Prop Preview", "Prop Preview", "rbxassetid://129506771895350")
local CombatMapButton = toolbar:CreateButton("Combat Flow Map", "Combat Flow Map", "rbxassetid://107812298422418")
local ZoneMarkerButton = toolbar:CreateButton("Cell Marker", "Cell Editor", "rbxassetid://97000446266881")
local AttributeSearchButton = toolbar:CreateButton("Attribute Search", "Attribute Search", "rbxassetid://18733558044")
local SectionVisibilityButton =
	toolbar:CreateButton("Section Visibility", "Section Visibility", "rbxassetid://8753176416")
local TerrainSerializationButton =
	toolbar:CreateButton("Terrain Serialization", "Terrain Serialization", "rbxassetid://115396940325881")

local MeadowMap = require(script.Parent.MeadowMap.Main)
local DoorAccess = require(script.Parent.DoorAccess.Main)
local PropBarrier = require(script.Parent.PropBarrier.Main)
local PropPreview = require(script.Parent.PropPreview.Main)
local CombatMap = require(script.Parent.CombatMap.Main)
local ZoneMarker = require(script.Parent.ZoneMarker.Main)
local AttributeSearch = require(script.Parent.AttributeSearch.Main)
local SectionVisibility = require(script.Parent.SectionVisibility.Main)
local TerrainSerialization = require(script.Parent.TerrainSerialization.Main)
local CurrentPlugin = nil

local VisibilityToggle = require(script.Parent.Util.VisibilityToggle)

local function ConnectPluginToButton(button, pluginModule)
	button.Click:Connect(function()
		if CurrentPlugin ~= pluginModule then
			if CurrentPlugin then
				CurrentPlugin.Clean()
			end
			CurrentPlugin = pluginModule
			plugin:Activate(true)
			pluginModule.Init(plugin:GetMouse())
		else
			plugin:Deactivate()
		end
	end)
end

ConnectPluginToButton(MeadowMapButton, MeadowMap)
ConnectPluginToButton(DoorAccessButton, DoorAccess)
ConnectPluginToButton(PropBarrierButton, PropBarrier)
ConnectPluginToButton(PropPreviewButton, PropPreview)
ConnectPluginToButton(CombatMapButton, CombatMap)
ConnectPluginToButton(ZoneMarkerButton, ZoneMarker)
ConnectPluginToButton(AttributeSearchButton, AttributeSearch)
ConnectPluginToButton(TerrainSerializationButton, TerrainSerialization)

SectionVisibilityButton.Click:Connect(function()
	plugin:Deactivate()
	SectionVisibility.OpenMenu(plugin)
	plugin:Deactivate()
end)

local function disablePlugin()
	MeadowMap.Clean()
	DoorAccess.Clean()
	PropBarrier.Clean()
	PropPreview.Clean()
	CombatMap.Clean()
	ZoneMarker.Clean()
	AttributeSearch.Clean()
	TerrainSerialization.Clean()
	VisibilityToggle.HideTempRevealedParts(workspace:FindFirstChild("DebugMission"))
	CurrentPlugin = nil
end

plugin.Unloading:connect(disablePlugin)
plugin.Deactivation:connect(disablePlugin)
]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{A5B8281D-21B6-4E44-8329-E31247C56C65}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX3E9AFDC6E45149CA9EB8519D1651D9B2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MeadowMap</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX8FA6BE79D8A341BFB133A4593CCDB4B1">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local AxisAlign = require(script.Parent.Parent.Util.AxisAlign)
local ZoneUtil = require(script.Parent.Parent.Util.ZoneUtil)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local UserInputService = game:GetService("UserInputService")
local UserInputConnection

local DOOR_BUFFER = 4.5

local CurrentZone = nil
local CurrentMap = {}
local CurrentModel = nil
local LinkWith = nil

local function CloseZone()
	if CurrentModel then
		CurrentModel:Destroy()
		CurrentModel = nil
	end
	CurrentMap = {}
	CurrentZone = nil
end

local function CheckLOS(p0, p1)
	if p0 == p1 then
		return false
	end
	local result = workspace:Raycast(p0.Position + Vector3.new(0, 0.75, 0), p1.Position - p0.Position)
	return not result or result.Instance == p1
end

local function AddLink(p0, p1)
	local l0 = Instance.new("Part")
	l0.Size = Vector3.new(0.4, 0.4, (p0.Position - p1.Position).magnitude / 2)
	l0.Transparency = 0.5
	local l1 = l0:Clone()

	l0.CFrame = CFrame.new(p0.Position * 0.75 + p1.Position * 0.25, p0.Position)
	if not CurrentMap[p0][p1] then
		CurrentMap[p0][p1] = l0
		l0.BrickColor = BrickColor.new("Bright blue")
		l0.Parent = CurrentModel
	end

	l1.CFrame = CFrame.new(p1.Position * 0.75 + p0.Position * 0.25, p1.Position)
	if not CurrentMap[p1][p0] then
		CurrentMap[p1][p0] = l1
		l1.BrickColor = BrickColor.new("Bright blue")
		l1.Parent = CurrentModel
	end
end

local function AddOneWayLink(p0, p1)
	local l0 = Instance.new("Part")
	l0.Size = Vector3.new(0.4, 0.4, (p0.Position - p1.Position).magnitude / 2)
	l0.Transparency = 0.5

	l0.CFrame = CFrame.new(p0.Position * 0.75 + p1.Position * 0.25, p0.Position)
	if not CurrentMap[p0][p1] then
		CurrentMap[p0][p1] = l0
		l0.BrickColor = BrickColor.new("Bright blue")
		l0.Parent = CurrentModel
	end
end

local function CreateNode(pos, placed, generateLinks)
	if placed and not ZoneUtil.InZone(CurrentZone, pos) then
		warn("Nodes should not be placed outside of their cell")
		return
	end

	local p = Instance.new("Part")
	p.Size = Vector3.new(2, 2, 2)
	p.Parent = CurrentModel
	p.CFrame = CFrame.new(pos)
	p.BrickColor = BrickColor.new("Bright blue")
	if placed then
		p.Transparency = 0.5
	end
	CurrentMap[p] = {}
	if generateLinks then
		for node in pairs(CurrentMap) do
			if node ~= p and CheckLOS(node, p) then
				AddLink(node, p)
			end
		end
	end
	return p
end

local function OpenZone(newZone)
	if CurrentZone then
		CloseZone()
	end

	local DoorNodes = {}
	for _, prop in pairs(workspace.DebugMission.Props:GetChildren()) do
		if prop.Name:match("Door") then
			local p0 = (prop.CFrame * CFrame.new(0, -3, DOOR_BUFFER)).p
			local p1 = (prop.CFrame * CFrame.new(0, -3, -DOOR_BUFFER)).p
			if ZoneUtil.InZone(newZone, p0) then
				table.insert(DoorNodes, p0)
			end
			if ZoneUtil.InZone(newZone, p1) then
				table.insert(DoorNodes, p1)
			end
		end
	end

	if workspace.DebugMission.Cells:FindFirstChild("Links") then
		for _, link in pairs(workspace.DebugMission.Cells.Links:GetChildren()) do
			if link:GetAttribute("Path") then
				local p0 = (link.CFrame * CFrame.new(0, 0.5, DOOR_BUFFER)).p
				local p1 = (link.CFrame * CFrame.new(0, 0.5, -DOOR_BUFFER)).p
				if ZoneUtil.InZone(newZone, p0) then
					table.insert(DoorNodes, p0)
				end
				if ZoneUtil.InZone(newZone, p1) then
					table.insert(DoorNodes, p1)
				end
			end
		end
	end

	CurrentModel = Instance.new("Model")
	CurrentModel.Parent = workspace
	CurrentMap = {}
	CurrentZone = newZone

	for _, pos in pairs(DoorNodes) do
		CreateNode(pos, false, true)
	end

	--[[if CurrentZone:GetAttribute("Path") then
		local data = HttpService:JSONDecode(CurrentZone:GetAttribute("Path"))
		if data.Placed then
			for _, placed in pairs(data.Placed) do
				CreateNode(Vector3.new(unpack(placed)), true, true)
			end
		end
	end]]
end

local function OpenZoneWithoutRegenerating(newZone)
	if CurrentZone then
		CloseZone()
	end

	CurrentModel = Instance.new("Model")
	CurrentModel.Parent = workspace
	CurrentMap = {}
	CurrentZone = newZone

	game.Selection:Set({ newZone })

	if not CurrentZone:GetAttribute("Path") then
		print("Doing first time generation for zone")
		return OpenZone(newZone)
	end

	local data = HttpService:JSONDecode(CurrentZone:GetAttribute("Path"))
	local PlacedNodes = {}
	if data.Placed then
		for _, placed in pairs(data.Placed) do
			local node = Vector3.new(unpack(placed))
			PlacedNodes[node] = true
		end
	end

	local NodeParts = {}
	for _, node in pairs(data.Node) do
		local pos = Vector3.new(unpack(node))
		local nodePart = CreateNode(pos, PlacedNodes[pos], false)
		table.insert(NodeParts, nodePart)
	end

	for startIndex, list in data.Link do
		for _, endIndex in list do
			AddOneWayLink(NodeParts[startIndex], NodeParts[endIndex])
		end
	end
end

local function RemovePart(part)
	if CurrentMap[part] then -- Is node
		for _, linkPart in pairs(CurrentMap[part]) do
			linkPart:Destroy()
		end
		CurrentMap[part] = nil
		for node, links in pairs(CurrentMap) do
			if links[part] then
				links[part]:Destroy()
				links[part] = nil
			end
		end
		part:Destroy()
	else -- Is link
		for node, linkList in pairs(CurrentMap) do
			for link, linkPart in pairs(linkList) do
				if linkPart == part then
					linkPart:Destroy()
					linkList[link] = nil
					break
				end
			end
		end
	end
end

local function Serialize()
	local node = {}
	local nodeId = {}
	local link = {}
	local placed = {}

	local function getNode(p)
		if not nodeId[p] then
			local pos = p.Position
			node[#node + 1] = { pos.X, pos.Y, pos.Z }
			nodeId[p] = #node

			if p.Transparency > 0.25 then
				table.insert(placed, node[#node])
			end
		end
		return nodeId[p]
	end

	for node, linkList in pairs(CurrentMap) do
		local id = getNode(node)
		local links = {}
		for linkNode in pairs(linkList) do
			table.insert(links, getNode(linkNode))
		end
		link[id] = links
	end

	return HttpService:JSONEncode({
		Node = node,
		Link = link,
		Placed = placed,
	})
end

local function Save()
	CurrentZone:SetAttribute("Path", Serialize())
end

local LastCTap = 0

return {
	Init = function(mouse)
		print("T - Open Cell Meadow Map")
		print("C - Fully Clear Meadow Map (Tap twice)")
		print("G - Add Node")
		print("H - Add Node (No Link Generation)")
		print("R - Remove")

		VisibilityToggle.TempReveal(workspace.DebugMission.Cells)

		UserInputConnection = UserInputService.InputBegan:Connect(function(io)
			if io.KeyCode == Enum.KeyCode.C then
				if tick() - LastCTap < 0.5 then
					LastCTap = 0
					local zone = ZoneUtil.GetZone(mouse.Hit.p)
					if zone then
						OpenZone(zone)
						Save()
					end
				else
					LastCTap = tick()
					local clock = LastCTap
					task.delay(0.5, function()
						if clock ~= LastCTap then
							return
						end
						warn(
							"Double tap C to fully clear and regenerate the meadow map for this room\nThis will remove any manual modifications you've made"
						)
					end)
				end
			elseif io.KeyCode == Enum.KeyCode.T then
				local zone = ZoneUtil.GetZone(mouse.Hit.p)
				if zone then
					OpenZoneWithoutRegenerating(zone)
					Save()
				elseif CurrentZone then
					warn("Cursor must be in cell to open meadow map")
					CloseZone()
				end
			elseif io.KeyCode == Enum.KeyCode.G then
				if CurrentZone then
					CreateNode(mouse.Hit.p + Vector3.new(0, 1, 0), true, true)
					Save()
				end
			elseif io.KeyCode == Enum.KeyCode.H then
				if CurrentZone then
					CreateNode(mouse.Hit.p + Vector3.new(0, 1, 0), true, false)
					Save()
				end
			elseif io.KeyCode == Enum.KeyCode.R then
				if mouse.Target then
					RemovePart(mouse.Target)
					Save()
				end
			elseif io.UserInputType == Enum.UserInputType.MouseButton1 then
				if LinkWith then
					if CurrentMap[LinkWith] and CurrentMap[mouse.Target] then
						AddLink(LinkWith, mouse.Target)
						Save()
					else
						print("Link failed")
					end
					LinkWith = nil
				elseif CurrentMap[mouse.Target] then
					LinkWith = mouse.Target
					print("Click another node to link")
				end
			end
		end)
	end,
	Clean = function()
		if UserInputConnection then
			UserInputConnection:Disconnect()
			UserInputConnection = nil
		end
		if CurrentZone then
			CloseZone()
		end
	end,
}
]]></ProtectedString>
					<string name="ScriptGuid">{4E5460BC-40AA-4899-A988-497AF4A3BDF1}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX0EE39AFC2BB744A2A538D2209946AADC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PropBarrier</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2B7E4CD498FF476D89C72E2BC4C57149">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--!strict

local UserInputService = game:GetService("UserInputService")

local Button = require(script.Parent.Parent.Util.Button)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local DEFAULT_COLOR = Color3.fromRGB(163, 162, 165)
local OFF_COLOR = Color3.fromRGB(30, 30, 30)
local ON_COLOR = Color3.fromRGB(0, 170, 170)

local ATTRIBUTE_NAME = "HasTopBarrier"
local PROP_BARRIER = "PropBarrier"

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

local module = {}
module.Active = false
module.DoorState = {}

-- Input Processing
module.ProcessInput = function(self, io)
	if io.UserInputState == Enum.UserInputState.Begin then
		if io.UserInputType == Enum.UserInputType.MouseButton1 then
			local part = self.Mouse.Target
			if part and part.Parent.Name == "Props" then
				local newValue = if part:GetAttribute(ATTRIBUTE_NAME) then nil else true
				part:SetAttribute(ATTRIBUTE_NAME, newValue)
				part.Color = newValue and ON_COLOR or OFF_COLOR
			end
		end
	end
end

local MAX_DIST = 20
local IgnoreList = {}
local CastConfig = RaycastParams.new()
CastConfig.FilterType = Enum.RaycastFilterType.Exclude

module.GetProjectedDistance = function(self, pos: Vector3, dir: Vector3)
	local cast = workspace:Raycast(pos, dir * MAX_DIST, CastConfig)
	local cellsModel = workspace:FindFirstChild("DebugMission")
	cellsModel = cellsModel and cellsModel:FindFirstChild("Cells")
	while
		cast
		and cast.Instance
		and cast.Instance.Transparency > 0.3
		and (not cellsModel or not cast.Instance:IsDescendantOf(cellsModel))
	do
		table.insert(IgnoreList, cast.Instance)
		CastConfig.FilterDescendantsInstances = IgnoreList
		cast = workspace:Raycast(pos, dir * MAX_DIST, CastConfig)
	end

	if cast then
		return cast.Distance
	end

	return MAX_DIST
end

-- Init/Cleanup
module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	if workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild("Props") then
		for _, prop in pairs(workspace.DebugMission.Props:GetDescendants()) do
			if prop:IsA("BasePart") then
				prop.Color = prop:GetAttribute(ATTRIBUTE_NAME) and ON_COLOR or OFF_COLOR
			end
		end

		if workspace.DebugMission:FindFirstChild("Barrier") then
			VisibilityToggle.TempReveal(workspace.DebugMission.Barrier)

			for _, part in pairs(workspace.DebugMission.Barrier:GetChildren()) do
				if part:GetAttribute(PROP_BARRIER) then
					part:Destroy()
				end
			end
		end
	end

	local self = module
	self.Mouse = mouse

	self.InputEvent = UserInputService.InputBegan:Connect(function(io)
		self:ProcessInput(io)
	end)
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	local self = module

	if workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild("Props") then
		for _, prop in pairs(workspace.DebugMission.Props:GetDescendants()) do
			if prop:IsA("BasePart") then
				prop.Color = DEFAULT_COLOR

				if prop:GetAttribute(ATTRIBUTE_NAME) then
					local top = prop.CFrame * CFrame.new(0, prop.Size.Y / 2, 0)
					local dist = module:GetProjectedDistance(top.p, Vector3.yAxis)

					local b = Instance.new("Part")
					b.Color = ON_COLOR
					b.Size = Vector3.new(prop.Size.X, dist, prop.Size.Z)
					b.CFrame = top * CFrame.new(0, dist / 2, 0)
					b.Anchored = true
					b.Transparency = 0.5
					b.TopSurface = Enum.SurfaceType.SmoothNoOutlines
					b.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
					b.CastShadow = false

					b:SetAttribute(PROP_BARRIER, true)

					b.Parent = workspace.DebugMission.Barrier
				end
			end
		end
	end

	self.InputEvent:Disconnect()
	self.InputEvent = nil
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{CF2A5CB3-2CA8-44E0-8269-FE83D1F95A70}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6E9ED1B197024BB4B3E7C537282C63CD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PropPreview</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX83AA44E9FCEB47FC8F96D2EC02BD10AC">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local PhysicsService = game:GetService("PhysicsService")

local COLLISON_GROUP = "PluginNoCollision"

local Button = require(script.Parent.Parent.Util.Button)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable

local CustomPropsFolder = State(false)

local module = {}

local ColorMap = {}
local Prop = {}

local ModelFolder = State(false)
local function UpdateModelFolder()
	local assetsFolder = game.ReplicatedStorage:FindFirstChild("Assets")
	ModelFolder:set(
		assetsFolder and assetsFolder:FindFirstChild("Props") or false
	)
end

-- Position/Color
function module:RepositionProp(part)
	local model = Prop[part]
	model = model and model.Model
	local base = model and model:FindFirstChild("Base", true)

	if not base then
		return
	end

	local diff = part.CFrame * base.CFrame:Inverse()
	for _, p in pairs(model:GetDescendants()) do
		if p:IsA("BasePart") then
			p.CFrame = diff * p.CFrame
		end
	end
end

function module:RecolorProp(part)
	local model = Prop[part]
	model = model and model.Model
	if not model then
		return
	end

	local index = 0
	local search = true
	local colors = {}
	while true do
		local colour = part:GetAttribute("Color" .. index)
		if colour then
			if typeof(colour) == "string" then
				colour = ColorMap[colour]
			end
			colors["Part" .. index] = {
				Color = colour,
				Material = part:GetAttribute("Material" .. index),
			}
			index += 1
		else
			break
		end
	end

	for _, p in pairs(model:GetDescendants()) do
		if p:IsA("BasePart") and colors[p.Name] then
			for prop, value in pairs(colors[p.Name]) do
				p[prop] = value
			end
		end
	end
end

-- Add/Remove

local HiddenModels = {}
local BaseByModel = {}
function module:AddProp(basePart)
	if not basePart:IsA("BasePart") then
		return
	end

	if Prop[basePart] then
		return
	end

	if script.Parent.ScalableProps:FindFirstChild(basePart.Name) then
		basePart.Transparency = 1

		local module = require(script.Parent.ScalableProps[basePart.Name])
		local function generateModel()
			local generator = setmetatable({
				Base = basePart,
				CFrame = basePart.CFrame,
			}, { __index = module })
			generator:InitModel()
			local model = generator.Model
			if not model:FindFirstChild("Base") then
				local p = Instance.new("Part")
				p.Size = Vector3.new(0.2, 0.2, 0.2)
				p.CFrame = basePart.CFrame
				p.Transparency = 1
				p.Name = "Base"
				p.Parent = model
			end
			for _, p in pairs(model:GetDescendants()) do
				if p:IsA("BasePart") then
					p.Archivable = false
					p.CollisionGroup = COLLISON_GROUP
				end
			end
			model.Archivable = false
			return model
		end

		local model = generateModel()
		Prop[basePart] = {
			Model = model,
			Events = {
				basePart:GetPropertyChangedSignal("CFrame"):Connect(function()
					self:RepositionProp(basePart)
				end),
				basePart:GetPropertyChangedSignal("Size"):Connect(function()
					Prop[basePart].Model:Destroy()
					local newModel = generateModel()
					Prop[basePart].Model = newModel
					BaseByModel[newModel] = basePart
					HiddenModels[basePart] = nil
					newModel.Parent = self.Folder
					self:RecolorProp(basePart)
				end),
				basePart.AttributeChanged:Connect(function()
					Prop[basePart].Model:Destroy()
					local newModel = generateModel()
					Prop[basePart].Model = newModel
					BaseByModel[newModel] = basePart
					HiddenModels[basePart] = nil
					newModel.Parent = self.Folder
					self:RecolorProp(basePart)
				end),
			},
		}
		model.Parent = self.Folder
		BaseByModel[model] = basePart
		self:RepositionProp(basePart)
		self:RecolorProp(basePart)
		return
	end

	local storedModel = CustomPropsFolder._Value and CustomPropsFolder._Value:FindFirstChild(basePart.Name)
		or ModelFolder._Value and ModelFolder._Value:FindFirstChild(basePart.Name)
	if storedModel then
		basePart.Transparency = 1

		local model = storedModel:Clone()
		for _, p in pairs(model:GetDescendants()) do
			if p:IsA("BasePart") then
				p.Archivable = false
				p.CollisionGroup = COLLISON_GROUP
			end
		end

		Prop[basePart] = {
			Model = model,
			Events = {
				basePart:GetPropertyChangedSignal("CFrame"):Connect(function()
					self:RepositionProp(basePart)
				end),
				basePart.AttributeChanged:Connect(function()
					HiddenModels[basePart] = nil
					model.Parent = self.Folder
					self:RecolorProp(basePart)
				end),
			},
		}
		model.Parent = self.Folder
		BaseByModel[model] = basePart
		self:RepositionProp(basePart)
		self:RecolorProp(basePart)
	end
end

function module:RemoveProp(basePart)
	if basePart:IsA("BasePart") then
		basePart.Transparency = 0.5
	end

	local propData = Prop[basePart]
	if propData then
		BaseByModel[propData.Model] = nil
		propData.Model:Destroy()
		for _, event in pairs(propData.Events) do
			event:Disconnect()
		end
		Prop[basePart] = nil
	end
end

module.OverlaysEnabled = false
module.EnabledState = State(false)

function module:SetEnabled()
	if self.Enabled then
		return
	end
	self.Enabled = true

	if workspace.DebugMission:FindFirstChild("MissionSetup") then
		local missionData = require(workspace.DebugMission.MissionSetup:Clone())
		ColorMap = missionData.Colors or {}
	end

	module.Folder = workspace:FindFirstChild("PropPreviewModels") or Instance.new("Folder")
	module.Folder.Archivable = false
	module.Folder.Parent = workspace
	module.Folder.Name = "PropPreviewModels"

	PhysicsService:RegisterCollisionGroup(COLLISON_GROUP)
	PhysicsService:CollisionGroupSetCollidable("Default", COLLISON_GROUP, false)

	for _, prop in pairs(workspace.DebugMission.Props:GetDescendants()) do
		module:AddProp(prop)
	end

	module.AddEvents = {
		workspace.DebugMission.Props.DescendantAdded:Connect(function(p)
			self:AddProp(p)
		end),
		workspace.DebugMission.Props.DescendantRemoving:Connect(function(p)
			self:RemoveProp(p)
		end),
		game.Selection.SelectionChanged:Connect(function()
			local selectedParts = {}
			local didSubstitution = false
			for _, part in game.Selection:Get() do
				local sub = BaseByModel[part]
				if sub then
					didSubstitution = true
					selectedParts[sub] = true
				else
					selectedParts[part] = true
				end
			end

			if didSubstitution then
				local newList = {}
				for p in selectedParts do
					table.insert(newList, p)
					game.Selection:Set(newList)
				end
			else
				for base, model in HiddenModels do
					if not selectedParts[base] then
						model.Parent = workspace
						HiddenModels[base] = nil
					end
				end
				for base in selectedParts do
					if Prop[base] then
						HiddenModels[base] = Prop[base].Model
						HiddenModels[base].Parent = nil
					end
				end
			end
		end),
	}
end

local SearchText = State("")
local SearchResults = Derived(function(text, customProps, modelFolder)
	local list = {}
	if modelFolder then
		for _, item in pairs(modelFolder:GetChildren()) do
			if string.lower(item.Name):match(string.lower(text)) then
				table.insert(list, item.Name)
			end
		end
		if customProps then
			for _, item in customProps:GetChildren() do
				if not modelFolder:FindFirstChild(item.Name) and string.lower(item.Name):match(string.lower(text)) then
					table.insert(list, item.Name)
				end
			end
		end
	end
	return list
end, SearchText, CustomPropsFolder, ModelFolder)

function module:SetDisabled()
	if not self.Enabled then
		return
	end
	self.Enabled = false

	module.Folder:Destroy()

	for _, e in pairs(self.AddEvents) do
		e:Disconnect()
	end
	self.AddEvents = nil

	PhysicsService:UnregisterCollisionGroup(COLLISON_GROUP)

	for _, prop in pairs(workspace.DebugMission.Props:GetDescendants()) do
		module:RemoveProp(prop)
	end
end

local function ReplicatedStorageChildrenChanged(child: Instance)
	if not child:IsA("Model") then return end
	if child.Name == "Assets" then UpdateModelFolder() end
end

-- Init/Cleanup
module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true
	
	if not module.ReplicatedChildAddedConnection then
		module.ReplicatedChildAddedConnection = game.ReplicatedStorage.ChildAdded:Connect(ReplicatedStorageChildrenChanged)
	end
	
	if not module.ReplicatedChildRemovedConnection then
		module.ReplicatedChildRemovedConnection = game.ReplicatedStorage.ChildRemoved:Connect(ReplicatedStorageChildrenChanged)
	end
	
	UpdateModelFolder()
	if not ModelFolder._Value then
		warn("No Assets folder found! Please read the Quick Start guide found here:\n\thttps://github.com/MoonstoneSkies/InfiltrationEngine-Custom-Missions/blob/main/README.md")
	end

	CustomPropsFolder:set(
		workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild("CustomProps") or false
	)

	local searchBox
	searchBox = Create("TextBox", {
		PlaceholderText = "Search For Prop",
		Text = "",
		Size = UDim2.new(0, 300, 0, 30),
		Position = UDim2.new(0, 50, 0, 80),
		BorderSizePixel = 0,
		Changed = function()
			if searchBox then
				SearchText:set(searchBox.Text)
			end
		end,
		BackgroundColor3 = Color3.new(1, 1, 1),
		BackgroundTransparency = 0.5,
	})

	module.UI = Create("ScreenGui", {
		Parent = game:GetService("CoreGui"),
		Archivable = false,
	}, {
		Button({
			Size = UDim2.new(0, 300, 0, 30),
			Enabled = module.EnabledState,
			Position = UDim2.new(0, 50, 0, 50),
			Text = Derived(function(e)
				return e and "Disable Prop Preview" or "Enable Prop Preview"
			end, module.EnabledState),
			Activated = function()
				module.OverlaysEnabled = not module.OverlaysEnabled
				module.EnabledState:set(module.OverlaysEnabled)
				if module.OverlaysEnabled then
					module:SetEnabled()
				else
					module:SetDisabled()
				end
			end,
		}),
		searchBox,
		Create("ScrollingFrame", {
			Size = UDim2.new(0, 300, 0.8, -100),
			Position = UDim2.new(0, 50, 0.9, 0),
			AnchorPoint = Vector2.new(0, 1),
			AutomaticCanvasSize = Enum.AutomaticSize.Y,
			BackgroundTransparency = 1,
		}, {
			Create("UIListLayout", {}),
			DerivedTable(function(index, value)
				return Button({
					Text = value,
					Enabled = State(false),
					Activated = function()
						local model = CustomPropsFolder._Value and CustomPropsFolder._Value:FindFirstChild(value)
							or ModelFolder._Value and ModelFolder._Value[value]
						local base = model and model:FindFirstChild("Base")
						if base then
							local prop = base:Clone()
							prop.Name = value
							prop.Transparency = 0.5
							prop.Parent = workspace.DebugMission.Props
							prop.CFrame = CFrame.new((workspace.CurrentCamera.CFrame * CFrame.new(0, 0, -5)).Position)
						end
					end,
					Size = UDim2.new(1, 0, 0, 30),
				})
			end, SearchResults),
		}),
	})
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	if module.ReplicatedChildAddedConnection then
		module.ReplicatedChildAddedConnection:Disconnect()
		module.ReplicatedChildAddedConnection = nil
	end
	
	if module.ReplicatedChildRemovedConnection then 
		module.ReplicatedChildRemovedConnection:Disconnect()
		module.ReplicatedChildRemovedConnection = nil
	end

	module.UI:Destroy()
	module.UI = nil
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{2B5F5BBA-72FA-47B8-9E4B-2E447E9C4770}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX09D2DF475229429FBBEB8F99DFBD0D95">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">ScalableProps</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX75A5BAE446EA46DA812D601AA3CCFC55">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return require(script.Parent.DecorativePipe)
]]></ProtectedString>
						<string name="ScriptGuid">{E269371B-0203-4329-B3B5-4506EE0F9DF5}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ClimbablePipe</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX84C67AFEEBBA4A2090D9640A4D9FDCC4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local RING_DIST = 5

local function addPart(model, baseCFr, offset, size)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = baseCFr * CFrame.new(offset)
	p.Anchored = true
	p.CanCollide = false
	p.Name = "Part0"
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.Metal
	p.CanTouch = false
	p.Parent = model
	p.CollisionGroup = "None"
	p.CastShadow = false
	return p
end

local function addCylinderPart(model, baseCFr, offset, size)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = baseCFr * CFrame.new(offset)
	p.Anchored = true
	p.CanCollide = true
	p.Shape = Enum.PartType.Cylinder
	p.Name = "Part0"
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.Metal
	p.CanTouch = false
	p.Parent = model
	p.CollisionGroup = "None"
	p.CastShadow = false
	return p
end

local function createModel(self)
	self.Base.CollisionGroup = "Default"

	local size = self.Base.Size
	local height = size.Y
	local baseCFr = self.CFrame * CFrame.new(0, height / -2, 0) * CFrame.Angles(0, 0, math.pi / 2)

	local model = Instance.new("Model")

	local POLE_DIAMETER = self.Base.Size.X
	local RING_DIAMETER = POLE_DIAMETER + 0.1

	local bendHeight = height

	if self.Base:GetAttribute("BendTop") or self.Base.Name == "ClimbablePipe" then
		bendHeight = bendHeight - POLE_DIAMETER / 2

		addPart(model, baseCFr, Vector3.new(bendHeight, 0, 0), Vector3.new(POLE_DIAMETER, POLE_DIAMETER, POLE_DIAMETER)).Shape =
			Enum.PartType.Ball

		local bent = addCylinderPart(
			model,
			baseCFr,
			Vector3.new(bendHeight, 0, POLE_DIAMETER / -2),
			Vector3.new(POLE_DIAMETER, POLE_DIAMETER, POLE_DIAMETER)
		)
		bent.CFrame = bent.CFrame * CFrame.Angles(0, math.pi / 2, 0)
	end

	addCylinderPart(
		model,
		baseCFr,
		Vector3.new(bendHeight / 2, 0, 0),
		Vector3.new(bendHeight, POLE_DIAMETER, POLE_DIAMETER)
	).CollisionGroup =
		"Default" -- Main pipe part

	local ringDist = self.Base:GetAttribute("RingSpace") or RING_DIST
	local ringCount = math.floor((bendHeight - 2) / ringDist)

	for i = 0, ringCount do
		local ringHeight = bendHeight / 2 + (i - ringCount / 2) * ringDist
		addCylinderPart(model, baseCFr, Vector3.new(ringHeight, 0, 0), Vector3.new(0.2, RING_DIAMETER, RING_DIAMETER))
		addPart(model, baseCFr, Vector3.new(ringHeight, 0, RING_DIAMETER / -2), Vector3.new(0.2, RING_DIAMETER, 0.2))
	end

	self.Model = model
	self.Parts = model:GetChildren()
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{7BCDBDE8-1E23-459E-A916-C04ACB17B205}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">DecorativePipe</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA78EC755089D4A739FA6AAEC68571349">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local function addPart(model, baseCFr, offset, size)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = baseCFr * CFrame.new(offset)
	p.Anchored = true
	p.CanCollide = true
	p.Name = "Part0"
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.Metal
	p.CanTouch = false
	p.Parent = model
	p.CollisionGroup = "Default"
	p.CastShadow = false
	return p
end

local function addWedgePart(model, baseCFr, offset, size)
	local p = Instance.new("WedgePart")
	p.Size = size
	p.CFrame = baseCFr * CFrame.new(offset)
	p.Anchored = true
	p.CanCollide = false
	p.Name = "Part0"
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.Metal
	p.CanTouch = false
	p.Parent = model
	p.CollisionGroup = "None"
	p.CastShadow = false
	return p
end

local function createModel(self)
	self.Base.CollisionGroup = "Default"

	local size = self.Base.Size
	local height = size.Y
	local baseCFr = self.CFrame * CFrame.new(0, height / -2, 0)

	local model = Instance.new("Model")
	local mainSectionBottom = 0
	local mainSectionTop = height

	local bendTop = self.Base:GetAttribute("BendTop")
	if bendTop == 1 then
		local bendSize = size.Z / 2
		mainSectionTop -= bendSize
		addPart(
			model,
			baseCFr,
			Vector3.new(0, mainSectionTop + bendSize / 2, bendSize / -2),
			Vector3.new(size.X, bendSize, bendSize)
		)
		addWedgePart(
			model,
			baseCFr * CFrame.Angles(0, math.pi, 0),
			Vector3.new(0, mainSectionTop + bendSize / 2, bendSize / -2),
			Vector3.new(size.X, bendSize, bendSize)
		)
	elseif bendTop == 2 then
		local bendSize = size.X / 2
		mainSectionTop -= bendSize
		addPart(
			model,
			baseCFr,
			Vector3.new(bendSize / 2, mainSectionTop + bendSize / 2, 0),
			Vector3.new(bendSize, bendSize, size.Z)
		)
		addWedgePart(
			model,
			baseCFr * CFrame.Angles(0, math.pi / 2, 0),
			Vector3.new(0, mainSectionTop + bendSize / 2, bendSize / -2),
			Vector3.new(size.Z, bendSize, bendSize)
		)
	elseif bendTop == 3 then
		local bendSize = size.X / 2
		mainSectionTop -= bendSize
		addPart(
			model,
			baseCFr,
			Vector3.new(bendSize / -2, mainSectionTop + bendSize / 2, 0),
			Vector3.new(bendSize, bendSize, size.Z)
		)
		addWedgePart(
			model,
			baseCFr * CFrame.Angles(0, math.pi / -2, 0),
			Vector3.new(0, mainSectionTop + bendSize / 2, bendSize / -2),
			Vector3.new(size.Z, bendSize, bendSize)
		)
	end

	local bendBottom = self.Base:GetAttribute("BendBottom")
	if bendBottom == 1 then
		local bendSize = size.Z / 2
		mainSectionBottom += bendSize
		addPart(model, baseCFr, Vector3.new(0, bendSize / 2, bendSize / -2), Vector3.new(size.X, bendSize, bendSize))
		addWedgePart(
			model,
			baseCFr * CFrame.Angles(math.pi, 0, 0),
			Vector3.new(0, bendSize / -2, bendSize / -2),
			Vector3.new(size.X, bendSize, bendSize)
		)
	elseif bendBottom == 2 then
		local bendSize = size.X / 2
		mainSectionBottom += bendSize
		addPart(model, baseCFr, Vector3.new(bendSize / 2, bendSize / 2, 0), Vector3.new(bendSize, bendSize, size.Z))
		addWedgePart(
			model,
			baseCFr * CFrame.Angles(math.pi, math.pi / 2, 0),
			Vector3.new(0, bendSize / -2, bendSize / -2),
			Vector3.new(size.Z, bendSize, bendSize)
		)
	elseif bendBottom == 3 then
		local bendSize = size.X / 2
		mainSectionBottom += bendSize
		addPart(model, baseCFr, Vector3.new(bendSize / -2, bendSize / 2, 0), Vector3.new(bendSize, bendSize, size.Z))
		addWedgePart(
			model,
			baseCFr * CFrame.Angles(math.pi, math.pi / -2, 0),
			Vector3.new(0, bendSize / -2, bendSize / -2),
			Vector3.new(size.Z, bendSize, bendSize)
		)
	end

	addPart(
		model,
		baseCFr,
		Vector3.new(0, (mainSectionTop + mainSectionBottom) / 2, 0),
		Vector3.new(size.X, mainSectionTop - mainSectionBottom, size.Z)
	)

	local ringDepth = self.Base:GetAttribute("RingDepth") or 0
	local ringDist = self.Base:GetAttribute("RingSpace") or 5
	local rings = math.floor((mainSectionTop - mainSectionBottom) / ringDist)
	local ringStart = (mainSectionTop - mainSectionBottom - rings * ringDist) / 2 + mainSectionBottom
	for i = 0, rings do
		local h = ringStart + i * ringDist
		addPart(model, baseCFr, Vector3.new(0, h, size.Z / 2), Vector3.new(size.X + 0.2, 0.3, 0.2))
		addPart(
			model,
			baseCFr,
			Vector3.new(size.X / 2, h, ringDepth / -2 - 0.1),
			Vector3.new(0.2, 0.3, size.Z + ringDepth)
		)
		addPart(
			model,
			baseCFr,
			Vector3.new(size.X / -2, h, ringDepth / -2 - 0.1),
			Vector3.new(0.2, 0.3, size.Z + ringDepth)
		)
	end

	self.Model = model
	self.Parts = model:GetChildren()
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{8ECEDA88-CC57-4A44-85F5-1D53C6FD5D8F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">DecorativeVent</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA1129F660D3D414D900E012B2C42B7F3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local renStep = game:GetService("RunService").RenderStepped

local MOVE_SPEED = 4

local function addPart(model, baseCFr, offset, size)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = baseCFr * CFrame.new(offset)
	p.Anchored = true
	p.CanCollide = true
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.CanTouch = false
	p.Parent = model
	p.CastShadow = false
	return p
end

local function createModel(self)
	local size = self.Base.Size
	local height = size.Y
	local baseCFr = self.CFrame * CFrame.new(0, height / -2, 0)

	local model = Instance.new("Model")

	for row = 0, math.floor(height) do
		local main = addPart(model, baseCFr, Vector3.new(0, row + 0.4, 0), Vector3.new(0.3, 0.8, size.Z))
		main.Material = Enum.Material.DiamondPlate
		main.Name = "Part0"
		local fill = addPart(model, baseCFr, Vector3.new(0, row + 0.9, 0), Vector3.new(0.2, 0.2, size.Z))
		fill.Material = Enum.Material.Metal
		fill.Name = "Part1"
	end

	self.Model = model
	self.Parts = model:GetChildren()
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{D94F8689-858C-49A5-87C0-B42439D14BA4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GarageDoor</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX15DCA4A3F33A4C778D6B7BAD31E4397C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local POLE_DIAMETER = 0.3
local POLE_HEIGHT = 1
local RUNG_DIAMETER = 0.2
local RUNG_SPACING = 0.7
local TOP_DEPTH = 2

local function addPart(model, baseCFr, offset, size)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = baseCFr * CFrame.new(offset)
	p.Anchored = true
	p.CanCollide = false
	p.Name = "Part0"
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.Metal
	p.CanTouch = false
	p.Parent = model
	p.CollisionGroup = "None"
	p.CastShadow = false
	return p
end

local function createModel(self)
	self.Base.CollisionGroup = "Default"

	local size = self.Base.Size
	local center = self.CFrame * CFrame.new(0, 0, (size.Z - POLE_DIAMETER) / 2)

	local model = Instance.new("Model")

	local left, right = (size.X - POLE_DIAMETER) / 2, (size.X - POLE_DIAMETER) / -2
	-- Main poles
	addPart(
		model,
		center,
		Vector3.new(left, POLE_HEIGHT / 2, 0),
		Vector3.new(POLE_DIAMETER, size.Y + POLE_HEIGHT, POLE_DIAMETER)
	)
	addPart(
		model,
		center,
		Vector3.new(right, POLE_HEIGHT / 2, 0),
		Vector3.new(POLE_DIAMETER, size.Y + POLE_HEIGHT, POLE_DIAMETER)
	)
	-- Top Back Poles
	addPart(
		model,
		center,
		Vector3.new(left, (size.Y + POLE_HEIGHT) / 2, -TOP_DEPTH + POLE_DIAMETER),
		Vector3.new(POLE_DIAMETER, POLE_HEIGHT, POLE_DIAMETER)
	)
	addPart(
		model,
		center,
		Vector3.new(right, (size.Y + POLE_HEIGHT) / 2, -TOP_DEPTH + POLE_DIAMETER),
		Vector3.new(POLE_DIAMETER, POLE_HEIGHT, POLE_DIAMETER)
	)
	-- Top Flat Poles
	addPart(
		model,
		center,
		Vector3.new(left, (size.Y - POLE_DIAMETER) / 2 + POLE_HEIGHT, (TOP_DEPTH - POLE_DIAMETER) / -2),
		Vector3.new(POLE_DIAMETER, POLE_DIAMETER, TOP_DEPTH - POLE_DIAMETER - POLE_DIAMETER)
	)
	addPart(
		model,
		center,
		Vector3.new(right, (size.Y - POLE_DIAMETER) / 2 + POLE_HEIGHT, (TOP_DEPTH - POLE_DIAMETER) / -2),
		Vector3.new(POLE_DIAMETER, POLE_DIAMETER, TOP_DEPTH - POLE_DIAMETER - POLE_DIAMETER)
	)

	local rungSize = Vector3.new(size.X - POLE_DIAMETER, RUNG_DIAMETER, RUNG_DIAMETER)
	for l = (size.Y - RUNG_DIAMETER) / 2, (size.Y - 2) / -2, -RUNG_SPACING do
		addPart(model, center, Vector3.new(0, l, 0), rungSize)
	end

	self.Model = model
	self.Parts = model:GetChildren()
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{0B0EEA3C-F4E2-43BD-883F-D0F2B2E6601A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ladder</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5D682F76C8544A718379AEC2D60E0F0D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local ThinBush = require(script.Parent.ThinBush)

local RailWidth = 0.4
local RailWidthHalf = RailWidth / 2
local RailHeight = 0.1

local function addPart(model, cfr, size, name)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = cfr
	p.Anchored = true
	p.CanCollide = true
	p.Name = name
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.SmoothPlastic
	p.CanTouch = false
	p.Parent = model
	p.CastShadow = false
	return p
end

local function createModel(self)
	local size = self.Base.Size
	local height = size.Y + RailHeight
	local baseCFr = self.CFrame * CFrame.new(0, RailHeight / 2, 0)

	local model = Instance.new("Model")

	addPart(
		model,
		baseCFr * CFrame.new(0, 0, size.Z / 2 - RailWidthHalf),
		Vector3.new(size.X - RailWidth * 2, height, RailWidth),
		"Part0"
	)
	addPart(
		model,
		baseCFr * CFrame.new(0, 0, size.Z / -2 + RailWidthHalf),
		Vector3.new(size.X - RailWidth * 2, height, RailWidth),
		"Part0"
	)
	addPart(
		model,
		baseCFr * CFrame.new(size.X / 2 - RailWidthHalf, 0, 0) * CFrame.Angles(0, math.pi / 2, 0),
		Vector3.new(size.Z, height, RailWidth),
		"Part0"
	)
	addPart(
		model,
		baseCFr * CFrame.new(size.X / -2 + RailWidthHalf, 0, 0) * CFrame.Angles(0, math.pi / 2, 0),
		Vector3.new(size.Z, height, RailWidth),
		"Part0"
	)
	addPart(
		model,
		baseCFr,
		Vector3.new(size.X - RailWidth - RailWidth, height - RailHeight - RailHeight, size.Z - RailWidth - RailWidth),
		"Part1"
	).Material =
		Enum.Material.Pebble

	local base = self.Base
	local attributes = self.Base:GetAttributes()
	local height = attributes.PlantHeight or 3
	local width = attributes.PlantWidth or 0
	if height > 0 then
		local p = Instance.new("Part")
		p.Name = "ThinBush"
		p.CFrame = base.CFrame * CFrame.new(0, base.Size.Y / 2 + height / 2, 0)
		p.Size = Vector3.new(base.Size.X + width, height, base.Size.Z + width)
		local generator = setmetatable({
			Base = p,
			CFrame = p.CFrame,
		}, { __index = ThinBush })
		generator:InitModel()
		generator.Model.Parent = model
	end

	self.Model = model
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{3D8B1849-20BE-4637-8E4D-5048CDB6DBD2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ScalablePlanter</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF05EA8A4C9A744AB8E555E8F3CDFA543">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local ThinBush = require(script.Parent.ThinBush)

local RailWidth = 0.2
local RailWidthHalf = RailWidth / 2
local RailHeight = 0.1

local function addPart(model, cfr, size, name)
	local p = Instance.new("Part")
	p.Size = size
	p.CFrame = cfr
	p.Anchored = true
	p.CanCollide = true
	p.Name = name
	p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
	p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
	p.Material = Enum.Material.SmoothPlastic
	p.CanTouch = false
	p.Parent = model
	p.CastShadow = false
	return p
end

local function createModel(self)
	local size = self.Base.Size
	local height = size.Y + RailHeight
	local baseCFr = self.CFrame * CFrame.new(0, RailHeight / 2, 0)

	local model = Instance.new("Model")

	-- Sides
	addPart(
		model,
		baseCFr * CFrame.new(RailWidthHalf, 0, size.Z / 2 - RailWidthHalf),
		Vector3.new(size.X - RailWidth, height, RailWidth),
		"Part0"
	)
	addPart(
		model,
		baseCFr * CFrame.new(RailWidthHalf, 0, size.Z / -2 + RailWidthHalf),
		Vector3.new(size.X - RailWidth, height, RailWidth),
		"Part0"
	)
	addPart(
		model,
		baseCFr * CFrame.new(size.X / -2 + RailWidthHalf, 0, 0) * CFrame.Angles(0, math.pi / 2, 0),
		Vector3.new(size.Z, height, RailWidth),
		"Part0"
	)

	-- bottom
	addPart(
		model,
		baseCFr * CFrame.new(RailWidthHalf, size.Y / -2 + RailWidthHalf, 0) * CFrame.Angles(0, math.pi / 2, 0),
		Vector3.new(size.Z - RailWidth - RailWidth, RailWidth, size.X - RailWidth),
		"Part0"
	)

	addPart(
		model,
		baseCFr * CFrame.new(RailWidthHalf, 0, 0),
		Vector3.new(size.X - RailWidth, height - RailHeight - RailHeight, size.Z - RailWidth - RailWidth),
		"Part1"
	).Material =
		Enum.Material.Pebble

	local base = self.Base
	local attributes = self.Base:GetAttributes()
	local height = attributes.PlantHeight or 3
	local width = attributes.PlantWidth or 0
	if height > 0 then
		local p = Instance.new("Part")
		p.Name = "ThinBush"
		p.CFrame = base.CFrame * CFrame.new(0, base.Size.Y / 2 + height / 2, 0)
		p.Size = Vector3.new(base.Size.X + width, height, base.Size.Z + width)
		local generator = setmetatable({
			Base = p,
			CFrame = p.CFrame,
		}, { __index = ThinBush })
		generator:InitModel()
		generator.Model.Parent = model
	end

	self.Model = model
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{8AEAF9E2-5010-4308-BF88-2BB9F0879D7D}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ScalableWallPlanter</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC4737354DA934744BB915A7DB74DEF49">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local leaves = Instance.new("Part")
leaves.BrickColor = BrickColor.new("Slime green")
leaves.Transparency = 0.05
leaves.CanCollide = false
leaves.Anchored = true
leaves.Size = Vector3.new(0.05, 0.05, 0.05)
leaves.Name = "Bush"

local leavesMesh = Instance.new("SpecialMesh")
leavesMesh.MeshType = Enum.MeshType.FileMesh
leavesMesh.MeshId = "rbxassetid://1091940"
leavesMesh.TextureId = "rbxassetid://140397573"

local function createModel(self)
	local expectedSize = self.Base.Size
	local model = Instance.new("Model")

	local variance = 0.2
	local spacing = 1.2

	local part = leaves:Clone()
	local mesh = leavesMesh:Clone()
	mesh.Scale = Vector3.new(expectedSize.X * 0.5, expectedSize.Y, expectedSize.X * 0.5)
	mesh.Parent = part

	local function plant(cfr)
		local l = part:Clone()
		local mesh = l:FindFirstChildOfClass("SpecialMesh")
		local factor = math.noise(cfr.p.X, cfr.p.Y, cfr.p.Z)
		mesh.Scale = Vector3.new(mesh.Scale.X, mesh.Scale.Y * (1 + factor * variance), mesh.Scale.Z)
		l.CFrame = cfr * CFrame.new(0, mesh.Scale.Y * 0.15, 0) * CFrame.Angles(0, factor * 10, 0)
		l.Parent = model
	end

	local dist = expectedSize.Z - expectedSize.X
	local minDist = dist / -2
	local cuts = math.ceil(dist / spacing)

	for x = 0, cuts do
		plant(self.Base.CFrame * CFrame.new(0, 0, minDist + (x / cuts) * dist))
	end

	self.Model = model
	self.Parts = model:GetChildren()
end

return {
	InitModel = createModel,
}
]]></ProtectedString>
						<string name="ScriptGuid">{9922CDC8-7D18-4BB4-9DEA-F3310AD9F45F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ThinBush</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF673F0E845734CF9B6CBCACDC318DB07">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local FRAME_WIDTH = 0.2

local function createServerGlass(self)
	local base = self.Base
	local attributes = base:GetAttributes()
	local bulletproof = base:GetAttribute("Bulletproof")

	local glass = Instance.new("Part")
	glass.Size = Vector3.new(
		base.Size.Z - (if attributes.NoFrame then 0 else FRAME_WIDTH * 2),
		base.Size.Y - (if attributes.NoFrame then 0 else FRAME_WIDTH * 2)
	)
	glass.CastShadow = false
	glass.CFrame = base.CFrame * CFrame.Angles(0, math.pi / 2, 0)
	glass.Anchored = true
	glass.Color = base:GetAttribute("GlassColor") or Color3.new(0, 0, 0)
	glass.Transparency = 0.8
	glass.Reflectance = 0.2
	glass.Material = Enum.Material.SmoothPlastic

	local size = base.Size
	local center = base.CFrame
	local model = Instance.new("Model")
	local material = base:GetAttribute("Material0") or "Metal"

	local function addPart(model, baseCFr, offset, size)
		local p = Instance.new("Part")
		p.Size = size
		p.CFrame = baseCFr * CFrame.new(offset)
		p.Anchored = true
		p.Name = "Part0"
		p.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		p.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		p.Material = Enum.Material.Metal
		p.CanTouch = false
		p.Parent = model
		p.CastShadow = false
		p.Material = material
		return p
	end

	if not attributes.NoFrame then
		addPart(model, center, Vector3.new(0, (size.Y - FRAME_WIDTH) / 2, 0), Vector3.new(size.X, FRAME_WIDTH, size.Z))
		addPart(model, center, Vector3.new(0, (size.Y - FRAME_WIDTH) / -2, 0), Vector3.new(size.X, FRAME_WIDTH, size.Z))
		addPart(
			model,
			center,
			Vector3.new(0, 0, (size.Z - FRAME_WIDTH) / 2),
			Vector3.new(size.X, size.Y - FRAME_WIDTH * 2, FRAME_WIDTH)
		)
		addPart(
			model,
			center,
			Vector3.new(0, 0, (size.Z - FRAME_WIDTH) / -2),
			Vector3.new(size.X, size.Y - FRAME_WIDTH * 2, FRAME_WIDTH)
		)
	end

	if bulletproof then
		glass.Parent = model
		glass.CollisionGroup = "Clear"
		glass:SetAttribute("CanDestroy", true)

		local p = addPart(
			model,
			center,
			Vector3.new(),
			Vector3.new(
				0.1,
				size.Y - (if attributes.NoFrame then 0 else FRAME_WIDTH),
				size.Z - (if attributes.NoFrame then 0 else FRAME_WIDTH)
			)
		)
		p.Material = Enum.Material.Concrete
		p.CollisionGroup = "None"
		p.Transparency = 0.9

		local texture = Instance.new("Texture")
		texture.Texture = "rbxassetid://5009999"
		texture.StudsPerTileU = 2
		texture.StudsPerTileV = 2
		texture.Face = Enum.NormalId.Left
		texture.Parent = p

		texture = texture:Clone()
		texture.Face = Enum.NormalId.Right
		texture.Parent = p

		p.Parent = model
	else
		glass.Name = "Glass"
		glass.Parent = model
	end

	self.Model = model
end

return {
	InitModel = createServerGlass,
}
]]></ProtectedString>
						<string name="ScriptGuid">{C8D90814-872C-4578-B44E-804A25368A2E}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Window</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX3ABD0ED6590042AFB2177814EA7634ED">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SectionVisibility</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX9369C79D851F4CD39DE042DCCC8050EB">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)
local sections = { "Barrier", "Cells", "Nodes", "LoudSpawns", "CombatFlowMap" }

local cache = {}

return {
	OpenMenu = function(plugin)
		local menu = cache.Menu or plugin:CreatePluginMenu("SectionVisibilityMenu")
		cache.Menu = menu
		menu:Clear()

		for _, section in sections do
			local instance = workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild(section)
			if not instance then
				continue
			end
			local hidden = VisibilityToggle.IsHidden(instance)
			local action = if hidden then "Show" else "Hide"
			local id = `SectionVisibility_{section}_{action}`
			local option = cache[id]
			if not option then
				option = plugin:CreatePluginAction(id, `{action} {section}`, "")
				option.Triggered:Connect(function()
					if hidden then
						VisibilityToggle.Reveal(workspace.DebugMission:FindFirstChild(section))
					else
						VisibilityToggle.Hide(workspace.DebugMission:FindFirstChild(section))
					end
				end)
				cache[id] = option
			end
			menu:AddAction(option)
		end

		if not cache.ShowAll then
			local ShowAll = plugin:CreatePluginAction("SectionVisibility_ShowAll", "Show All", "")
			ShowAll.Triggered:Connect(function()
				if not workspace:FindFirstChild("DebugMission") then
					return
				end
				for _, section in sections do
					local part = workspace.DebugMission:FindFirstChild(section)
					if part then
						VisibilityToggle.Reveal(part)
					end
				end
			end)
			local HideAll = plugin:CreatePluginAction("SectionVisibility_HideAll", "Hide All", "")
			HideAll.Triggered:Connect(function()
				if not workspace:FindFirstChild("DebugMission") then
					return
				end
				for _, section in sections do
					local part = workspace.DebugMission:FindFirstChild(section)
					if part then
						VisibilityToggle.Hide(part)
					end
				end
			end)

			cache.ShowAll = ShowAll
			cache.HideAll = HideAll
		end

		menu:AddAction(cache.ShowAll)
		menu:AddAction(cache.HideAll)
		menu:ShowAsync()
	end,
}
]]></ProtectedString>
					<string name="ScriptGuid">{27F5167C-6B13-4372-95E8-03022440A218}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXF8CB73B9F98C4DFD88DA844101A18F23">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">TerrainSerialization</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX6F2482339FBA4C369855E2D50A5AEAF4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local module = {}

local TerrainSerialization = require(script.Parent.TerrainSerialization)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable

function module:GetTerrainFolder()
	if not workspace:FindFirstChild("DebugMission") then
		return
	end
	if not workspace.DebugMission:FindFirstChild("TerrainData") then
		Create("Folder", {
			Name = "TerrainData",
			Parent = workspace.DebugMission,
		})
	end
	return workspace.DebugMission.TerrainData
end

function module:GetTerrainBounds()
	local areaMin, areaMax = Vector3.new(-10, -2, -10), Vector3.new(10, 2, 10)
	local dataFolder = self:GetTerrainFolder()
	if dataFolder then
		if workspace.DebugMission:FindFirstChild("TerrainBounds") then
			areaMin, areaMax = TerrainSerialization:GetCoordinateBoundsFromPart(workspace.DebugMission.TerrainBounds)
			dataFolder:SetAttribute("BoundsMin", areaMin)
			dataFolder:SetAttribute("BoundsMax", areaMax)
		else
			local savedMin, savedMax = dataFolder:GetAttribute("BoundsMin"), dataFolder:GetAttribute("BoundsMax")
			if savedMin then
				areaMin = savedMin
			else
				dataFolder:SetAttribute("BoundsMin", areaMin)
			end
			if savedMax then
				areaMax = savedMax
			else
				dataFolder:SetAttribute("BoundsMax", areaMax)
			end
		end
	end
	return areaMin, areaMax
end

function module.Init(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	module.UI = Create("ScreenGui", {
		Parent = game.CoreGui,
		Archivable = false,
	}, {
		Create("Frame", {
			Size = UDim2.new(0, 300, 1, -100),
			Position = UDim2.new(0, 20, 0.5, 0),
			AnchorPoint = Vector2.new(0, 0.5),
			BackgroundTransparency = 1,
		}, {
			Create("UIListLayout", {
				Padding = UDim.new(0, 20),
			}),
			Create("TextButton", {
				Size = UDim2.new(1, 0, 0, 50),
				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.4,
				BorderSizePixel = 0,
				Text = "Save Terrain Data To Mission",
				TextColor3 = Color3.new(1, 1, 1),
				Activated = function()
					local dataFolder = module:GetTerrainFolder()
					local areaMin, areaMax = module:GetTerrainBounds()
					TerrainSerialization:SaveArea(dataFolder, areaMin, areaMax)
				end,
			}),
			Create("TextButton", {
				Size = UDim2.new(1, 0, 0, 50),
				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.4,
				BorderSizePixel = 0,
				Text = "Load Terrain Data From Mission To Workspace",
				TextColor3 = Color3.new(1, 1, 1),
				Activated = function()
					local dataFolder = module:GetTerrainFolder()
					TerrainSerialization:LoadArea(dataFolder)
				end,
			}),
		}),
	})
end

function module.Clean()
	module.Active = false
	if module.UI then
		module.UI:Destroy()
		module.UI = nil
	end
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{5640AD88-8C49-4FB0-A29E-8B8DA2DE8632}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF515E9EFCC244B4DA5D07D330B8877D6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local MaterialId

MaterialId = {
	Asphalt = 1,
	Basalt = 2,
	Brick = 3,
	Cobblestone = 4,
	Concrete = 5,
	CorrodedMetal = 6,
	CrackedLava = 7,
	DiamondPlate = 8,
	Fabric = 9,
	Foil = 10,
	ForceField = 11,
	Glacier = 12,
	Glass = 13,
	Granite = 14,
	Grass = 15,
	Ground = 16,
	Ice = 17,
	LeafyGrass = 18,
	Limestone = 19,
	Marble = 20,
	Metal = 21,
	Mud = 22,
	Neon = 23,
	Pavement = 24,
	Pebble = 25,
	Plastic = 26,
	Rock = 27,
	Salt = 28,
	Sand = 29,
	Sandstone = 30,
	Slate = 31,
	SmoothPlastic = 32,
	Snow = 33,
	Wood = 34,
	WoodPlanks = 35,
	ClayRoofTiles = 36,
	Carpet = 37,
	Cardboard = 38,
	CeramicTiles = 39,
	RoofShingles = 40,
	Leather = 41,
	Plaster = 42,
	Rubber = 43,
	Air = 44,
}

for _, material in Enum.Material:GetEnumItems() do
	if MaterialId[material.Name] then
		local id = MaterialId[material.Name]
		MaterialId[material] = id
		MaterialId[id] = material
	end
end

return MaterialId
]]></ProtectedString>
					<string name="ScriptGuid">{7F95B384-A7AF-4821-926E-10F4EEED4729}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">MaterialReference</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7962ABBD198D474B8155FDD36CDA51FB">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local MaterialId = require(script.Parent.MaterialReference)

local BLOCK_SIZE = 16
local VOXEL_SIZE = 4

local BLOCK_STUD_SIZE = BLOCK_SIZE * VOXEL_SIZE
local BLOCK_STUD_HALF_SIZE = BLOCK_STUD_SIZE / 2

local BUFFER_OFFSET = 32 -- Avoiding adding control characters to the buffer
local BUFFER_RANGE = 127 - BUFFER_OFFSET

local StandardAttributes = {
	WaterColor = true,
	WaterTransparency = true,
	WaterReflectance = true,
	WaterWaveSize = true,
	WaterWaveSpeed = true,
}

local SaveMaterialColors = {
	Enum.Material.Asphalt,
	Enum.Material.Basalt,
	Enum.Material.Brick,
	Enum.Material.Cobblestone,
	Enum.Material.Concrete,
	Enum.Material.CrackedLava,
	Enum.Material.Glacier,
	Enum.Material.Grass,
	Enum.Material.Ground,
	Enum.Material.Ice,
	Enum.Material.LeafyGrass,
	Enum.Material.Limestone,
	Enum.Material.Mud,
	Enum.Material.Pavement,
	Enum.Material.Rock,
	Enum.Material.Salt,
	Enum.Material.Sand,
	Enum.Material.Sandstone,
	Enum.Material.Slate,
	Enum.Material.Snow,
	Enum.Material.WoodPlanks,
}

local module = {
	GetCoordinateBoundsFromPart = function(self, basePart)
		local minX, minY, minZ
		minX = math.round(basePart.Position.X / BLOCK_STUD_SIZE)
		minY = math.round(basePart.Position.Y / BLOCK_STUD_SIZE)
		minZ = math.round(basePart.Position.Z / BLOCK_STUD_SIZE)
		local maxX, maxY, maxZ = minX, minY, minZ

		local halfSize = basePart.Size / 2
		for x = -1, 1, 2 do
			for y = -1, 1, 2 do
				for z = -1, 1, 2 do
					local corner =
						basePart.CFrame:PointToWorldSpace(Vector3.new(x * halfSize.X, y * halfSize.Y, z * halfSize.Z))
					minX = math.min(minX, math.round(corner.X / BLOCK_STUD_SIZE))
					maxX = math.max(maxX, math.round(corner.X / BLOCK_STUD_SIZE))
					minY = math.min(minY, math.round(corner.Y / BLOCK_STUD_SIZE))
					maxY = math.max(maxY, math.round(corner.Y / BLOCK_STUD_SIZE))
					minZ = math.min(minZ, math.round(corner.Z / BLOCK_STUD_SIZE))
					maxZ = math.max(maxZ, math.round(corner.Z / BLOCK_STUD_SIZE))
				end
			end
		end

		return Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ)
	end,
	GetBlockRegion = function(self, coordinates)
		local basePos = coordinates * BLOCK_STUD_SIZE
		local rangeMin = basePos + Vector3.new(-BLOCK_STUD_HALF_SIZE, -BLOCK_STUD_HALF_SIZE, -BLOCK_STUD_HALF_SIZE)
		local rangeMax = basePos + Vector3.new(BLOCK_STUD_HALF_SIZE, BLOCK_STUD_HALF_SIZE, BLOCK_STUD_HALF_SIZE)
		return Region3.new(rangeMin, rangeMax)
	end,
	HasData = function(self, channel)
		for x = 1, BLOCK_SIZE do
			for y = 1, BLOCK_SIZE do
				for z = 1, BLOCK_SIZE do
					if channel[x][y][z] ~= 0 then
						return true
					end
				end
			end
		end
		return false
	end,
	CompressChannel = function(self, channel)
		local counts = {}
		local values = {}
		local lastValue = channel[1][1][1]
		local sequenceLength = 0
		for x = 1, BLOCK_SIZE do
			for y = 1, BLOCK_SIZE do
				for z = 1, BLOCK_SIZE do
					local value = channel[x][y][z]
					if value ~= lastValue or sequenceLength == BUFFER_RANGE then
						table.insert(counts, sequenceLength)
						table.insert(values, lastValue)
						lastValue = value
						sequenceLength = 0
					end
					sequenceLength += 1
				end
			end
		end

		table.insert(counts, sequenceLength)
		table.insert(values, lastValue)

		local channelBuffer = buffer.create(#counts * 2)
		for index, count in counts do
			buffer.writeu8(channelBuffer, index * 2 - 2, count + BUFFER_OFFSET)
			buffer.writeu8(channelBuffer, index * 2 - 1, values[index] + BUFFER_OFFSET)
		end

		return buffer.tostring(channelBuffer)
	end,
	DecompressChannel = function(self, channelDataString)
		local channelBuffer = buffer.fromstring(channelDataString)

		local applyCount = buffer.readu8(channelBuffer, 0) - BUFFER_OFFSET
		local applyValue = buffer.readu8(channelBuffer, 1) - BUFFER_OFFSET

		local readIndex = 2
		local bufferLen = buffer.len(channelBuffer)

		local channel = {}
		for x = 1, BLOCK_SIZE do
			channel[x] = {}
			for y = 1, BLOCK_SIZE do
				channel[x][y] = {}
				for z = 1, BLOCK_SIZE do
					if applyCount <= 0 and readIndex < bufferLen then
						applyCount = buffer.readu8(channelBuffer, readIndex) - BUFFER_OFFSET
						applyValue = buffer.readu8(channelBuffer, readIndex + 1) - BUFFER_OFFSET
						readIndex += 2
					end
					applyCount -= 1
					channel[x][y][z] = applyValue
				end
			end
		end

		return channel
	end,
	TransformChannel = function(self, channel, modify)
		for x = 1, BLOCK_SIZE do
			for y = 1, BLOCK_SIZE do
				for z = 1, BLOCK_SIZE do
					channel[x][y][z] = modify(channel[x][y][z])
				end
			end
		end
		return channel
	end,
	SaveBlock = function(self, coordinates)
		local channels = workspace.Terrain:ReadVoxelChannels(
			self:GetBlockRegion(coordinates),
			VOXEL_SIZE,
			{ "SolidMaterial", "SolidOccupancy", "LiquidOccupancy" }
		)

		local hasWater = self:HasData(channels.LiquidOccupancy)
		local hasLand = self:HasData(channels.SolidOccupancy)
		if not hasLand and not hasWater then
			return
		end

		local folder = Instance.new("Folder")
		folder.Name = `{coordinates.X},{coordinates.Y},{coordinates.Z}`
		folder:SetAttribute("Coordinates", coordinates)
		if hasLand then
			folder:SetAttribute(
				"SolidMaterial",
				self:CompressChannel(self:TransformChannel(channels.SolidMaterial, function(material)
					return MaterialId[material] or MaterialId.Air
				end))
			)
			folder:SetAttribute(
				"SolidOccupancy",
				self:CompressChannel(self:TransformChannel(channels.SolidOccupancy, function(occupancy)
					return math.round(occupancy * BUFFER_RANGE)
				end))
			)
		end
		if hasWater then
			folder:SetAttribute(
				"LiquidOccupancy",
				self:CompressChannel(self:TransformChannel(channels.LiquidOccupancy, function(occupancy)
					return math.round(occupancy * BUFFER_RANGE)
				end))
			)
		end

		return folder
	end,
	LoadBlock = function(self, dataFolder)
		local attributes = dataFolder:GetAttributes()
		local coordinates = attributes.Coordinates
		local channels = {
			SolidMaterial = if attributes.SolidMaterial
				then self:TransformChannel(self:DecompressChannel(attributes.SolidMaterial), function(id)
					return MaterialId[id] or Enum.Material.Air
				end)
				else nil,
			SolidOccupancy = if attributes.SolidOccupancy
				then self:TransformChannel(self:DecompressChannel(attributes.SolidOccupancy), function(occupancy)
					return occupancy / BUFFER_RANGE
				end)
				else nil,
			LiquidOccupancy = if attributes.LiquidOccupancy
				then self:TransformChannel(self:DecompressChannel(attributes.LiquidOccupancy), function(occupancy)
					return occupancy / BUFFER_RANGE
				end)
				else nil,
		}

		workspace.Terrain:WriteVoxelChannels(self:GetBlockRegion(coordinates), 4, channels)
	end,

	SaveArea = function(self, dataFolder, areaMin, areaMax)
		local clearedOldData = false

		local minX, maxX = math.min(areaMin.X, areaMax.X), math.max(areaMin.X, areaMax.X)
		local minY, maxY = math.min(areaMin.Y, areaMax.Y), math.max(areaMin.Y, areaMax.Y)
		local minZ, maxZ = math.min(areaMin.Z, areaMax.Z), math.max(areaMin.Z, areaMax.Z)

		local blocksRead = 0
		local blocksTotal = (maxX - minX + 1) * (maxY - minY + 1) * (maxZ - minZ + 1)

		for x = minX, maxX do
			for y = minY, maxY do
				for z = minZ, maxZ do
					blocksRead += 1
					print(`Saving block {blocksRead} of {blocksTotal} ({math.floor(blocksRead / blocksTotal * 100)}%)`)
					if blocksRead % 20 == 0 then
						task.wait()
					end

					local folder = self:SaveBlock(Vector3.new(x, y, z))
					if folder then
						if not clearedOldData then
							clearedOldData = true
							dataFolder:ClearAllChildren()
						end
						folder.Parent = dataFolder
					end
				end
			end
		end

		if clearedOldData then
			for attribute in StandardAttributes do
				dataFolder:SetAttribute(attribute, workspace.Terrain[attribute])
			end
			for _, material in SaveMaterialColors do
				dataFolder:SetAttribute(material.Name, workspace.Terrain:GetMaterialColor(material))
			end
		end

		if not clearedOldData and next(dataFolder:GetChildren()) then
			warn(
				"No terrain found. If you're trying to delete the terrain from this mission, manually delete the TerrainData folder"
			)
		end
	end,
	LoadArea = function(self, dataFolder)
		for _, blockData in dataFolder:GetChildren() do
			self:LoadBlock(blockData)
		end

		for attribute in StandardAttributes do
			local value = dataFolder:GetAttribute(attribute)
			if value ~= nil then
				workspace.Terrain[attribute] = value
			end
		end
		for _, material in SaveMaterialColors do
			local loadedColor = dataFolder:GetAttribute(material.Name)
			if loadedColor then
				workspace.Terrain:SetMaterialColor(material, loadedColor)
			end
		end
	end,
	DeleteArea = function(self, areaMin, areaMax)
		local channels = {
			SolidMaterial = {},
			SolidOccupancy = {},
			LiquidOccupancy = {},
		}
		for x = 1, BLOCK_SIZE do
			channels.SolidMaterial[x] = {}
			channels.SolidOccupancy[x] = {}
			channels.LiquidOccupancy[x] = {}
			for y = 1, BLOCK_SIZE do
				channels.SolidMaterial[x][y] = {}
				channels.SolidOccupancy[x][y] = {}
				channels.LiquidOccupancy[x][y] = {}
				for z = 1, BLOCK_SIZE do
					channels.SolidMaterial[x][y][z] = Enum.Material.Air
					channels.SolidOccupancy[x][y][z] = 0
					channels.LiquidOccupancy[x][y][z] = 0
				end
			end
		end

		local minX, maxX = math.min(areaMin.X, areaMax.X), math.max(areaMin.X, areaMax.X)
		local minY, maxY = math.min(areaMin.Y, areaMax.Y), math.max(areaMin.Y, areaMax.Y)
		local minZ, maxZ = math.min(areaMin.Z, areaMax.Z), math.max(areaMin.Z, areaMax.Z)

		for x = minX, maxX do
			for y = minY, maxY do
				for z = minZ, maxZ do
					workspace.Terrain:WriteVoxelChannels(self:GetBlockRegion(Vector3.new(x, y, z)), 4, channels)
				end
			end
		end
	end,
	DeleteCoordinates = function(self, coordinates)
		local channels = {
			SolidMaterial = {},
			SolidOccupancy = {},
			LiquidOccupancy = {},
		}
		for x = 1, BLOCK_SIZE do
			channels.SolidMaterial[x] = {}
			channels.SolidOccupancy[x] = {}
			channels.LiquidOccupancy[x] = {}
			for y = 1, BLOCK_SIZE do
				channels.SolidMaterial[x][y] = {}
				channels.SolidOccupancy[x][y] = {}
				channels.LiquidOccupancy[x][y] = {}
				for z = 1, BLOCK_SIZE do
					channels.SolidMaterial[x][y][z] = Enum.Material.Air
					channels.SolidOccupancy[x][y][z] = 0
					channels.LiquidOccupancy[x][y][z] = 0
				end
			end
		end

		for _, coordinate in coordinates do
			workspace.Terrain:WriteVoxelChannels(self:GetBlockRegion(coordinate), 4, channels)
		end
	end,
}

return module
]]></ProtectedString>
					<string name="ScriptGuid">{D3EA6869-E882-4F80-B70B-FBE9CB3E8996}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">TerrainSerialization</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXB3D641C72E4847C89A7A4BB6A1672C5D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Util</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2FA962E69F9D42C4B83E40FACB507CA2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local module = {
	Create = require(script._ActorCreation._Create),

	State = require(script._ActorState._State),
	Derived = require(script._ActorState._Derived),
	DerivedTable = require(script._ActorState._DerivedTable),
	Watch = require(script._ActorState._Watch),

	Spring = require(script._ActorAnim._ActorSpring),
	Cubic = require(script._ActorAnim._Cubic),

	OnChange = require(script._OnChange),
}

return module]]></ProtectedString>
					<string name="ScriptGuid">{0ECB5BEF-DE61-4BA9-B8F8-8BBB76B6FB59}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Actor</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX07932C934CB0421C95F6B92DA866665C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorAnim</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX941257E61A0943DA8644FBDAE0C8EFB0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local AnimRunner = require(script.Parent._Anim)

local numberClose = function(x, y)
	return math.abs(x - y) < 0.01
end
local vectorClose = function(x, y)
	return (x - y).magnitude < 0.01
end
local udim2Close = function(x, y)
	local rel = x - y
	return math.abs(rel.X.Offset) <= 1 and math.abs(rel.Y.Offset) <= 1 and math.abs(rel.X.Scale) < 0.01 and math.abs(rel.Y.Scale) < 0.01 
end

local function getStartingVelocityByType(value)
	if typeof(value) == "number" then
		return 0, numberClose
	elseif typeof(value) == "Vector3" then
		return Vector3.new(), vectorClose
	--elseif typeof(value) == "UDim2" then
	--	return UDim2.new(), udim2Close
	end
end

local Spring = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		if self._IsClose(self._Value, self.T) then
			self._Value = self.T
			return true
		end
		if dt > 0.03 then dt = 0.03 end
		local accel = (self.T - self._Value) * self._Force - self.V * self._Damping
		local vel = self.V
		self.V = self.V + accel * dt * self._Speed
		self._Value = self._Value + (self.V + vel) * dt * 0.5 * self._Speed
		return false
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		self._Value = self._Follow._Value -- Position
		self.T = self._Follow._Value -- Target
		self.V, self._IsClose = getStartingVelocityByType(self._Follow._Value)
	end
}
Spring.__index = Spring

return function(follow, force, damping, speed)
	local self = {}
	self._StateType = "_Spring"
	self._Active = false
	self._Follow = follow
	self._Force = force or 50
	self._Damping = damping or 10
	self._Speed = speed or 1
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Spring)
	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{75F7ED28-4E8C-4DD2-B4B4-96FE43B00734}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_ActorSpring</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8DEF838565944479906E51FF4F7E81CB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Update = require(script.Parent.Parent._ActorState._Update)

local Anim = {}
Anim._List = {}
Anim._Active = false

function Anim:Start(data)
	self._List[data] = true
	data._Active = true
	if self._Active then return end
	self._Active = true
	self._StepEvent = RunService.RenderStepped:Connect(function(dt)
		for data in pairs(self._List) do
			if data:_Step(dt) then
				self._List[data] = nil
				data._Active = false
			end
			Update(data)
		end
		if not next(self._List) then
			self._Active = false
			self._StepEvent:Disconnect()
			self._StepEvent = nil
		end
	end)
end

return Anim]]></ProtectedString>
							<string name="ScriptGuid">{E23A44C6-6E9A-4C05-B073-4ACA09DF1D84}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Anim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1B813AE49FDC4AB1862CCEE86CBA203E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{21975FB5-A2DB-4AE0-8AE1-201F23010F5E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Cubic</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFF10B97E4E7345C5B821B041239D631A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{663F5D7F-0BB4-454F-B6C8-BFD97C0E59E5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Linear</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXBB8130B233464232ACCB91E7CC0A56CE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorCreation</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX551BCF7FCEC54BDF855B5B21C9585D24">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local TABLE = "table"
local SCRIPT_SIGNAL = "RBXScriptSignal"
local INST = "Instance"
local DEBUG = "Debug"
local TEMP_STATE = "TempState"

local HandleStateCleanup = require(script.Parent:WaitForChild("_HandleStateCleanup"))


local function processChildren(parent, item, stateLink)
	if typeof(item) == INST then
		item.Parent = parent
		return
	end
	if item._DerivedTable then
		item:_Init()
		item.OnAdd = function(_, instance)
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		item.OnRemove = function(_, instance)
			if typeof(instance) == INST then
				instance:Destroy()
			end
		end
		for _, instance in pairs(item._Value) do
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		if stateLink then
			table.insert(stateLink, item)
		end
	else
		for _, c in pairs(item) do
			processChildren(parent, c, stateLink)
		end
	end
end

return function(className, props, children, autoCleanup)
	local instance = Instance.new(className)

	local stateLink
	if autoCleanup then
		stateLink = {}
	end

	for name, value in pairs(props) do
		if name == DEBUG or name == TEMP_STATE then continue end

		if typeof(value) == TABLE then
			if value._StateType then
				value._Link[instance] = name
				if value._Init then
					value:_Init()
				end
				instance[name] = value._Value
				if autoCleanup then
					table.insert(stateLink, value)
				end
			end
		elseif typeof(name) == TABLE then
			if name._OnChange then
				local propName = name._Property
				instance:GetPropertyChangedSignal(propName):Connect(function() value(instance[propName]) end)
				value(props[propName] or instance[propName])
			end
		elseif typeof(instance[name]) == SCRIPT_SIGNAL then
			instance[name]:Connect(value)
		else
			instance[name] = value
		end
	end

	if children then
		processChildren(instance, children, autoCleanup and stateLink)
	end

	if autoCleanup and next(stateLink) then
		instance.AncestryChanged:Connect(function()
			if instance.Parent == nil then
				if props.Debug then
					warn("Cleanup:", props.Debug, stateLink)
				end
				for _, dep in pairs(stateLink) do
					dep._Link[instance] = nil
					HandleStateCleanup(dep)
				end
			end
		end)
	end

	return instance
end]]></ProtectedString>
							<string name="ScriptGuid">{FB0DC063-0B0B-46FD-8739-27F1FB24C276}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Create</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE7FCABFB4A4045D7B6ECD31DCEC0299A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local cleanup
cleanup = function(state)
	if state.Debug then
		warn(state.Debug, state._Temp, state._GetDependencies ~= nil, next(state._Dependent), next(state._Link))
	end
	if not state._Persist and state._GetDependencies and not next(state._Dependent) and not next(state._Link) then
		if state.Debug then
			warn("Cleanup", state.Debug, state:_GetDependencies())
		end
		state._Initialized = false
		for _, dep in pairs(state:_GetDependencies()) do
			dep._Dependent[state] = nil
			cleanup(dep)
		end
	end
end

return cleanup]]></ProtectedString>
							<string name="ScriptGuid">{8142FDB1-2BEA-412B-A7D9-06B564731451}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_HandleStateCleanup</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX3479D4E08F0446A1B5A484090136C585">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorState</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9DBC013480A74C80801E25712874B237">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Derived = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		local newValue = self._Eval(unpack(values))
		if newValue ~= self._Value then
			self._Value = newValue
			return true
		end
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Derived.__index = Derived

return function(eval, ...)
	local self = {}
	self._StateType = "_Derived"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Derived)
	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{85505D8D-2DC5-468A-85F2-F6D246900F2C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Derived</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAF2D607CC8D140E9A8514FA213D5181D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local DerivedTable = {
	_Update = function(self)
		local changed = false
		local input = self._Input._Value

		for k, v in pairs(input) do
			local li = self._LastInput[k]
			if v ~= li then
				changed = true
				if li and self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = v
				self._Value[k] = self._Eval(k, v)
				if self.OnAdd then
					self.OnAdd(k, self._Value[k])
				end
			end
		end

		for k, v in pairs(self._LastInput) do
			if not input[k] then
				if self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = nil
				changed = true
			end
		end

		return changed
	end,
	_GetDependencies = function(self)
		return { self._Input }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Input._Dependent[self] = true
		if self._Input._Init then
			self._Input:_Init()
		end
		self:_Update()
	end
}
DerivedTable.__index = DerivedTable

return function(eval, input, onAdd, onRemove)
	local self = {}
	self._StateType = "_DerivedTable"
	self._DerivedTable = true
	self._Eval = eval
	self._Value = {}
	self._LastInput = {}
	self._Input = input
	self._Temp = input._Temp
	self._Priority = input._Priority + 1

	self.OnAdd = onAdd
	self.OnRemove = onRemove

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, DerivedTable)
	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{69B98402-6A89-4E5B-B3B6-154DCBA5EF75}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_DerivedTable</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9FC6ED16DB064C738EBAD709D5A19BAF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Update = require(script.Parent:WaitForChild("_Update"))

local State = {
	set = function(self, value)
		if self._Value == value then return end
		self._Value = value
		Update(self)
	end
}
State.__index = State

return function(value)
	local self = {}
	self._StateType = "_State"
	self._State = true
	self._Value = value
	self._Priority = 0
	self._Dependent = {}
	self._Link = {}
	self._Temp = false
	--setmetatable(self._Link, WEAK_KEYS)

	setmetatable(self, State)
	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{EA799B52-C8B1-4260-B518-AA66BF7F71A3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_State</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9314E6857BD54144BB51E38AA6D5F72D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return function(base)
	local list = {}

	for instance, prop in pairs(base._Link) do
		instance[prop] = base._Value
	end

	for dep in pairs(base._Dependent) do
		list[dep] = true
	end

	local best = next(list)
	while best do
		local priority = best._Priority
		for dep in pairs(list) do
			if dep._Priority < priority then
				best = dep
				priority = best._Priority
			end
		end
		list[best] = nil

		if best:_Update() then -- this updated and we need to change it's dependencies
			for instance, prop in pairs(best._Link) do
				instance[prop] = best._Value
			end
			for dep in pairs(best._Dependent) do
				list[dep] = true
			end
		end

		best = next(list)
	end
end]]></ProtectedString>
							<string name="ScriptGuid">{CE2139AE-96AB-4A46-A4B9-E13F94D0BB5B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX043131B0AAB741728B13D1BDE7CAD8BD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Watch = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		-- Make Watch Callback
        self._Eval(unpack(values))
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Watch.__index = Watch

return function(eval, ...)
	local self = {}
	self._StateType = "_Watch"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Watch)

    -- Unlike other state components, we want to init this one immediataly as it will never connect to an instance
    -- Any dependencies will never be released, only use this for debugging or if you're sure those state components don't need to be gced
    self:_Init()

	return self
end]]></ProtectedString>
							<string name="ScriptGuid">{528EF26E-0FB8-4FB7-8A57-5CC83FA7D96D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">_Watch</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXD41E321A2AF54805839809C65991E540">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(prop)
	return {
		_OnChange = true,
		_Property = prop,
	}
end]]></ProtectedString>
						<string name="ScriptGuid">{8A5D737E-5999-4D56-8708-217CD5EA632B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_OnChange</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX9596936C1FE748838FB48B47C4615300">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local AxisAlign = {}

local VECTOR_UP = Vector3.new(0, 1, 0)

function AxisAlign.BestMatch(cfr, axis)
	local comp = axis or VECTOR_UP
	
	local v0, v1, v2 = cfr:VectorToWorldSpace(VECTOR_UP), cfr:VectorToWorldSpace(Vector3.new(1, 0, 0)), cfr:VectorToWorldSpace(Vector3.new(0, 0, 1))
	local d0, d1, d2 = v0:Dot(comp), v1:Dot(comp), v2:Dot(comp)
	
	if d0 < 0 then
		d0 = -d0
		v0 = -v0
	end
	if d1 < 0 then
		d1 = -d1
		v1 = -v1
	end
	if d2 < 0 then
		d2 = -d2
		v2 = -v2
	end
	
	if d1 > d0 then
		d1, d0 = d0, d1
		v1, v0 = v0, v1
	end
	if d2 > d0 then
		d2, d0 = d0, d2
		v2, v0 = v0, v2
	end
	
	return v0, v1, v2
end

function AxisAlign.CameraAlign(cfr, axis)
	local _, v0, v1 = AxisAlign.BestMatch(cfr, axis)
	
	local cam = workspace.CurrentCamera.CFrame.LookVector
	if math.abs(v1:Dot(cam)) > math.abs(v0:Dot(cam)) then
		v0 = v1
	end
	
	local flat = Vector3.new(v0.X, 0, v0.Z).Unit
	return flat, flat:Cross(VECTOR_UP)
end

return AxisAlign
]]></ProtectedString>
					<string name="ScriptGuid">{FCAE0095-E09A-495C-AD8B-0A3F07FE53B7}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">AxisAlign</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5DEA52AA8FFA4445A9C144E016DFCD18">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local Actor = require(script.Parent.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

return function(props)
	local enabled = props.Enabled or State(false)
	
	return Create("TextButton", {
		BorderSizePixel = 0,
		Size = props.Size or UDim2.new(0, 200, 0, 40),
		Text = props.Text,
		BackgroundTransparency = Derived(function(e)
			return e and 0 or 0.5
		end, enabled),
		BackgroundColor3 = Derived(function(e)
			return e and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
		end, enabled),
		TextColor3 = Derived(function(e)
			return e and Color3.new(0, 0, 0) or Color3.new(1, 1, 1)
		end, enabled),
		
		TextSize = 20,
		Font = Enum.Font.SciFi,
		
		Activated = props.Activated,
		Position = props.Position,
		AnchorPoint = props.AnchorPoint
	})
end]]></ProtectedString>
					<string name="ScriptGuid">{B1C97A2B-2D0D-4D52-936B-99B4958F7359}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Button</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1D7A6DC8F99A4835A539E8C87716705A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local STASH_LINK_NAME = "StashLink"

local module = {}

module.GetStashRoot = function()
	local root = game.ReplicatedStorage:FindFirstChild("StashRoot")
	if not root then
		root = Instance.new("Folder")
		root.Name = "StashRoot"
		root.Parent = game.ReplicatedStorage
	end
	return root
end

module.Hide = function(part)
	if part:FindFirstChild(STASH_LINK_NAME) then
		return false
	end

	local originalParent = part.Parent
	part.Parent = module.GetStashRoot()
	local folder = Instance.new("Folder")
	folder.Parent = originalParent
	folder.Name = part.Name
	local link = Instance.new("ObjectValue")
	link.Value = part
	link.Name = STASH_LINK_NAME
	link.Parent = folder

	return folder
end

module.Reveal = function(part)
	local link = part:FindFirstChild(STASH_LINK_NAME)
	if not link then
		return false
	end

	local val = link.Value
	val.Parent = part.Parent
	part:Destroy()

	return val
end

module.IsHidden = function(part)
	return part:FindFirstChild(STASH_LINK_NAME) ~= nil
end

module.TempReveal = function(part)
	local revealed = module.Reveal(part)
	if revealed then
		revealed:SetAttribute("TempRevealed", true)
	end
end

module.HideTempRevealedParts = function(root)
	if not root then
		return
	end
	for _, part in root:GetChildren() do
		if part:GetAttribute("TempRevealed") then
			part:SetAttribute("TempRevealed", nil)
			module.Hide(part)
		end
	end
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{03010712-3035-4B33-B6B1-9A3F2ABF90D6}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">VisibilityToggle</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA8587F62A36B440B8185DBD0B29D9924">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local ZoneUtil = {}

function ZoneUtil.InZone(zone, pos)
	local floorMatch = zone:FindFirstChild("Floor") == nil
	local roofMatch = false

	for _, part in pairs(zone:GetChildren()) do
		local rel = part.CFrame:PointToObjectSpace(pos)

		if math.abs(rel.X) <= part.Size.X / 2 and math.abs(rel.Z) <= part.Size.Z / 2 then
			if part.Name == "Roof" and rel.Y <= 0 then
				roofMatch = true
			elseif part.Name == "Floor" and rel.Y >= 0 then
				floorMatch = true
			end

			if floorMatch and roofMatch then
				return true
			end
		end
	end
	
	return false
end

function ZoneUtil.GetZone(pos)
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, zone in pairs(LevelBase.Cells:GetChildren()) do
		if ZoneUtil.InZone(zone, pos) then
			return zone
		end
	end
end

return ZoneUtil]]></ProtectedString>
					<string name="ScriptGuid">{C734C7E7-B836-48EC-8D7A-3595CD31FEEC}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">ZoneUtil</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXAC2F165E8C00439FAD3EBFB7E3818AC1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ZoneMarker</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1CF10DF5C01D4A26B1A1DF530B58A818">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return function(pos)
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, zone in pairs(LevelBase.Cells:GetChildren()) do
		local floorMatch = zone:FindFirstChild("Floor") == nil
		local roofMatch = false
		
		for _, part in pairs(zone:GetChildren()) do
			local rel = part.CFrame:PointToObjectSpace(pos)
			
			if math.abs(rel.X) <= part.Size.X / 2 and math.abs(rel.Z) <= part.Size.Z / 2 then
				if part.Name == "Roof" and rel.Y <= 0 then
					roofMatch = true
				elseif part.Name == "Floor" and rel.Y >= 0 then
					floorMatch = true
				end
				
				if floorMatch and roofMatch then
					return zone
				end
			end
		end
	end
end]]></ProtectedString>
					<string name="ScriptGuid">{33BA81F2-01AB-407D-AC1A-75CA9F763B4F}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">GetZone</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8D09541584E34709B0A0FD66AF3632AC">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local AxisAlign = require(script.Parent.Parent.Util.AxisAlign)
local GetZone = require(script.Parent.GetZone)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local UserInputService = game:GetService("UserInputService")

local MAX_PROJECT = 50

local SIZE_PADDING = 1
local POSITION_SINK = 0.3

local CellFolder
local Events = {}
local Ghost
local HoveringCell

local MouseDown = false
local ShiftDown = false
local CtrlDown = false

local GhostCfr
local GhostSize
local GhostMax
local GhostMin

local WithPropCastParams = RaycastParams.new()
local NoPropCastParams = RaycastParams.new()
NoPropCastParams.FilterType = Enum.RaycastFilterType.Exclude

local CellCastParams = RaycastParams.new()
CellCastParams.FilterType = Enum.RaycastFilterType.Include

local function GetLevelRoot()
	return workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
end

local function CreateTempDoorFolder()
	local levelRoot = GetLevelRoot()
	local propFolder = levelRoot and levelRoot:FindFirstChild("Props")
	if not propFolder then return end

	local doorsFolderTemp = Instance.new("Folder")
	doorsFolderTemp.Name = "CellMarkerDoorsTemp"
	doorsFolderTemp.Parent = workspace

	for _, prop in pairs(propFolder:GetDescendants()) do
		if prop.Name:find("Door") == nil or not prop:IsA("BasePart") then continue end
		local tempDoor = prop:Clone()
		tempDoor.Parent = doorsFolderTemp
	end
end

local function CleanupTempDoorFolder()
	local doorsFolderTemp = workspace:FindFirstChild("CellMarkerDoorsTemp")
	if not doorsFolderTemp then return end
	doorsFolderTemp:Destroy()
end

local function UpdatePropCastExcludeList()
	local levelRoot = GetLevelRoot()
	NoPropCastParams.FilterDescendantsInstances = {
		levelRoot and levelRoot:FindFirstChild("Props") or nil,
		levelRoot and levelRoot:FindFirstChild("CombatFlowMap") or nil,
		levelRoot and levelRoot:FindFirstChild("Nodes") or nil,
		levelRoot and levelRoot:FindFirstChild("MapData") or nil
	}
end

local function GetProjectionDist(basePos, axis)
	local castParams = CtrlDown and WithPropCastParams or NoPropCastParams

	local castDistance = ShiftDown and 1_000_000 or MAX_PROJECT

	local result = workspace:Raycast(basePos, axis * castDistance, castParams)
	if result then
		return (result.Position - basePos).magnitude
	else
		return MAX_PROJECT
	end
end

local function UpdateGhost(basePos, axis0, axis1, mouseDown)
	if mouseDown then
		Ghost.Transparency = 0.0
		return
	else
		Ghost.Transparency = 0.5
	end
	
	local z0, z1 = GetProjectionDist(basePos, axis0), GetProjectionDist(basePos, -axis0)
	local x0, x1 = GetProjectionDist(basePos, axis1), GetProjectionDist(basePos, -axis1)

	local pos = basePos + axis0 * (z0 - z1) / 2 + axis1 * (x0 - x1) / 2
	GhostCfr = CFrame.new(pos, pos + axis0)
	GhostSize = Vector3.new(x0 + x1, 0.2, z0 + z1)
	GhostMax = GetProjectionDist(basePos, Vector3.new(0, 1, 0))
	GhostMin = GetProjectionDist(basePos, Vector3.new(0, -1, 0))

	if GhostMax == MAX_PROJECT and not ShiftDown then
		GhostMax = GhostMax - GhostMin
	end

	Ghost.CFrame = GhostCfr
	Ghost.Size = GhostSize
end

local function UpdateHoveringCell(pos, mouseDown)
	if HoveringCell then
		-- Reveal previously hovered cell
		for _, p in pairs(HoveringCell:GetChildren()) do
			p.Transparency = 0.5
		end
	end
	
	if not MouseDown then return end
	
	local hoveringCell = GetZone(pos)
	if not hoveringCell then return end
	
	HoveringCell = hoveringCell
	for _, p in pairs(hoveringCell:GetChildren()) do
		p.Transparency = 0
	end
end

local function ReoptimizeCells()
	print("Reoptimize cell floors")
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, cell in pairs(LevelBase.Cells:GetChildren()) do
		if cell:IsA("Model") then
			local canFit = true
			local floorPart

			local baseRef = cell:FindFirstChild("Roof")
			local minX, maxX = baseRef.Position.X, baseRef.Position.X
			local minZ, maxZ = baseRef.Position.Z, baseRef.Position.Z

			for _, part in pairs(cell:GetChildren()) do
				if part.Name=="Roof" then
					for xo = -1, 1, 2 do
						for zo = -1, 1, 2 do
							local ref = part.CFrame:pointToWorldSpace(Vector3.new(part.Size.X * 0.5 * xo, 0, part.Size.Z * 0.5 * zo))
							minX = math.min(minX, ref.X)
							maxX = math.max(maxX, ref.X)
							minZ = math.min(minZ, ref.Z)
							maxZ = math.max(maxZ, ref.Z)
						end
					end
				elseif part.Name=="Floor" then
					if floorPart==nil then
						floorPart = part
					else
						canFit = false
						break
					end
				end
			end

			if floorPart and canFit then
				floorPart.Size = Vector3.new(maxX - minX, floorPart.Size.Y, maxZ - minZ)
				floorPart.CFrame = CFrame.new((maxX + minX)/2, floorPart.Position.Y, (maxZ + minZ)/2)
			end
		end
	end
end

local function ShowCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		for _, part in pairs(cell:GetChildren()) do
			part.Size = Vector3.new(part.Size.X, 1, part.Size.Z)
			part.Transparency = 0.5
			part.Locked = false
		end
	end
end

local function ShowLinks()
	for _, cell in pairs(CellFolder:GetChildren()) do
		if cell.Name ~= "Links" then continue end
		for _, part in pairs(cell:GetChildren()) do
			part.Size = Vector3.new(part.Size.X, 1, part.Size.Z)
			part.Transparency = 0.5
			part.Locked = false
		end
	end
end

local function HideCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		for _, part in pairs(cell:GetChildren()) do
			part.Size = Vector3.new(part.Size.X, 0, part.Size.Z)
			part.Transparency = 1
			part.Locked = true
		end
	end
end

local function HideNamedCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		if cell.Name ~= "Default" then
			for _, part in pairs(cell:GetChildren()) do
				part.Size = Vector3.new(part.Size.X, 0, part.Size.Z)
				part.Transparency = 1
				part.Locked = true
			end
		end
	end
end

local function hashName(name)
	if name == "Default" then
		return Color3.new(0, 0, 0)
	end

	local h = 5^7
	local n = 0
	for i = 1, #name do
		n = (n * 257 + string.byte(name, i, i)) % h 
	end
	local color = Color3.fromHSV((n % 1000) / 1000, 0.5, 0.5)
	return color
end

local function RecolorCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		local color = hashName(cell.Name)
		for _, part in pairs(cell:GetChildren()) do
			part.Color = color
		end
	end
end

local function CreateCell(mousePos)
	local cellModel = GetZone(mousePos)
	local addFloor = true

	if cellModel then
		addFloor = false
		print("Add to:", cellModel:GetFullName())
	else
		local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
		print("Create new cell")
		cellModel = Instance.new("Model")
		cellModel.Name = "Default"
		cellModel.Parent = LevelBase.Cells
	end

	local roof = Ghost:Clone()
	roof.Size = roof.Size + Vector3.new(SIZE_PADDING * 2, 0.8, SIZE_PADDING * 2)
	roof.CFrame = GhostCfr * CFrame.new(0, GhostMax + POSITION_SINK, 0)
	roof.Name = "Roof"
	roof.Parent = cellModel
	roof.Anchored = true
	roof.Transparency = 0.5
	roof.CastShadow = false

	if addFloor then
		local floor = roof:Clone()
		floor.Name = "Floor"
		floor.CFrame = GhostCfr * CFrame.new(0, -GhostMin - POSITION_SINK, 0)
		floor.Parent = cellModel
		floor.Anchored = true
		floor.CastShadow = false
	else
		ReoptimizeCells()
	end
end

return {
	Init = function(mouse)
		if not workspace:FindFirstChild("Level") then
			local l = Instance.new("Folder")
			l.Name = "Level"
			l.Parent = workspace
		end

		local LevelBase = GetLevelRoot()
		if not LevelBase:FindFirstChild("Cells") then
			local c = Instance.new("Folder")
			c.Name = "Cells"
			c.Parent = LevelBase
		end

		UpdatePropCastExcludeList()
		CreateTempDoorFolder()

		Ghost = Instance.new("Part")
		Ghost.Color = Color3.new(0, 0, 0)
		Ghost.Transparency = 0.5
		Ghost.Parent = LevelBase.Cells
		Ghost.CastShadow = false

		CellFolder = LevelBase.Cells
		mouse.TargetFilter = CellFolder
		WithPropCastParams.FilterType = Enum.RaycastFilterType.Exclude
		WithPropCastParams.FilterDescendantsInstances = { CellFolder }

		Events[1] = game:GetService("RunService").RenderStepped:connect(function()
			if mouse.Target then
				local v0, v1 = AxisAlign.CameraAlign(mouse.Target.CFrame)
				local origin = mouse.Hit.p - mouse.UnitRay.Direction * 0.5
				UpdateGhost(origin, v0, v1, MouseDown)
				UpdateHoveringCell(mouse.Hit.p, MouseDown)
			end
		end)

		Events[2] = mouse.Button1Up:connect(function()
			CreateCell(mouse.Hit.p)
			MouseDown = false
		end)

		Events[3] = mouse.Button1Down:connect(function()
			MouseDown = true
		end)

		Events[4] = UserInputService.InputBegan:connect(function(io)
			ShiftDown = io:IsModifierKeyDown(Enum.ModifierKey.Shift)
			CtrlDown  = io:IsModifierKeyDown(Enum.ModifierKey.Ctrl )
			if io.KeyCode == Enum.KeyCode.T then
				ReoptimizeCells()
			elseif io.KeyCode == Enum.KeyCode.G then
				ShowCells()
			elseif io.KeyCode == Enum.KeyCode.H then
				HideCells()
			elseif io.KeyCode == Enum.KeyCode.J then
				HideNamedCells()
			elseif io.KeyCode == Enum.KeyCode.K then
				RecolorCells()
			elseif io.KeyCode == Enum.KeyCode.L then
				ShowLinks()
			end
		end)
		
		Events[5] = UserInputService.InputEnded:Connect(function(io)
			ShiftDown = io:IsModifierKeyDown(Enum.ModifierKey.Shift)
			CtrlDown  = io:IsModifierKeyDown(Enum.ModifierKey.Ctrl )
		end)

		VisibilityToggle.TempReveal(workspace.DebugMission.Cells)

		print([[T - Reoptimize Cell Floors
		G - Show All Cells
		H - Hide All Cells
		J - Hide Named Cells
		K - Recolor Cells
		L - Show Links]])
	end,
	Clean = function()
		if Events then
			for _, e in pairs(Events) do
				e:Disconnect()
			end
			Events = {}
		end
		if Ghost then
			Ghost:Destroy()
			Ghost = nil
		end
		CleanupTempDoorFolder()
	end,
}
]]></ProtectedString>
					<string name="ScriptGuid">{065261BE-C192-4E23-A6B5-2ED736812507}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>