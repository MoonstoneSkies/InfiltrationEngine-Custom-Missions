<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXA6FE8B69A8114235A4BFD3C3F9AC28E7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngineTools</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX3A4C0EAAC28048149517A3C3F7A1E32B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Util</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX4699DD18B12B4A5380A13A689E575FD4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Actor</string>
					<string name="ScriptGuid">{E9186E47-B880-4E95-95FD-F07D9E6525DB}</string>
					<ProtectedString name="Source"><![CDATA[local module = {
	Create = require(script._ActorCreation._Create),

	State = require(script._ActorState._State),
	Derived = require(script._ActorState._Derived),
	DerivedTable = require(script._ActorState._DerivedTable),
	Watch = require(script._ActorState._Watch),

	Spring = require(script._ActorAnim._ActorSpring),
	Cubic = require(script._ActorAnim._Cubic),

	OnChange = require(script._OnChange),
}

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX19A454D280B546B689859AD76E669B54">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorAnim</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDDB2EE3818FC4ED58BD04AF153B8006B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_ActorSpring</string>
							<string name="ScriptGuid">{0B527C00-6D50-4AC5-BB2F-513DD569B1C7}</string>
							<ProtectedString name="Source"><![CDATA[local AnimRunner = require(script.Parent._Anim)

local numberClose = function(x, y)
	return math.abs(x - y) < 0.01
end
local vectorClose = function(x, y)
	return (x - y).magnitude < 0.01
end
local udim2Close = function(x, y)
	local rel = x - y
	return math.abs(rel.X.Offset) <= 1 and math.abs(rel.Y.Offset) <= 1 and math.abs(rel.X.Scale) < 0.01 and math.abs(rel.Y.Scale) < 0.01 
end

local function getStartingVelocityByType(value)
	if typeof(value) == "number" then
		return 0, numberClose
	elseif typeof(value) == "Vector3" then
		return Vector3.new(), vectorClose
	--elseif typeof(value) == "UDim2" then
	--	return UDim2.new(), udim2Close
	end
end

local Spring = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		if self._IsClose(self._Value, self.T) then
			self._Value = self.T
			return true
		end
		if dt > 0.03 then dt = 0.03 end
		local accel = (self.T - self._Value) * self._Force - self.V * self._Damping
		local vel = self.V
		self.V = self.V + accel * dt * self._Speed
		self._Value = self._Value + (self.V + vel) * dt * 0.5 * self._Speed
		return false
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		self._Value = self._Follow._Value -- Position
		self.T = self._Follow._Value -- Target
		self.V, self._IsClose = getStartingVelocityByType(self._Follow._Value)
	end
}
Spring.__index = Spring

return function(follow, force, damping, speed)
	local self = {}
	self._StateType = "_Spring"
	self._Active = false
	self._Follow = follow
	self._Force = force or 50
	self._Damping = damping or 10
	self._Speed = speed or 1
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Spring)
	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1104B71D45F44F2F92B1449D2324BDDA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Anim</string>
							<string name="ScriptGuid">{63C9A41E-5101-4D31-A361-8A6940F9B137}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Update = require(script.Parent.Parent._ActorState._Update)

local Anim = {}
Anim._List = {}
Anim._Active = false

function Anim:Start(data)
	self._List[data] = true
	data._Active = true
	if self._Active then return end
	self._Active = true
	self._StepEvent = RunService.RenderStepped:Connect(function(dt)
		for data in pairs(self._List) do
			if data:_Step(dt) then
				self._List[data] = nil
				data._Active = false
			end
			Update(data)
		end
		if not next(self._List) then
			self._Active = false
			self._StepEvent:Disconnect()
			self._StepEvent = nil
		end
	end)
end

return Anim]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF84F72D8BF5D478A8180988C9D9833C4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Cubic</string>
							<string name="ScriptGuid">{ABE67D69-C946-40A9-ADD7-2B91A8294BFE}</string>
							<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA66B2D878DBF4DDD8D653E04DE29FF5A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Linear</string>
							<string name="ScriptGuid">{0D074906-1D5B-41D5-AEA2-8EB0A743A2C3}</string>
							<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX72656C831BF644D0BFDFF1AD6E70ABD3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorCreation</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD370DBE598F34B73996A5F37BD086D9A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Create</string>
							<string name="ScriptGuid">{DA0A047B-36D3-4713-BF0B-D565C0EC85D4}</string>
							<ProtectedString name="Source"><![CDATA[local TABLE = "table"
local SCRIPT_SIGNAL = "RBXScriptSignal"
local INST = "Instance"
local DEBUG = "Debug"
local TEMP_STATE = "TempState"

local HandleStateCleanup = require(script.Parent:WaitForChild("_HandleStateCleanup"))


local function processChildren(parent, item, stateLink)
	if typeof(item) == INST then
		item.Parent = parent
		return
	end
	if item._DerivedTable then
		item:_Init()
		item.OnAdd = function(_, instance)
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		item.OnRemove = function(_, instance)
			if typeof(instance) == INST then
				instance:Destroy()
			end
		end
		for _, instance in pairs(item._Value) do
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		if stateLink then
			table.insert(stateLink, item)
		end
	else
		for _, c in pairs(item) do
			processChildren(parent, c, stateLink)
		end
	end
end

return function(className, props, children, autoCleanup)
	local instance = Instance.new(className)

	local stateLink
	if autoCleanup then
		stateLink = {}
	end

	for name, value in pairs(props) do
		if name == DEBUG or name == TEMP_STATE then continue end

		if typeof(value) == TABLE then
			if value._StateType then
				value._Link[instance] = name
				if value._Init then
					value:_Init()
				end
				instance[name] = value._Value
				if autoCleanup then
					table.insert(stateLink, value)
				end
			end
		elseif typeof(name) == TABLE then
			if name._OnChange then
				local propName = name._Property
				instance:GetPropertyChangedSignal(propName):Connect(function() value(instance[propName]) end)
				value(props[propName] or instance[propName])
			end
		elseif typeof(instance[name]) == SCRIPT_SIGNAL then
			instance[name]:Connect(value)
		else
			instance[name] = value
		end
	end

	if children then
		processChildren(instance, children, autoCleanup and stateLink)
	end

	if autoCleanup and next(stateLink) then
		instance.AncestryChanged:Connect(function()
			if instance.Parent == nil then
				if props.Debug then
					warn("Cleanup:", props.Debug, stateLink)
				end
				for _, dep in pairs(stateLink) do
					dep._Link[instance] = nil
					HandleStateCleanup(dep)
				end
			end
		end)
	end

	return instance
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX782157AC87D24FEAB8E98C5AD0342DE9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_HandleStateCleanup</string>
							<string name="ScriptGuid">{5F1D9141-B6A4-41EC-894E-33AE0520F084}</string>
							<ProtectedString name="Source"><![CDATA[local cleanup
cleanup = function(state)
	if state.Debug then
		warn(state.Debug, state._Temp, state._GetDependencies ~= nil, next(state._Dependent), next(state._Link))
	end
	if not state._Persist and state._GetDependencies and not next(state._Dependent) and not next(state._Link) then
		if state.Debug then
			warn("Cleanup", state.Debug, state:_GetDependencies())
		end
		state._Initialized = false
		for _, dep in pairs(state:_GetDependencies()) do
			dep._Dependent[state] = nil
			cleanup(dep)
		end
	end
end

return cleanup]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB62584BA1C6D4DE8960924C924AEC84A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorState</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0EB6CCE70BB9443EAA82036471DD116B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Derived</string>
							<string name="ScriptGuid">{198688C5-D42D-476C-970F-B5658928BCF2}</string>
							<ProtectedString name="Source"><![CDATA[local Derived = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		local newValue = self._Eval(unpack(values))
		if newValue ~= self._Value then
			self._Value = newValue
			return true
		end
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Derived.__index = Derived

return function(eval, ...)
	local self = {}
	self._StateType = "_Derived"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Derived)
	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC079E520A4304E3FB63E69CA94090756">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_DerivedTable</string>
							<string name="ScriptGuid">{474CFE78-F76E-41AF-B06A-65CEA5EBD86F}</string>
							<ProtectedString name="Source"><![CDATA[local DerivedTable = {
	_Update = function(self)
		local changed = false
		local input = self._Input._Value

		for k, v in pairs(input) do
			local li = self._LastInput[k]
			if v ~= li then
				changed = true
				if li and self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = v
				self._Value[k] = self._Eval(k, v)
				if self.OnAdd then
					self.OnAdd(k, self._Value[k])
				end
			end
		end

		for k, v in pairs(self._LastInput) do
			if not input[k] then
				if self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = nil
				changed = true
			end
		end

		return changed
	end,
	_GetDependencies = function(self)
		return { self._Input }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Input._Dependent[self] = true
		if self._Input._Init then
			self._Input:_Init()
		end
		self:_Update()
	end
}
DerivedTable.__index = DerivedTable

return function(eval, input, onAdd, onRemove)
	local self = {}
	self._StateType = "_DerivedTable"
	self._DerivedTable = true
	self._Eval = eval
	self._Value = {}
	self._LastInput = {}
	self._Input = input
	self._Temp = input._Temp
	self._Priority = input._Priority + 1

	self.OnAdd = onAdd
	self.OnRemove = onRemove

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, DerivedTable)
	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBDA7ADA422164867A99380BF89D535BF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_State</string>
							<string name="ScriptGuid">{34150F97-6DF4-4F30-B0CC-AF05F46FB5EB}</string>
							<ProtectedString name="Source"><![CDATA[local Update = require(script.Parent:WaitForChild("_Update"))

local State = {
	set = function(self, value)
		if self._Value == value then return end
		self._Value = value
		Update(self)
	end
}
State.__index = State

return function(value)
	local self = {}
	self._StateType = "_State"
	self._State = true
	self._Value = value
	self._Priority = 0
	self._Dependent = {}
	self._Link = {}
	self._Temp = false
	--setmetatable(self._Link, WEAK_KEYS)

	setmetatable(self, State)
	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8AFECEB68F444C3C8BFC1338654283DB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Update</string>
							<string name="ScriptGuid">{056B8C65-D08C-439F-92A6-28039B225A26}</string>
							<ProtectedString name="Source"><![CDATA[return function(base)
	local list = {}

	for instance, prop in pairs(base._Link) do
		instance[prop] = base._Value
	end

	for dep in pairs(base._Dependent) do
		list[dep] = true
	end

	local best = next(list)
	while best do
		local priority = best._Priority
		for dep in pairs(list) do
			if dep._Priority < priority then
				best = dep
				priority = best._Priority
			end
		end
		list[best] = nil

		if best:_Update() then -- this updated and we need to change it's dependencies
			for instance, prop in pairs(best._Link) do
				instance[prop] = best._Value
			end
			for dep in pairs(best._Dependent) do
				list[dep] = true
			end
		end

		best = next(list)
	end
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX85F2F6D4F9104973963B2EF7573B3590">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Watch</string>
							<string name="ScriptGuid">{2293D1E2-F4BF-4893-9CBE-10E8CBB4F77A}</string>
							<ProtectedString name="Source"><![CDATA[local Watch = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		-- Make Watch Callback
        self._Eval(unpack(values))
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Watch.__index = Watch

return function(eval, ...)
	local self = {}
	self._StateType = "_Watch"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Watch)

    -- Unlike other state components, we want to init this one immediataly as it will never connect to an instance
    -- Any dependencies will never be released, only use this for debugging or if you're sure those state components don't need to be gced
    self:_Init()

	return self
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXF10B2395834B45D082410E88E0E00416">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_OnChange</string>
						<string name="ScriptGuid">{C93C1F1E-EE9B-452B-A49B-0AA0BF98AAFC}</string>
						<ProtectedString name="Source"><![CDATA[return function(prop)
	return {
		_OnChange = true,
		_Property = prop,
	}
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX99C3BFE9AA05440EBEE2E7D957CC0E75">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AxisAlign</string>
					<string name="ScriptGuid">{622BEDFD-DBC5-4B01-BA44-A3CFBA0DE296}</string>
					<ProtectedString name="Source"><![CDATA[local AxisAlign = {}

local VECTOR_UP = Vector3.new(0, 1, 0)

function AxisAlign.BestMatch(cfr, axis)
	local comp = axis or VECTOR_UP
	
	local v0, v1, v2 = cfr:VectorToWorldSpace(VECTOR_UP), cfr:VectorToWorldSpace(Vector3.new(1, 0, 0)), cfr:VectorToWorldSpace(Vector3.new(0, 0, 1))
	local d0, d1, d2 = v0:Dot(comp), v1:Dot(comp), v2:Dot(comp)
	
	if d0 < 0 then
		d0 = -d0
		v0 = -v0
	end
	if d1 < 0 then
		d1 = -d1
		v1 = -v1
	end
	if d2 < 0 then
		d2 = -d2
		v2 = -v2
	end
	
	if d1 > d0 then
		d1, d0 = d0, d1
		v1, v0 = v0, v1
	end
	if d2 > d0 then
		d2, d0 = d0, d2
		v2, v0 = v0, v2
	end
	
	return v0, v1, v2
end

function AxisAlign.CameraAlign(cfr, axis)
	local _, v0, v1 = AxisAlign.BestMatch(cfr, axis)
	
	local cam = workspace.CurrentCamera.CFrame.LookVector
	if math.abs(v1:Dot(cam)) > math.abs(v0:Dot(cam)) then
		v0 = v1
	end
	
	local flat = Vector3.new(v0.X, 0, v0.Z).Unit
	return flat, flat:Cross(VECTOR_UP)
end

return AxisAlign
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7278FF2D85AD444EB26ABE9302067EA6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Button</string>
					<string name="ScriptGuid">{8EE82400-7C53-4C1C-9FF2-B1E7D4113AA9}</string>
					<ProtectedString name="Source"><![CDATA[local Actor = require(script.Parent.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

return function(props)
	local enabled = props.Enabled or State(false)
	
	return Create("TextButton", {
		BorderSizePixel = 0,
		Size = props.Size or UDim2.new(0, 200, 0, 40),
		Text = props.Text,
		BackgroundTransparency = Derived(function(e)
			return e and 0 or 0.5
		end, enabled),
		BackgroundColor3 = Derived(function(e)
			return e and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
		end, enabled),
		TextColor3 = Derived(function(e)
			return e and Color3.new(0, 0, 0) or Color3.new(1, 1, 1)
		end, enabled),
		
		TextSize = 20,
		Font = Enum.Font.SciFi,
		
		Activated = props.Activated,
		Position = props.Position,
		AnchorPoint = props.AnchorPoint
	})
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX60D425B5C1E44F10BAB91BD9FFBD1410">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ZoneUtil</string>
					<string name="ScriptGuid">{2FA78B77-6B08-4662-A3AE-E324F991C2DB}</string>
					<ProtectedString name="Source"><![CDATA[local ZoneUtil = {}

function ZoneUtil.InZone(zone, pos)
	local floorMatch = zone:FindFirstChild("Floor") == nil
	local roofMatch = false

	for _, part in pairs(zone:GetChildren()) do
		local rel = part.CFrame:PointToObjectSpace(pos)

		if math.abs(rel.X) <= part.Size.X / 2 and math.abs(rel.Z) <= part.Size.Z / 2 then
			if part.Name == "Roof" and rel.Y <= 0 then
				roofMatch = true
			elseif part.Name == "Floor" and rel.Y >= 0 then
				floorMatch = true
			end

			if floorMatch and roofMatch then
				return true
			end
		end
	end
	
	return false
end

function ZoneUtil.GetZone(pos)
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, zone in pairs(LevelBase.Cells:GetChildren()) do
		if ZoneUtil.InZone(zone, pos) then
			return zone
		end
	end
end

return ZoneUtil]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2A578C1D19F4475D9560C67D904F4A51">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">VisibilityToggle</string>
					<string name="ScriptGuid">{B9406850-9026-4309-A969-689B69660E7B}</string>
					<ProtectedString name="Source"><![CDATA[local STASH_LINK_NAME = "StashLink"

local module = {}

module.GetStashRoot = function()
	local root = game.ReplicatedStorage:FindFirstChild("StashRoot")
	if not root then
		root = Instance.new("Folder")
		root.Name = "StashRoot"
		root.Parent = game.ReplicatedStorage
	end
	return root
end

module.Hide = function(part)
	if part:FindFirstChild(STASH_LINK_NAME) then
		return false
	end

	local originalParent = part.Parent
	part.Parent = module.GetStashRoot()
	local folder = Instance.new("Folder")
	folder.Parent = originalParent
	folder.Name = part.Name
	local link = Instance.new("ObjectValue")
	link.Value = part
	link.Name = STASH_LINK_NAME
	link.Parent = folder

	return folder
end

module.Reveal = function(part)
	local link = part:FindFirstChild(STASH_LINK_NAME)
	if not link then
		return false
	end

	local val = link.Value
	val.Parent = part.Parent
	part:Destroy()

	return val
end

module.IsHidden = function(part)
	return part:FindFirstChild(STASH_LINK_NAME) ~= nil
end

module.TempReveal = function(part)
	local revealed = module.Reveal(part)
	if revealed then
		revealed:SetAttribute("TempRevealed", true)
	end
end

module.HideTempRevealedParts = function(root)
	if not root then
		return
	end
	for _, part in root:GetChildren() do
		if part:GetAttribute("TempRevealed") then
			part:SetAttribute("TempRevealed", nil)
			module.Hide(part)
		end
	end
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX40382F504E5847018516D98B1D315F5C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">CombatMap</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1CB075208A634D469F123BE3FF77EEB2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{6589937B-61AB-40E1-BE96-4303C55F7AEB}</string>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local module = {}

local DrawnModel = nil
local ClickConnection = nil
local CurrentMap = nil

local BLUE = Color3.fromRGB(110, 153, 202)
local BLACK = Color3.fromRGB(0, 0, 0)
local WHITE = Color3.new(1, 1, 1)

local function DrawLine(p0, p1, color)
	local p = Instance.new("Part")
	p.Size = Vector3.new(1, 1, (p0 - p1).Magnitude)
	p.CFrame = CFrame.new((p0 + p1) / 2, p0)
	p.Color = color
	p.CastShadow = false
	return p
end

local function LinkId(id0, id1)
	if id0 < id1 then
		return id0 .. "|" .. id1
	end
	return id1 .. "|" .. id0
end

function module.Init(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	if workspace.DebugMission:FindFirstChild("CombatFlowMap") then
		VisibilityToggle.TempReveal(workspace.DebugMission.CombatFlowMap)
	end

	local function RedrawMap(id)
		if DrawnModel then
			DrawnModel:Destroy()
			DrawnModel = nil
		end

		DrawnModel = Instance.new("Model")
		DrawnModel.Parent = workspace

		local part = CurrentMap[id]
		local used = {}
		local blocked = part:GetAttribute("BlockedLinks") or "{}"
		blocked = game:GetService("HttpService"):JSONDecode(blocked)

		local FilteredLinks = {}

		local distLeft = {
			[id] = 3,
		}
		local expandFrom = { id }

		while #expandFrom > 0 do
			local checkId = expandFrom[1]
			table.remove(expandFrom, 1)

			local part = CurrentMap:FindFirstChild(checkId)
			local linkTo = HttpService:JSONDecode(part:GetAttribute("LinkedIds"))

			for _, targetId in linkTo do
				local linkName = LinkId(checkId, targetId)

				local linkPart = CurrentMap:FindFirstChild(targetId)
				local p = DrawLine(part.Position, linkPart.Position, Color3.new(0, 0, 0.8), BLUE)
				p.Parent = DrawnModel
				p.Name = linkName

				if blocked[linkName] then
					p.Color = BLACK
				else
					table.insert(FilteredLinks, targetId)
					if distLeft[checkId] > 1 and not distLeft[targetId] then
						table.insert(expandFrom, targetId)
					end
				end
				distLeft[targetId] = distLeft[checkId] - 1
			end
		end

		part:SetAttribute("FilteredLinks", HttpService:JSONEncode(FilteredLinks))
		part.Color = BLACK
	end

	ClickConnection = mouse.Button1Down:Connect(function(target)
		local part = mouse.Target
		if part:IsDescendantOf(workspace.DebugMission.CombatFlowMap) then
			CurrentMap = part.Parent
			for _, p in CurrentMap:GetChildren() do
				p.Name = p:GetAttribute("Id")
			end

			local id = part:GetAttribute("Id")
			game.Selection:Set({ part })

			RedrawMap(id)
		elseif part.Name:match("|") and #part.Name == 73 then
			local node = game.Selection:Get()[1]
			local blocked = node:GetAttribute("BlockedLinks") or "{}"
			blocked = game:GetService("HttpService"):JSONDecode(blocked)

			blocked[part.Name] = if not blocked[part.Name] then true else nil

			node:SetAttribute("BlockedLinks", HttpService:JSONEncode(blocked))
			RedrawMap(node.Name)
		else
			local id0, id1 = part.Name:match("|")

			if DrawnModel then
				DrawnModel:Destroy()
				DrawnModel = nil
			end
		end
	end)
end

function module.Clean()
	if DrawnModel then
		DrawnModel:Destroy()
		DrawnModel = nil
	end

	if ClickConnection then
		ClickConnection:Disconnect()
		ClickConnection = nil
	end

	module.Active = false
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXE2C269F2D2934DA0A2FC58FC1018C0B6">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">DoorAccess</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX4125E7D8F05342E985EA238F67E60842">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{7C88A7C5-9B87-4498-83E6-E0186DEE7D05}</string>
					<ProtectedString name="Source"><![CDATA[--!strict

local UserInputService = game:GetService("UserInputService")

local Button = require(script.Parent.Parent.Util.Button)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

local module = {}
module.Active = false
module.DoorState = {}

local RESTRICTIONS_LIST = {
	"Never",
	"Combat",
	"BasicKeycard",
	"SecurityKeycard",
	"MasterKeycard",
	"MRKey",
	"MasterKey",
	"SecurityBadge",
	"LeadSecurityBadge",
	"ITBadge",
}

type DoorData = {
	Base: Part?,
	Side: number?,
	Restrictions: {[number]: string},
	Recover: boolean,
	Locked: boolean,
	IgnoreWhenOpen: boolean,
	IgnoreWhenUnlocked: boolean,
	IgnoreWhenBroken: boolean,
	Display: Part?,
}

local DEFAULT_DOOR_STATE: DoorData = {
	Restrictions = {},
	Recover = false,
	Locked = false,
	IgnoreWhenOpen = false,
	IgnoreWhenUnlocked = false,
	IgnoreWhenBroken = false,
}

module.UIState = State(DEFAULT_DOOR_STATE)
function module:UpdateSelectedState(key: string, value: any)
	local newData = {}
	for k, v in pairs(self.UIState._Value) do
		newData[k] = if k ~= key then v else value
	end
	self.UIState:set(newData)
end
	
-- Data Load/Unload
function module:GetDoorsFromLevel()
	local doors = {}
	local props = workspace.DebugMission.Props:GetChildren()
	for _, part in pairs(props) do
		if string.match(part.Name, "^Door") then
			table.insert(doors, part)
		end
	end
	return doors
end

function module:ReadData(part: Part, side: number)
	local atr = part:GetAttributes()
	local req = atr["PathReq"..side]
	local data: DoorData = {
		Base = part,
		Side = side,
		Restrictions = {},
		Locked = atr[side == 1 and "LockFront" or "LockBack"],
		Recover = atr.PathRecover and atr.PathRecover % (side + side) >= side or false,
		IgnoreWhenOpen = atr.PathIgnoreOpen and atr.PathIgnoreOpen % (side + side) >= side or false,
		IgnoreWhenUnlocked = atr.PathIgnoreUnlocked and atr.PathIgnoreUnlocked % (side + side) >= side or false,
		IgnoreWhenBroken = atr.PathIgnoreBroken and atr.PathIgnoreBroken % (side + side) >= side or false,
	}
	if req then
		for s in req:gmatch("(%a+)") do
			table.insert(data.Restrictions, s)
		end
	end
	return data
end

local function setBitMaskValue(mask: number, bit: number, enabled: boolean)
	local n = if mask % (bit + bit) >= bit then mask - bit else mask
	if enabled then n += bit end
	return n
end

function module:WriteData(part: Part, side: number, data: DoorData)
	local atr = part:GetAttributes()
	local req = table.concat(data.Restrictions, " ")
	part:SetAttribute("PathReq"..side, if req ~= "" then req else nil)
	
	part:SetAttribute(side == 1 and "LockFront" or "LockBack", data.Locked)
	
	local recover = setBitMaskValue(atr.PathRecover or 0, side, data.Recover)
	part:SetAttribute("PathRecover", if recover ~= 0 then recover else nil)
	
	local ignoreOpen = setBitMaskValue(atr.PathIgnoreOpen or 0, side, data.IgnoreWhenOpen)
	part:SetAttribute("PathIgnoreOpen", if ignoreOpen ~= 0 then ignoreOpen else nil)
	
	local ignoreUnlocked = setBitMaskValue(atr.PathIgnoreUnlocked or 0, side, data.IgnoreWhenUnlocked)
	part:SetAttribute("PathIgnoreUnlocked", if ignoreUnlocked ~= 0 then ignoreUnlocked else nil)

	local ignoreBroken = setBitMaskValue(atr.PathIgnoreBroken or 0, side, data.IgnoreWhenBroken)
	part:SetAttribute("PathIgnoreBroken", if ignoreBroken ~= 0 then ignoreBroken else nil)
	
	local newData = self:ReadData(part, side)
	newData.Display = self.DoorState[part][side].Display
	self.DoorState[part][side] = newData
	self:UpdateDisplayedData(newData)
end

-- Display
local COLOR_MAP = {
	Unrestricted = Color3.new(0, 0.8, 0),
	Recovery = Color3.new(0, 0.8, 0),
	Unlocked = Color3.new(0, 0.8, 0),
	Combat = Color3.new(0.8, 0, 0),
	Never = Color3.new(0.8, 0, 0),
	Locked = Color3.new(0.8, 0, 0),
}

function module:UpdateDisplayedData(data: DoorData)
	if data.Display then
		data.Display:Destroy()
		data.Display = nil
	end
	
	local listItems = {}
	table.insert(listItems, data.Locked and "Locked" or "Unlocked")
	
	if #data.Restrictions == 0 then
		table.insert(listItems, "Unrestricted")
	else
		table.insert(listItems, table.concat(data.Restrictions, " - "))
	end
	
	if data.Recover then
		table.insert(listItems, "Recovery")
	end
	
	if data.IgnoreWhenOpen then
		table.insert(listItems, "Ignore When Open")
	end
	
	if data.IgnoreWhenUnlocked then
		table.insert(listItems, "Ignore When Unlocked")
	end
	
	if data.IgnoreWhenBroken then
		table.insert(listItems, "Ignore When Broken")
	end
	
	for index, item in pairs(listItems) do
		listItems[index] = Create("TextLabel", {
			Text = item,
			TextColor3 = COLOR_MAP[item] or Color3.new(1, 1, 1),
			Font = Enum.Font.SciFi,
			TextSize = 42,
			AutomaticSize = Enum.AutomaticSize.XY,
			Size = UDim2.new(0, 0, 0, 0),
			BackgroundTransparency = 1,
			TextWrapped = true
		})
	end
	
	if data.Base then
		data.Display = Create("Part", {
			CFrame = data.Base.CFrame * CFrame.Angles(0, data.Side == 2 and math.pi or 0, 0) * CFrame.new(0, 0, -0.5),
			Size = Vector3.new(4, 4, 0.2),
			Parent = workspace,
			Material = Enum.Material.Glass,
			Color = Color3.new(0, 0, 0),
		}, {
			Create("SurfaceGui", {
				PixelsPerStud = 25,
			}, {
				Create("Frame", {
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 1,
				}, {
					Create("UIListLayout", {
						VerticalAlignment = Enum.VerticalAlignment.Center,
						HorizontalAlignment = Enum.HorizontalAlignment.Center,
						Padding = UDim.new(0, 10),
					}),
					listItems,
				})
			})
		})
	end
end

-- Input Processing
module.ProcessInput = function(io: InputObject)
	if io.UserInputState == Enum.UserInputState.Begin then
		local door, side = module:GetHoveredDoor()
		if io.UserInputType == Enum.UserInputType.MouseButton1 then
			if door and side then
				print("Overwrite")
				module:WriteData(door, side, module.UIState._Value)
			end
		elseif io.KeyCode == Enum.KeyCode.F then
			if door and side then
				print("Copy door data")
				module.UIState:set(module:ReadData(door, side))
			else
				print("Clearing door data")
				module.UIState:set(DEFAULT_DOOR_STATE)
			end
		end
	end
end

function module:GetHoveredDoor(): (Part?, number?)
	local part = self.Mouse.Target
	if part and part:IsA("Part") and self.DoorState[part] then
		local hit = self.Mouse.Hit.Position
		local rel = part.CFrame:PointToObjectSpace(hit)
		return part, if rel.Z < 0 then 1 else 2
	end
	return nil, nil
end

-- UI setup
function module:InitUI()
	
	local buttons = {
		Button({
			Text = "Locked",
			Enabled = Derived(function(data: DoorData)
				return data.Locked
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("Locked", not self.UIState._Value.Locked)
			end,
		}),
		Button({
			Text = "Recovery",
			Enabled = Derived(function(data: DoorData)
				return data.Recover
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("Recover", not self.UIState._Value.Recover)
			end,
		}),
		Button({
			Text = "Ignore When Open",
			Enabled = Derived(function(data: DoorData)
				return data.IgnoreWhenOpen
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("IgnoreWhenOpen", not self.UIState._Value.IgnoreWhenOpen)
			end,
		}),
		Button({
			Text = "Ignore When Unlocked",
			Enabled = Derived(function(data: DoorData)
				return data.IgnoreWhenUnlocked
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("IgnoreWhenUnlocked", not self.UIState._Value.IgnoreWhenUnlocked)
			end,
		}),
		Button({
			Text = "Ignore When Broken",
			Enabled = Derived(function(data: DoorData)
				return data.IgnoreWhenBroken
			end, self.UIState),
			Activated = function()
				self:UpdateSelectedState("IgnoreWhenBroken", not self.UIState._Value.IgnoreWhenBroken)
			end,
		}),
	}
	
	for index, text in pairs(RESTRICTIONS_LIST) do
		table.insert(buttons, Button({
			Text = text,
			Enabled = Derived(function(data: DoorData)
				for _, restriction in pairs(data.Restrictions) do
					if restriction == text then
						return true
					end
				end
				return false
			end, module.UIState),
			Activated = function()
				local wasRemoved = false
				local copy = {}
				for _, restriction in pairs(module.UIState._Value.Restrictions) do
					if restriction ~= text then
						table.insert(copy, restriction)
					else
						wasRemoved = true
					end
				end
				if not wasRemoved then
					table.insert(copy, text)
				end
				self:UpdateSelectedState("Restrictions", copy)
			end,
		}))
	end
	
	self.UI = Create("ScreenGui", {
		Parent = game.StarterGui,
		Archivable = false,
		Name = "DoorAccessConfig",
	}, {
		Create("Frame", {
			Position = UDim2.new(1, -20, 1, -20),
			AnchorPoint = Vector2.new(1, 1),
			Size = UDim2.new(0, 200, 0, 200),
			BackgroundTransparency = 1,
		}, {
			Create("UIListLayout", {
				VerticalAlignment = Enum.VerticalAlignment.Bottom,
				HorizontalAlignment = Enum.HorizontalAlignment.Left,
			}),
			buttons
		})
	})
end

function module:CleanUI()
	if self.UI then
		self.UI:Destroy()
		self.UI = nil
	end
end

-- Init/Cleanup
module.Init = function(mouse: PluginMouse)
	if module.Active then return end
	module.Active = true
	
	local self = module
	self.Mouse = mouse
	
	for _, door in pairs(self:GetDoorsFromLevel()) do
		self.DoorState[door] = {
			self:ReadData(door, 1),
			self:ReadData(door, 2),
		}
		self:UpdateDisplayedData(self.DoorState[door][1])
		self:UpdateDisplayedData(self.DoorState[door][2])
	end
	
	self:InitUI()
	
	self.InputEvent = UserInputService.InputBegan:Connect(module.ProcessInput)
end

module.Clean = function()
	if not module.Active then return end
	module.Active = false
	
	local self = module

	self.InputEvent:Disconnect()
	self.InputEvent = nil

	for _, list in pairs(self.DoorState) do
		for _, data in pairs(list) do
			if data.Display then
				data.Display:Destroy()
			end
		end
	end
	self.DoorState = {}
	
	self:CleanUI()
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXA76D4243F4D248EEAFA848C0851A9764">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MeadowMap</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX16663BA847404438B8B068E2D7DCDF73">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{2F1A8E49-8E4A-4D7A-AA9A-5136BF0A80BE}</string>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local AxisAlign = require(script.Parent.Parent.Util.AxisAlign)
local ZoneUtil = require(script.Parent.Parent.Util.ZoneUtil)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local UserInputService = game:GetService("UserInputService")
local UserInputConnection

local DOOR_BUFFER = 4.5

local CurrentZone = nil
local CurrentMap = {}
local CurrentModel = nil
local LinkWith = nil

local function CloseZone()
	if CurrentModel then
		CurrentModel:Destroy()
		CurrentModel = nil
	end
	CurrentMap = {}
	CurrentZone = nil
end

local function CheckLOS(p0, p1)
	if p0 == p1 then return false end
	local result = workspace:Raycast(p0.Position + Vector3.new(0, 0.75, 0), p1.Position - p0.Position)
	return not result or result.Instance == p1
end

local function AddLink(p0, p1)
	local l0 = Instance.new("Part")
	l0.Size = Vector3.new(0.4, 0.4, (p0.Position - p1.Position).magnitude / 2)
	l0.Transparency = 0.5
	local l1 = l0:Clone()
	
	l0.CFrame = CFrame.new(p0.Position * 0.75 + p1.Position * 0.25, p0.Position)
	if not CurrentMap[p0][p1] then
		CurrentMap[p0][p1] = l0
		l0.BrickColor = BrickColor.new("Bright blue")
		l0.Parent = CurrentModel
	end
	
	l1.CFrame = CFrame.new(p1.Position * 0.75 + p0.Position * 0.25, p1.Position)
	if not CurrentMap[p1][p0] then
		CurrentMap[p1][p0] = l1
		l1.BrickColor = BrickColor.new("Bright blue")
		l1.Parent = CurrentModel
	end
end

local function AddOneWayLink(p0, p1)
	local l0 = Instance.new("Part")
	l0.Size = Vector3.new(0.4, 0.4, (p0.Position - p1.Position).magnitude / 2)
	l0.Transparency = 0.5

	l0.CFrame = CFrame.new(p0.Position * 0.75 + p1.Position * 0.25, p0.Position)
	if not CurrentMap[p0][p1] then
		CurrentMap[p0][p1] = l0
		l0.BrickColor = BrickColor.new("Bright blue")
		l0.Parent = CurrentModel
	end
end

local function CreateNode(pos, placed, generateLinks)
	if placed and not ZoneUtil.InZone(CurrentZone, pos) then
		warn("Nodes should not be placed outside of their cell")
		return
	end

	local p = Instance.new("Part")
	p.Size = Vector3.new(2, 2, 2)
	p.Parent = CurrentModel
	p.CFrame = CFrame.new(pos)
	p.BrickColor = BrickColor.new("Bright blue")
	if placed then p.Transparency = 0.5 end
	CurrentMap[p] = {}
	if generateLinks then
		for node in pairs(CurrentMap) do
			if node ~= p and CheckLOS(node, p) then
				AddLink(node, p)
			end
		end
	end
	return p
end

local function OpenZone(newZone)
	if CurrentZone then
		CloseZone()
	end

	local DoorNodes = {}
	for _, prop in pairs(workspace.DebugMission.Props:GetChildren()) do
		if prop.Name:match("Door") then
			local p0 = (prop.CFrame * CFrame.new(0, -3, DOOR_BUFFER)).p
			local p1 = (prop.CFrame * CFrame.new(0, -3, -DOOR_BUFFER)).p
			if ZoneUtil.InZone(newZone, p0) then table.insert(DoorNodes, p0) end
			if ZoneUtil.InZone(newZone, p1) then table.insert(DoorNodes, p1) end
		end
	end
	
	if workspace.DebugMission.Cells:FindFirstChild("Links") then
		for _, link in pairs(workspace.DebugMission.Cells.Links:GetChildren()) do
			if link:GetAttribute("Path") then
				local p0 = (link.CFrame * CFrame.new(0, 0.5, DOOR_BUFFER)).p
				local p1 = (link.CFrame * CFrame.new(0, 0.5, -DOOR_BUFFER)).p
				if ZoneUtil.InZone(newZone, p0) then table.insert(DoorNodes, p0) end
				if ZoneUtil.InZone(newZone, p1) then table.insert(DoorNodes, p1) end
			end
		end
	end

	CurrentModel = Instance.new("Model")
	CurrentModel.Parent = workspace
	CurrentMap = {}
	CurrentZone = newZone

	for _, pos in pairs(DoorNodes) do
		CreateNode(pos, false, true)
	end
	
	--[[if CurrentZone:GetAttribute("Path") then
		local data = HttpService:JSONDecode(CurrentZone:GetAttribute("Path"))
		if data.Placed then
			for _, placed in pairs(data.Placed) do
				CreateNode(Vector3.new(unpack(placed)), true, true)
			end
		end
	end]]
end

local function OpenZoneWithoutRegenerating(newZone)
	if CurrentZone then
		CloseZone()
	end
	
	CurrentModel = Instance.new("Model")
	CurrentModel.Parent = workspace
	CurrentMap = {}
	CurrentZone = newZone

	if not CurrentZone:GetAttribute("Path") then
		print("Doing first time generation for zone")
		return OpenZone(newZone)
	end
		
	local data = HttpService:JSONDecode(CurrentZone:GetAttribute("Path"))
	local PlacedNodes = {}
	if data.Placed then
		for _, placed in pairs(data.Placed) do
			local node = Vector3.new(unpack(placed))
			PlacedNodes[node] = true
		end
	end
	
	local NodeParts = {}
	for _, node in pairs(data.Node) do
		local pos = Vector3.new(unpack(node))
		local nodePart = CreateNode(pos, PlacedNodes[pos], false)
		table.insert(NodeParts, nodePart)
	end
	
	for startIndex, list in data.Link do
		for _, endIndex in list do
			AddOneWayLink(NodeParts[startIndex], NodeParts[endIndex])
		end
	end
end

local function RemovePart(part)
	if CurrentMap[part] then -- Is node
		for _, linkPart in pairs(CurrentMap[part]) do
			linkPart:Destroy()
		end
		CurrentMap[part] = nil
		for node, links in pairs(CurrentMap) do
			if links[part] then
				links[part]:Destroy()
				links[part] = nil
			end
		end
		part:Destroy()
	else -- Is link
		for node, linkList in pairs(CurrentMap) do
			for link, linkPart in pairs(linkList) do
				if linkPart == part then
					linkPart:Destroy()
					linkList[link] = nil
					break
				end
			end
		end
	end
end

local function Serialize()
	local node = {}
	local nodeId = {}
	local link = {}
	local placed = {}
	
	local function getNode(p)
		if not nodeId[p] then
			local pos = p.Position
			node[#node+1] = {pos.X, pos.Y, pos.Z}
			nodeId[p] = #node
			
			if p.Transparency > 0.25 then
				table.insert(placed, node[#node])
			end
		end
		return nodeId[p]
	end
	
	for node, linkList in pairs(CurrentMap) do
		local id = getNode(node)
		local links = {}
		for linkNode in pairs(linkList) do
			table.insert(links, getNode(linkNode))
		end
		link[id] = links
	end
	
	return HttpService:JSONEncode({
		Node = node,
		Link = link,
		Placed = placed,
	})
end

local function Save()
	CurrentZone:SetAttribute("Path", Serialize())
end

local LastCTap = 0

return {
	Init = function(mouse)
		print("T - Open Cell Meadow Map")
		print("C - Fully Clear Meadow Map (Tap twice)")
		print("G - Add Node")
		print("H - Add Node (No Link Generation)")
		print("R - Remove")

		VisibilityToggle.TempReveal(workspace.DebugMission.Cells)
		
		UserInputConnection = UserInputService.InputBegan:Connect(function(io)
			if io.KeyCode == Enum.KeyCode.C then
				if tick() - LastCTap < 0.5 then
					LastCTap = 0
					local zone = ZoneUtil.GetZone(mouse.Hit.p)
					if zone then 
						OpenZone(zone) 
						Save()
					end
				else
					LastCTap = tick()
					local clock = LastCTap
					task.delay(0.5, function()
						if clock ~= LastCTap then
							return
						end
						warn("Double tap C to fully clear and regenerate the meadow map for this room\nThis will remove any manual modifications you've made")
					end)
				end
			elseif io.KeyCode == Enum.KeyCode.T then
				local zone = ZoneUtil.GetZone(mouse.Hit.p)
				if zone then 
					OpenZoneWithoutRegenerating(zone) 
					Save()
				elseif CurrentZone then
					CloseZone()
				end
			elseif io.KeyCode == Enum.KeyCode.G then
				if CurrentZone then
					CreateNode(mouse.Hit.p + Vector3.new(0, 1, 0), true, true)
					Save()
				end
			elseif io.KeyCode == Enum.KeyCode.H then
				if CurrentZone then
					CreateNode(mouse.Hit.p + Vector3.new(0, 1, 0), true, false)
					Save()
				end
			elseif io.KeyCode == Enum.KeyCode.R then
				if mouse.Target then
					RemovePart(mouse.Target)
					Save()
				end
			elseif io.UserInputType == Enum.UserInputType.MouseButton1 then
				if LinkWith then
					if CurrentMap[LinkWith] and CurrentMap[mouse.Target] then
						AddLink(LinkWith, mouse.Target)
						Save()
					else
						print("Link failed")
					end
					LinkWith = nil
				elseif CurrentMap[mouse.Target] then
					LinkWith = mouse.Target
					print("Click another node to link")
				end
			end
		end)
	end,
	Clean = function()
		if UserInputConnection then
			UserInputConnection:Disconnect()
			UserInputConnection = nil
		end
		if CurrentZone then
			CloseZone()
		end
	end,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX2BB34487F31844169B4DA92BBB41E2A0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PropBarrier</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX63569A9A4E4D403D8782F7FB27565AD8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{02F51D6C-CC75-4483-8C24-7C3272733982}</string>
					<ProtectedString name="Source"><![CDATA[--!strict

local UserInputService = game:GetService("UserInputService")

local Button = require(script.Parent.Parent.Util.Button)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local DEFAULT_COLOR = Color3.fromRGB(163, 162, 165)
local OFF_COLOR = Color3.fromRGB(30, 30, 30)
local ON_COLOR = Color3.fromRGB(0, 170, 170)

local ATTRIBUTE_NAME = "HasTopBarrier"
local PROP_BARRIER = "PropBarrier"

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

local module = {}
module.Active = false
module.DoorState = {}

-- Input Processing
module.ProcessInput = function(self, io)
	if io.UserInputState == Enum.UserInputState.Begin then
		if io.UserInputType == Enum.UserInputType.MouseButton1 then
			local part = self.Mouse.Target
			if part and part.Parent.Name == "Props" then
				local newValue = if part:GetAttribute(ATTRIBUTE_NAME) then nil else true
				part:SetAttribute(ATTRIBUTE_NAME, newValue)
				part.Color = newValue and ON_COLOR or OFF_COLOR
			end
		end
	end
end

local MAX_DIST = 20
local IgnoreList = {}
local CastConfig = RaycastParams.new()
CastConfig.FilterType = Enum.RaycastFilterType.Exclude

module.GetProjectedDistance = function(self, pos: Vector3, dir: Vector3)
	local cast = workspace:Raycast(pos, dir * MAX_DIST, CastConfig)
	while cast and cast.Instance and cast.Instance.Transparency > 0.3 do
		table.insert(IgnoreList, cast.Instance)
		CastConfig.FilterDescendantsInstances = IgnoreList
		cast = workspace:Raycast(pos, dir * MAX_DIST, CastConfig)
	end

	if cast then
		return cast.Distance
	end

	return MAX_DIST
end

-- Init/Cleanup
module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	if workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild("Props") then
		for _, prop in pairs(workspace.DebugMission.Props:GetChildren()) do
			if prop:IsA("BasePart") then
				prop.Color = prop:GetAttribute(ATTRIBUTE_NAME) and ON_COLOR or OFF_COLOR
			end
		end

		if workspace.DebugMission:FindFirstChild("Barrier") then
			VisibilityToggle.TempReveal(workspace.DebugMission.Barrier)

			for _, part in pairs(workspace.DebugMission.Barrier:GetChildren()) do
				if part:GetAttribute(PROP_BARRIER) then
					part:Destroy()
				end
			end
		end
	end

	local self = module
	self.Mouse = mouse

	self.InputEvent = UserInputService.InputBegan:Connect(function(io)
		self:ProcessInput(io)
	end)
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	local self = module

	if workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild("Props") then
		for _, prop in pairs(workspace.DebugMission.Props:GetChildren()) do
			if prop:IsA("BasePart") then
				prop.Color = DEFAULT_COLOR

				if prop:GetAttribute(ATTRIBUTE_NAME) then
					local top = prop.CFrame * CFrame.new(0, prop.Size.Y / 2, 0)
					local dist = module:GetProjectedDistance(top.p, Vector3.yAxis)

					local b = Instance.new("Part")
					b.Color = ON_COLOR
					b.Size = Vector3.new(prop.Size.X, dist, prop.Size.Z)
					b.CFrame = top * CFrame.new(0, dist / 2, 0)
					b.Anchored = true
					b.Transparency = 0.5
					b.TopSurface = Enum.SurfaceType.SmoothNoOutlines
					b.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
					b.CastShadow = false

					b:SetAttribute(PROP_BARRIER, true)

					b.Parent = workspace.DebugMission.Barrier
				end
			end
		end
	end

	self.InputEvent:Disconnect()
	self.InputEvent = nil
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX31A99325014546E6BD8EC0E46D2AB5DE">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PropPreview</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX9872CC50A5EA44E9818381857B23454B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{50EFE37D-6063-4588-BC64-E398FBBE1F50}</string>
					<ProtectedString name="Source"><![CDATA[local PhysicsService = game:GetService("PhysicsService")

local COLLISON_GROUP = "PluginNoCollision"

local ModelFolder = game.ReplicatedStorage:FindFirstChild("Assets")
ModelFolder = ModelFolder and ModelFolder:FindFirstChild("Props")

local Button = require(script.Parent.Parent.Util.Button)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable

local CustomPropsFolder = State(false)

local module = {}

local ColorMap = {}
local Prop = {}

-- Position/Color
function module:RepositionProp(part)
	local model = Prop[part]
	model = model and model.Model
	local base = model and model:FindFirstChild("Base", true)

	if not base then
		return
	end

	local diff = part.CFrame * base.CFrame:Inverse()
	for _, p in pairs(model:GetDescendants()) do
		if p:IsA("BasePart") then
			p.CFrame = diff * p.CFrame
		end
	end
end

function module:RecolorProp(part)
	local model = Prop[part]
	model = model and model.Model
	if not model then
		return
	end

	local index = 0
	local search = true
	local colors = {}
	while true do
		local colour = part:GetAttribute("Color" .. index)
		if colour then
			if typeof(colour) == "string" then
				colour = ColorMap[colour]
			end
			colors["Part" .. index] = {
				Color = colour,
				Material = part:GetAttribute("Material" .. index),
			}
			index += 1
		else
			break
		end
	end

	for _, p in pairs(model:GetDescendants()) do
		if p:IsA("BasePart") and colors[p.Name] then
			for prop, value in pairs(colors[p.Name]) do
				p[prop] = value
			end
		end
	end
end

-- Add/Remove

local BaseByModel = {}
function module:AddProp(basePart)
	if not basePart:IsA("BasePart") then
		return
	end

	if Prop[basePart] then
		return
	end

	local storedModel = CustomPropsFolder._Value and CustomPropsFolder._Value:FindFirstChild(basePart.Name)
		or ModelFolder and ModelFolder:FindFirstChild(basePart.Name)
	if storedModel then
		basePart.Transparency = 1

		local model = storedModel:Clone()
		for _, p in pairs(model:GetDescendants()) do
			if p:IsA("BasePart") then
				p.Archivable = false
				p.CollisionGroup = COLLISON_GROUP
			end
		end

		Prop[basePart] = {
			Model = model,
			Events = {
				basePart:GetPropertyChangedSignal("CFrame"):Connect(function()
					self:RepositionProp(basePart)
				end),
				basePart.AttributeChanged:Connect(function()
					self:RecolorProp(basePart)
				end),
			},
		}
		model.Parent = self.Folder
		BaseByModel[model] = basePart
		self:RepositionProp(basePart)
		self:RecolorProp(basePart)
	end
end

function module:RemoveProp(basePart)
	if basePart:IsA("BasePart") then
		basePart.Transparency = 0.5
	end

	local propData = Prop[basePart]
	if propData then
		BaseByModel[propData.Model] = nil
		propData.Model:Destroy()
		for _, event in pairs(propData.Events) do
			event:Disconnect()
		end
		Prop[basePart] = nil
	end
end

module.OverlaysEnabled = false
module.EnabledState = State(false)

function module:SetEnabled()
	if self.Enabled then
		return
	end
	self.Enabled = true

	if workspace.DebugMission:FindFirstChild("MissionSetup") then
		local missionData = require(workspace.DebugMission.MissionSetup:Clone())
		ColorMap = missionData.Colors or {}
	end

	module.Folder = workspace:FindFirstChild("PropPreviewModels") or Instance.new("Folder")
	module.Folder.Archivable = false
	module.Folder.Parent = workspace
	module.Folder.Name = "PropPreviewModels"

	PhysicsService:RegisterCollisionGroup(COLLISON_GROUP)
	PhysicsService:CollisionGroupSetCollidable("Default", COLLISON_GROUP, false)

	for _, prop in pairs(workspace.DebugMission.Props:GetDescendants()) do
		module:AddProp(prop)
	end

	local HiddenModels = {}

	module.AddEvents = {
		workspace.DebugMission.Props.DescendantAdded:Connect(function(p)
			self:AddProp(p)
		end),
		workspace.DebugMission.Props.DescendantRemoving:Connect(function(p)
			self:RemoveProp(p)
		end),
		game.Selection.SelectionChanged:Connect(function()
			local selectedParts = {}
			local didSubstitution = false
			for _, part in game.Selection:Get() do
				local sub = BaseByModel[part]
				if sub then
					didSubstitution = true
					selectedParts[sub] = true
				else
					selectedParts[part] = true
				end
			end

			if didSubstitution then
				local newList = {}
				for p in selectedParts do
					table.insert(newList, p)
					game.Selection:Set(newList)
				end
			else
				for base, model in HiddenModels do
					if not selectedParts[base] then
						model.Parent = workspace
						HiddenModels[base] = nil
					end
				end
				for base in selectedParts do
					if Prop[base] then
						HiddenModels[base] = Prop[base].Model
						HiddenModels[base].Parent = nil
					end
				end
			end
		end),
	}
end

local SearchText = State("")
local SearchResults = Derived(function(text, customProps)
	local list = {}
	if ModelFolder then
		for _, item in pairs(ModelFolder:GetChildren()) do
			if string.lower(item.Name):match(string.lower(text)) then
				table.insert(list, item.Name)
			end
		end
		if customProps then
			for _, item in customProps:GetChildren() do
				if not ModelFolder:FindFirstChild(item.Name) and string.lower(item.Name):match(string.lower(text)) then
					table.insert(list, item.Name)
				end
			end
		end
	end
	return list
end, SearchText, CustomPropsFolder)

function module:SetDisabled()
	if not self.Enabled then
		return
	end
	self.Enabled = false

	module.Folder:Destroy()

	for _, e in pairs(self.AddEvents) do
		e:Disconnect()
	end
	self.AddEvents = nil

	PhysicsService:RemoveCollisionGroup(COLLISON_GROUP)

	for _, prop in pairs(workspace.DebugMission.Props:GetDescendants()) do
		module:RemoveProp(prop)
	end
end

-- Init/Cleanup
module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	CustomPropsFolder:set(
		workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild("CustomProps") or false
	)

	local searchBox
	searchBox = Create("TextBox", {
		PlaceholderText = "Search For Prop",
		Text = "",
		Size = UDim2.new(0, 300, 0, 30),
		Position = UDim2.new(0, 50, 0, 80),
		BorderSizePixel = 0,
		Changed = function()
			if searchBox then
				SearchText:set(searchBox.Text)
			end
		end,
		BackgroundColor3 = Color3.new(1, 1, 1),
		BackgroundTransparency = 0.5,
	})

	module.UI = Create("ScreenGui", {
		Parent = game.StarterGui,
		Archivable = false,
	}, {
		Button({
			Size = UDim2.new(0, 300, 0, 30),
			Enabled = module.EnabledState,
			Position = UDim2.new(0, 50, 0, 50),
			Text = Derived(function(e)
				return e and "Disable Prop Preview" or "Enable Prop Preview"
			end, module.EnabledState),
			Activated = function()
				module.OverlaysEnabled = not module.OverlaysEnabled
				module.EnabledState:set(module.OverlaysEnabled)
				if module.OverlaysEnabled then
					module:SetEnabled()
				else
					module:SetDisabled()
				end
			end,
		}),
		searchBox,
		Create("ScrollingFrame", {
			Size = UDim2.new(0, 300, 0.8, -100),
			Position = UDim2.new(0, 50, 0.9, 0),
			AnchorPoint = Vector2.new(0, 1),
			AutomaticCanvasSize = Enum.AutomaticSize.Y,
			BackgroundTransparency = 1,
		}, {
			Create("UIListLayout", {}),
			DerivedTable(function(index, value)
				return Button({
					Text = value,
					Enabled = State(false),
					Activated = function()
						local model = CustomPropsFolder._Value and CustomPropsFolder._Value:FindFirstChild(value)
							or ModelFolder[value]
						local base = model and model:FindFirstChild("Base")
						if base then
							local prop = base:Clone()
							prop.Name = value
							prop.Transparency = 0.5
							prop.Parent = workspace.DebugMission.Props
							prop.CFrame = CFrame.new((workspace.CurrentCamera.CFrame * CFrame.new(0, 0, -5)).Position)
						end
					end,
					Size = UDim2.new(1, 0, 0, 30),
				})
			end, SearchResults),
		}),
	})
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	module.UI:Destroy()
	module.UI = nil
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXDF23C1703CDE4C5495526388C814678D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ZoneMarker</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXFACECBEB44124304962F40FB46D9F7AE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GetZone</string>
					<string name="ScriptGuid">{27EAE60F-8A95-429E-A032-6FD05C239681}</string>
					<ProtectedString name="Source"><![CDATA[return function(pos)
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, zone in pairs(LevelBase.Cells:GetChildren()) do
		local floorMatch = zone:FindFirstChild("Floor") == nil
		local roofMatch = false
		
		for _, part in pairs(zone:GetChildren()) do
			local rel = part.CFrame:PointToObjectSpace(pos)
			
			if math.abs(rel.X) <= part.Size.X / 2 and math.abs(rel.Z) <= part.Size.Z / 2 then
				if part.Name == "Roof" and rel.Y <= 0 then
					roofMatch = true
				elseif part.Name == "Floor" and rel.Y >= 0 then
					floorMatch = true
				end
				
				if floorMatch and roofMatch then
					return zone
				end
			end
		end
	end
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3EFCA4DD3D6D44DD8DE53FD63DA46187">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{A69D8C2B-B3FE-4CDD-9BA0-5720AB7115D7}</string>
					<ProtectedString name="Source"><![CDATA[local AxisAlign = require(script.Parent.Parent.Util.AxisAlign)
local GetZone = require(script.Parent.GetZone)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)

local UserInputService = game:GetService("UserInputService")

local MAX_PROJECT = 50
local SIZE_PADDING = 1
local POSITION_SINK = 0.3

local CellFolder
local Events = {}
local Ghost
local MouseDown = false

local GhostCfr
local GhostSize
local GhostMax
local GhostMin

local CastParams = RaycastParams.new()
local function GetProjectionDist(basePos, axis)
	local result = workspace:Raycast(basePos, axis * MAX_PROJECT, CastParams)
	if result then
		return (result.Position - basePos).magnitude
	else
		return MAX_PROJECT
	end
end

local function UpdateGhost(basePos, axis0, axis1)
	local z0, z1 = GetProjectionDist(basePos, axis0), GetProjectionDist(basePos, -axis0)
	local x0, x1 = GetProjectionDist(basePos, axis1), GetProjectionDist(basePos, -axis1)
	
	local pos = basePos + axis0 * (z0 - z1) / 2 + axis1 * (x0 - x1) / 2
	GhostCfr = CFrame.new(pos, pos + axis0)
	GhostSize = Vector3.new(x0 + x1, 0.2, z0 + z1)
	GhostMax = GetProjectionDist(basePos, Vector3.new(0, 1, 0))
	GhostMin = GetProjectionDist(basePos, Vector3.new(0, -1, 0))
	
	if GhostMax == MAX_PROJECT then
		GhostMax = GhostMax - GhostMin
	end
	
	Ghost.CFrame = GhostCfr
	Ghost.Size = GhostSize
end

local function ReoptimizeCells()
	print("Reoptimize cell floors")
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, cell in pairs(LevelBase.Cells:GetChildren()) do
		if cell:IsA("Model") then
			local canFit = true
			local floorPart

			local baseRef = cell:FindFirstChild("Roof")
			local minX, maxX = baseRef.Position.X, baseRef.Position.X
			local minZ, maxZ = baseRef.Position.Z, baseRef.Position.Z

			for _, part in pairs(cell:GetChildren()) do
				if part.Name=="Roof" then
					for xo = -1, 1, 2 do
						for zo = -1, 1, 2 do
							local ref = part.CFrame:pointToWorldSpace(Vector3.new(part.Size.X * 0.5 * xo, 0, part.Size.Z * 0.5 * zo))
							minX = math.min(minX, ref.X)
							maxX = math.max(maxX, ref.X)
							minZ = math.min(minZ, ref.Z)
							maxZ = math.max(maxZ, ref.Z)
						end
					end
				elseif part.Name=="Floor" then
					if floorPart==nil then
						floorPart = part
					else
						canFit = false
						break
					end
				end
			end

			if floorPart and canFit then
				floorPart.Size = Vector3.new(maxX - minX, floorPart.Size.Y, maxZ - minZ)
				floorPart.CFrame = CFrame.new((maxX + minX)/2, floorPart.Position.Y, (maxZ + minZ)/2)
			end
		end
	end
end

local function ShowCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		for _, part in pairs(cell:GetChildren()) do
			part.Size = Vector3.new(part.Size.X, 1, part.Size.Z)
			part.Transparency = 0.5
			part.Locked = false
		end
	end
end

local function ShowLinks()
	for _, cell in pairs(CellFolder:GetChildren()) do
		if cell.Name ~= "Links" then continue end
		for _, part in pairs(cell:GetChildren()) do
			part.Size = Vector3.new(part.Size.X, 1, part.Size.Z)
			part.Transparency = 0.5
			part.Locked = false
		end
	end
end

local function HideCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		for _, part in pairs(cell:GetChildren()) do
			part.Size = Vector3.new(part.Size.X, 0, part.Size.Z)
			part.Transparency = 1
			part.Locked = true
		end
	end
end

local function HideNamedCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		if cell.Name ~= "Default" then
			for _, part in pairs(cell:GetChildren()) do
				part.Size = Vector3.new(part.Size.X, 0, part.Size.Z)
				part.Transparency = 1
				part.Locked = true
			end
		end
	end
end

local function hashName(name)
	if name == "Default" then
		return Color3.new(0, 0, 0)
	end
	
	local h = 5^7
	local n = 0
	for i = 1, #name do
		n = (n * 257 + string.byte(name, i, i)) % h 
	end
	local color = Color3.fromHSV((n % 1000) / 1000, 0.5, 0.5)
	return color
end

local function RecolorCells()
	for _, cell in pairs(CellFolder:GetChildren()) do
		local color = hashName(cell.Name)
		for _, part in pairs(cell:GetChildren()) do
			part.Color = color
		end
	end
end

local function CreateCell(mousePos)
	local cellModel = GetZone(mousePos)
	local addFloor = true
	
	if cellModel then
		addFloor = false
		print("Add to:", cellModel:GetFullName())
	else
		local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
		print("Create new cell")
		cellModel = Instance.new("Model")
		cellModel.Name = "Default"
		cellModel.Parent = LevelBase.Cells
	end
	
	local roof = Ghost:Clone()
	roof.Size = roof.Size + Vector3.new(SIZE_PADDING * 2, 0.8, SIZE_PADDING * 2)
	roof.CFrame = GhostCfr * CFrame.new(0, GhostMax + POSITION_SINK, 0)
	roof.Name = "Roof"
	roof.Parent = cellModel
	roof.Anchored = true
	
	if addFloor then
		local floor = roof:Clone()
		floor.Name = "Floor"
		floor.CFrame = GhostCfr * CFrame.new(0, -GhostMin - POSITION_SINK, 0)
		floor.Parent = cellModel
		floor.Anchored = true
	else
		ReoptimizeCells()
	end
end

return {
	Init = function(mouse)
		if not workspace:FindFirstChild("Level") then
			local l = Instance.new("Folder")
			l.Name = "Level"
			l.Parent = workspace
		end
		local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
		if not LevelBase:FindFirstChild("Cells") then
			local c = Instance.new("Folder")
			c.Name = "Cells"
			c.Parent = LevelBase
		end
		
		Ghost = Instance.new("Part")
		Ghost.Color = Color3.new(0, 0, 0)
		Ghost.Transparency = 0.5
		Ghost.Parent = LevelBase.Cells
		
		CellFolder = LevelBase.Cells
		mouse.TargetFilter = CellFolder
		CastParams.FilterType = Enum.RaycastFilterType.Blacklist
		CastParams.FilterDescendantsInstances = { CellFolder }
		
		Events[1] = game["Run Service"].RenderStepped:connect(function()
			if mouse.Target and not MouseDown then
				local v0, v1 = AxisAlign.CameraAlign(mouse.Target.CFrame)
				local origin = mouse.Hit.p - mouse.UnitRay.Direction * 0.5
				UpdateGhost(origin, v0, v1)
			end
		end)
		
		Events[2] = mouse.Button1Up:connect(function()
			CreateCell(mouse.Hit.p)
			MouseDown = false
		end)

		Events[3] = mouse.Button1Down:connect(function()
			MouseDown = true
		end)
		
		Events[3] = UserInputService.InputBegan:connect(function(io)
			if io.KeyCode == Enum.KeyCode.T then
				ReoptimizeCells()
			elseif io.KeyCode == Enum.KeyCode.G then
				ShowCells()
			elseif io.KeyCode == Enum.KeyCode.H then
				HideCells()
			elseif io.KeyCode == Enum.KeyCode.J then
				HideNamedCells()
			elseif io.KeyCode == Enum.KeyCode.K then
				RecolorCells()
			elseif io.KeyCode == Enum.KeyCode.L then
				ShowLinks()
			end
		end)

		VisibilityToggle.TempReveal(workspace.DebugMission.Cells)
		
		print([[T - Reoptimize Cell Floors
		G - Show All Cells
		H - Hide All Cells
		J - Hide Named Cells
		K - Recolor Cells
		L - Show Links]])
	end,
	Clean = function()
		if Events then
			for _, e in pairs(Events) do
				e:Disconnect()
			end
			Events = {}
		end
		if Ghost then
			Ghost:Destroy()
			Ghost = nil
		end
	end,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBXA0EC85C35B214484972AC52715976C54">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{ADAD6147-97CE-4D9B-AE96-5C0B09ED42FD}</string>
				<ProtectedString name="Source"><![CDATA[-- Infiltration Engine Tooling created by Cishshato
-- Modified by GhfjSpero
-- All Rights Reserved

local toolbar = plugin:CreateToolbar("Infiltration Engine Tools")
local MeadowMapButton = toolbar:CreateButton("Meadow Map", "Meadow Map", "rbxassetid://13749858361")
local DoorAccessButton = toolbar:CreateButton("Door Access", "Door Access", "rbxassetid://72317736899762")
local PropBarrierButton = toolbar:CreateButton("Prop Barrier", "Prop Barrier", "rbxassetid://119815023380659")
local PropPreviewButton = toolbar:CreateButton("Prop Preview", "Prop Preview", "rbxassetid://129506771895350")
local CombatMapButton = toolbar:CreateButton("Combat Flow Map", "Combat Flow Map", "rbxassetid://107812298422418")
local ZoneMarkerButton = toolbar:CreateButton("Cell Marker", "Cell Editor", "rbxassetid://97000446266881")
local SectionVisibilityButton =
	toolbar:CreateButton("Section Visibility", "Section Visibility", "rbxassetid://8753176416")

local MeadowMap = require(script.Parent.MeadowMap.Main)
local DoorAccess = require(script.Parent.DoorAccess.Main)
local PropBarrier = require(script.Parent.PropBarrier.Main)
local PropPreview = require(script.Parent.PropPreview.Main)
local CombatMap = require(script.Parent.CombatMap.Main)
local ZoneMarker = require(script.Parent.ZoneMarker.Main)
local SectionVisibility = require(script.Parent.SectionVisibility.Main)
local CurrentPlugin = nil

local VisibilityToggle = require(script.Parent.Util.VisibilityToggle)

MeadowMapButton.Click:connect(function()
	if CurrentPlugin ~= MeadowMap then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = MeadowMap
		plugin:Activate(true)
		MeadowMap.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

DoorAccessButton.Click:connect(function()
	if CurrentPlugin ~= DoorAccess then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = DoorAccess
		plugin:Activate(true)
		CurrentPlugin.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

PropBarrierButton.Click:connect(function()
	if CurrentPlugin ~= PropBarrier then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = PropBarrier
		plugin:Activate(true)
		CurrentPlugin.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

PropPreviewButton.Click:connect(function()
	if CurrentPlugin ~= PropPreview then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = PropPreview
		plugin:Activate(true)
		CurrentPlugin.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

CombatMapButton.Click:connect(function()
	if CurrentPlugin ~= CombatMap then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = CombatMap
		plugin:Activate(true)
		CurrentPlugin.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

ZoneMarkerButton.Click:connect(function()
	if CurrentPlugin ~= ZoneMarker then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = ZoneMarker
		plugin:Activate(true)
		CurrentPlugin.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

SectionVisibilityButton.Click:Connect(function()
	plugin:Deactivate()
	SectionVisibility.OpenMenu(plugin)
	plugin:Deactivate()
end)

local function disablePlugin()
	MeadowMap.Clean()
	DoorAccess.Clean()
	PropBarrier.Clean()
	PropPreview.Clean()
	CombatMap.Clean()
	ZoneMarker.Clean()
	VisibilityToggle.HideTempRevealedParts(workspace:FindFirstChild("DebugMission"))
	CurrentPlugin = nil
end

plugin.Unloading:connect(disablePlugin)
plugin.Deactivation:connect(disablePlugin)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX9B8DB55963C24D8E9BB252C7B4F7398A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SectionVisibility</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2E9E86FDE97B4155BB87111C5E3DCFCD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{86DB723B-5BD4-4BC6-9A08-AB857562413F}</string>
					<ProtectedString name="Source"><![CDATA[local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)
local sections = { "Barrier", "Cells", "Nodes", "LoudSpawns", "CombatFlowMap" }

local cache = {}

return {
	OpenMenu = function(plugin)
		local menu = cache.Menu or plugin:CreatePluginMenu("SectionVisibilityMenu")
		cache.Menu = menu
		menu:Clear()

		for _, section in sections do
			local instance = workspace:FindFirstChild("DebugMission") and workspace.DebugMission:FindFirstChild(section)
			if not instance then
				continue
			end
			local hidden = VisibilityToggle.IsHidden(instance)
			local action = if hidden then "Show" else "Hide"
			local id = `SectionVisibility_{section}_{action}`
			local option = cache[id]
			if not option then
				option = plugin:CreatePluginAction(id, `{action} {section}`, "")
				option.Triggered:Connect(function()
					if hidden then
						VisibilityToggle.Reveal(workspace.DebugMission:FindFirstChild(section))
					else
						VisibilityToggle.Hide(workspace.DebugMission:FindFirstChild(section))
					end
				end)
				cache[id] = option
			end
			menu:AddAction(option)
		end

		if not cache.ShowAll then
			local ShowAll = plugin:CreatePluginAction("SectionVisibility_ShowAll", "Show All", "")
			ShowAll.Triggered:Connect(function()
				if not workspace:FindFirstChild("DebugMission") then
					return
				end
				for _, section in sections do
					local part = workspace.DebugMission:FindFirstChild(section)
					if part then
						VisibilityToggle.Reveal(part)
					end
				end
			end)
			local HideAll = plugin:CreatePluginAction("SectionVisibility_HideAll", "Hide All", "")
			HideAll.Triggered:Connect(function()
				if not workspace:FindFirstChild("DebugMission") then
					return
				end
				for _, section in sections do
					local part = workspace.DebugMission:FindFirstChild(section)
					if part then
						VisibilityToggle.Hide(part)
					end
				end
			end)

			cache.ShowAll = ShowAll
			cache.HideAll = HideAll
		end

		menu:AddAction(cache.ShowAll)
		menu:AddAction(cache.HideAll)
		menu:ShowAsync()
	end,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>