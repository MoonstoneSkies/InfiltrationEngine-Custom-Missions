<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXA98F8EF6913E42A0BBE32F47CCEAC145">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">SerializationTools</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX675F6947354F42A3AE747CAF2B4AEF55">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">API</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXF24348B4C0C44B28A5EF98E606071E9B">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
					<string name="ScriptGuid">{436C3DEC-24EE-44AB-8E46-1E008FCE27FA}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">APIConsumer</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6833E570A92C4B17B1989BC06AD7BC26">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local httpService = game:GetService("HttpService")

local attributesMap = require(script.Parent.Parent.AttributesMap)

local internalAPI = {}
internalAPI.APIExtensions = {}

internalAPI.Hooks = {}
internalAPI.Hooks.APIExtensionLoaded = {}
internalAPI.Hooks.APIExtensionUnloaded = {}
internalAPI.Hooks.PreSerialize = {}
internalAPI.Hooks.SerializerUnloaded = {}
internalAPI.Hooks.PreSerializeMissionSetup = {}

internalAPI.HookTypes = {}

internalAPI.ProtectedStateKeys = {
	Present = true,
	Done = false
}

local function varargs(...)
	local n = select('#', ...)
	local t = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

local function tblCount(t)
	local i = 0
	for k, v in pairs(t) do
		i = i + 1
	end
	return i
end

local function APIDevPrint(msg)
	if not workspace:GetAttribute("APIDev") then return end
	print(`SerializerAPI :\t{msg}`)
end

internalAPI.DeepClone = function(tbl)
	local cloned = {}
	for k, v in pairs(tbl) do
		if type(v) == "table" then
			cloned[k] = internalAPI.DeepClone(v)
		else
			cloned[k] = v
		end
	end
	return cloned
end

internalAPI.DeepFreeze = function(tbl)
	for _, v in pairs(tbl) do
		if type(v) == "table" then
			table.freeze(v)
		end
	end
	return table.freeze(tbl)
end

internalAPI.AddTokenData = function(tbl, data)
	local id = httpService:GenerateGUID(false)
	tbl[id] = data
	return id
end

internalAPI.RemoveTokenData = function(tbl, token, hookName)
	if tbl[token] == nil then
		warn(`Attempt made to remove {hookName} using invalid GUID!`)
		return
	end
	tbl[token] = nil
end

internalAPI.SafeIndex = function(tbl, ...)
	local indexing = tbl
	for i, key in varargs(...) do
		if type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(key)]
	end
	
	if type(indexing) == "table" then
		return true, internalAPI.DeepFreeze(internalAPI.DeepClone(indexing))
	end
	
	return true, indexing
end

internalAPI.CreateInvokationState = function(invoking)
	local underlyingState = {}
	local publicInterface = {}
	
	for _, hook in pairs(invoking) do
		underlyingState[`{hook.Registrant}_Present`] = true
		underlyingState[hook.Registrant] = internalAPI.DeepClone(internalAPI.ProtectedStateKeys)
	end
	
	publicInterface.Get = function(...)
		return internalAPI.SafeIndex(underlyingState, ...)
	end
	
	return table.freeze(publicInterface), underlyingState
end

internalAPI.AddHook = function(hookType: string, registrant, callback, state) : string
	local hookTbl = internalAPI.Hooks[hookType]
	for _, hook in pairs(hookTbl) do
		if hook.Registrant == registrant then
			warn(`{hookType}Hook Naming Collision! Name \"{registrant}\" already in-use!`)
			return
		end
	end
	APIDevPrint(`Adding {hookType}Hook \t{registrant}`)
	return internalAPI.AddTokenData(
		hookTbl, 
		{ 
			Registrant = registrant,
			Callback = callback,
			CallbackState = state
		}
	)
end

internalAPI.RemoveHook = function(hookType: string, token: string)
	local hookName = `{hookType}Hook`
	local hookTbl = internalAPI.Hooks[hookType]
	local removing = hookTbl[token] or {}
	APIDevPrint(`Removing {hookName} \t{removing.Registrant}`)
	internalAPI.RemoveTokenData(hookTbl, token, hookName)
end

internalAPI.InvokeHook = function(hookType, ...)
	APIDevPrint(`Running Hooks Of Type \t{hookType}`)
	
	local hooksToRun = internalAPI.Hooks[hookType]
	local unfinishedHooks = hooksToRun
	local invokeIterations = 1
	
	local invokeStatePublic, invokeState = internalAPI.CreateInvokationState(hooksToRun)
	
	local hookCoroutines = {}
	for _, hook in pairs(hooksToRun) do
		hookCoroutines[hook.Callback] = coroutine.create(hook.Callback)
	end
	
	while tblCount(unfinishedHooks) > 0 and invokeIterations <= 2000 do
		hooksToRun = unfinishedHooks
		unfinishedHooks = {}
		
		for _, hook in pairs(hooksToRun) do
			local hookCoroutine = hookCoroutines[hook.Callback]
			local success, stateVals = coroutine.resume(hookCoroutine, hook.CallbackState, invokeStatePublic, ...)
			
			if success and type(stateVals) == "table" then
				-- Set state values
				for k, v in pairs(stateVals) do
					if internalAPI.ProtectedStateKeys[k] ~= nil then
						warn(`Attempt by {hook.Registrant} to set protected InvokeState value {hook.Registrant}.{k}`)
						continue
					end
					invokeState[hook.Registrant][k] = v
				end
			end
			
			if success and coroutine.status(hookCoroutine) == "suspended" then
				unfinishedHooks[#unfinishedHooks+1] = hook
			elseif success and coroutine.status(hookCoroutine) == "dead" then
				invokeState[hook.Registrant].Done = true
			elseif not success then
				warn(`Error encountered when running {hookType}Hook {hook.Registrant} - {stateVals}`)
			end
		end
		
		invokeIterations = invokeIterations + 1
	end

	if invokeIterations > 2000 then
		warn(`Hook {hookType} ran for 2,000 stages and did not finish, unfinished hooks are as follows:`)
		for _, hook in ipairs(unfinishedHooks) do
			warn(`\t{hook.Registrant}`)
		end
	end
	
end

function internalAPI.GetHookTypes()
	return internalAPI.HookTypes
end

internalAPI.AddAPIExtension = function(name, author, contents)
	for _, apiExtension in pairs(internalAPI.APIExtensions) do
		if apiExtension.Name.Name == name then
			warn(`APIExtension naming collision! Name \"{name}\" already in use!`)
			return
		end
	end

	local id = internalAPI.AddTokenData(
		internalAPI.APIExtensions,
		{
			Name = name,
			Author = author,
			Contents = contents
		}
	)

	internalAPI.InvokeHook("APIExtensionLoaded", name, author, contents)
	return id
end

internalAPI.GetAPIExtension = function(name, author)
	for _, extension in internalAPI.APIExtensions do
		if extension.Name == name and extension.Author == author then return extension.Contents end
	end
end

internalAPI.RemoveAPIExtension = function(guid)
	local removing = internalAPI.APIExtensions[guid]
	if removing then
		internalAPI.InvokeHook("APIExtensionUnloaded", removing.Name, removing.Author, removing.Contents)
	end

	internalAPI.RemoveTokenData(internalAPI.APIExtensions, guid, "APIExtension")

end

for k, _ in pairs(internalAPI.Hooks) do
	internalAPI.HookTypes[#internalAPI.HookTypes+1] = k
end
table.freeze(internalAPI.HookTypes)

return internalAPI]]></ProtectedString>
					<string name="ScriptGuid">{BA4D33AD-91D2-470B-8BD9-A67F63714EA1}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Internal</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9E504177386546B78797939E15DBB439">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local coreGui = game:GetService("CoreGui")

local SERIALIZER_INDICATOR_NAME = "InfilEngine_SerializerAPIAvailable"

local serializerAPI = {}

serializerAPI.Public = require(script.Parent.Public)
serializerAPI.Internal = require(script.Parent.Internal)

serializerAPI.Events = {}
serializerAPI.PresenceIndicator = nil

function serializerAPI.PresenceIndicatorDestroying()
	serializerAPI.CreatePresenceIndicator(tostring(serializerAPI.Public), true)
end

function serializerAPI.PresenceIndicatorChanged()
	-- Resetting the indicator back would create an infinite loop
	-- Instead, force the indicator to be re-created
	serializerAPI.PresenceIndicator:Destroy()
end

function serializerAPI.CoreGuiChildAdded(child)
	if child.Name == SERIALIZER_INDICATOR_NAME then
		if child == serializerAPI.PresenceIndicator then return end
		warn("Attempted tampering of Serializer API presence indication detected - consider vetting plugins for undesirable behaviour")
		child:Destroy()
	end
end

function serializerAPI.CreatePresenceIndicator(tableId, shouldWarn)
	if shouldWarn == nil then shouldWarn = true end

	if shouldWarn then warn("Tampering of Serializer API presence indicator detected - consider vetting plugins for undesirable behaviour") end

	local presenceIndicator = Instance.new("StringValue")
	presenceIndicator.Archivable = false
	presenceIndicator.Name = SERIALIZER_INDICATOR_NAME
	presenceIndicator.Value = tableId
	presenceIndicator.Parent = coreGui

	serializerAPI.CleanIndicatorEvents()
	serializerAPI.Events[1] = presenceIndicator.Destroying:Connect(serializerAPI.PresenceIndicatorDestroying)
	serializerAPI.Events[2] = presenceIndicator.Changed:Connect(serializerAPI.PresenceIndicatorChanged)
	serializerAPI.Events[3] = presenceIndicator.AncestryChanged:Connect(serializerAPI.PresenceIndicatorChanged)
	serializerAPI.Events[4] = presenceIndicator:GetPropertyChangedSignal("Archivable"):Connect(serializerAPI.PresenceIndicatorChanged)
	serializerAPI.PresenceIndicator = presenceIndicator
end

function serializerAPI.AntiTamperInit()
	for _, child in coreGui:GetChildren() do
		if child.Name ~= SERIALIZER_INDICATOR_NAME then continue end
		serializerAPI.CoreGuiChildAdded(child)
	end
	serializerAPI.AntiCoreGuiTamper = coreGui.ChildAdded:Connect(serializerAPI.CoreGuiChildAdded)
end

function serializerAPI.Init()
	serializerAPI.AntiTamperInit()
	shared.InfilEngine_SerializerAPI = serializerAPI.Public
	serializerAPI.CreatePresenceIndicator(tostring(serializerAPI.Public), false)
end

function serializerAPI.Clean()
	serializerAPI.CleanIndicatorEvents()
	serializerAPI.AntiCoreGuiTamper:Disconnect()
	serializerAPI.PresenceIndicator:Destroy()
	serializerAPI.PresenceIndicator = nil
	serializerAPI.Internal.InvokeHook("SerializerUnloaded")
end

function serializerAPI.CleanIndicatorEvents()
	for i, e in ipairs(serializerAPI.Events) do
		e:Disconnect()
		e = nil
	end
end

return serializerAPI
]]></ProtectedString>
					<string name="ScriptGuid">{54D01B35-E071-4370-AD3C-8123E1831953}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXDBB8AC0F950F4C558C150D6CAB0048CE">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local httpService = game:GetService("HttpService")

local attributesMap = require(script.Parent.Parent.AttributesMap)
local attributeTypes = require(script.Parent.Parent.PropAttributeTypes)
local versionCfg = require(script.Parent.Parent.Util.VersionConfig)

local internalAPI = require(script.Parent.Internal)

local function ValidateArgTypes(fname, ...)
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)

		local argTypesStr = argSettings[3]
		argTypesStr = string.gsub(argTypesStr, '?', "|nil")
		local validTypesList = string.split(argTypesStr, '|')

		local isExpected = false
		for _, expectedType in ipairs(validTypesList) do
			if argType == expectedType then isExpected = true break end
		end

		if not isExpected then
			warn(`Invalid argument {argName} passed to API function {fname} - expected type {argTypesStr} but got {argType}!`)
			return false
		end
	end
	return true
end

type APIExtension = { [string] : (...any) -> ...any }

local publicAPI = {}

--[[
	[Returns]
		1 - Returns an integer describing the current revision of the serializer plugin API
]]
function publicAPI.GetAPIVersion() : number
	return versionCfg.VersionNumber_API
end

--[[
	[Returns]
		1 - Integer describing the current version of the serializer's code format
]]
function publicAPI.GetCodeVersion() : number
	return versionCfg.VersionNumber
end

--[[
	[Returns]
		1 - Frozen copy of internal attributes map
]]
local frozenAttributesMap = internalAPI.DeepFreeze(internalAPI.DeepClone(attributesMap))
function publicAPI.GetAttributesMap() : { [string] : { any } }
	return frozenAttributesMap
end

--[[
	[Returns]
		1 - Frozen copy of internal attribute types
]]
local frozenAttributeTypes = internalAPI.DeepFreeze(internalAPI.DeepClone(attributeTypes))
function publicAPI.GetAttributeTypes() : { [string] : number }
	return frozenAttributeTypes
end

--[[
	[Returns]
		1 - Frozen copy of valid hook types table
]]
function publicAPI.GetHookTypes() : { string }
	return internalAPI.GetHookTypes()
end

--[[
	[Args]
		 Title // Description                                        // Example    //
		------ // -------------------------------------------------- // ---------- //
		author // Name/alias for the author(s) of the calling plugin // "Sprix"    //
		plugin // Name/codename for the calling plugin               // "MyPlugin" //
	[Returns]
		1 - Helper function which constructs registrant names
]]
function publicAPI.GetRegistrantFactory(author: string, plugin: string) : (string) -> string
	local prefix = author .. '_' .. plugin
	return function(hookName) return prefix .. '_' .. hookName end
end

--[[
	[Args]
		     Title // Description                                                                                // Example        //
		---------- // ------------------------------------------------------------------------------------------ // -------------- //
		  hookType // String corresponding to the hookType you're attempting to validate                         // "PreSerialize" //
		warnCaller // String corresponding to the name of the caller - if provided, an automated warn is emitted // "MyFunction"   //
	[Returns]
		1 - Boolean indicating whether or not the provided HookType is valid
]]
function publicAPI.IsHookTypeValid(hookType: string, warnCaller: string?) : boolean
	if not ValidateArgTypes(
		"IsHookTypeValid", 
		{"hookType",   hookType,   "string" },
		{"warnCaller", warnCaller, "string?"}
		) then return false end
	local isValid = table.find(publicAPI.GetHookTypes(), hookType) ~= nil
	if not isValid and warnCaller ~= nil then
		warn(`Invalid HookType {hookType} passed to function {warnCaller}!`)
	end
	return isValid
end

--[[
	[Args]
		     Title // Description                                                                       // Example                                   //
		---------- // --------------------------------------------------------------------------------- // ----------------------------------------- //
		  hookType // String corresponding to the type of hook being removed                            // "PreSerialize"                            //
		registrant // String representing the source of the hook. Should be unique                      // "MyPlugin"                                //
		      hook // Function to be invoked when the corresponding hookType is invoked                 // function() print("Hook!") end             //
		 hookState // (Optional) Extra state to be passed as the last argument to the hook when invoked // { PartCol = Color3.fromHex("#FFFFFF") }   //
	[Returns]
		1 - Token which may be later used to securely de-register the hook
	[Notes]
		1) All valid hookTypes may be retrieved by calling GetHookTypes
		2) Execution order can be specified dynamically by calling coroutine.yield() within the hook
		   	An Example:
		   	function MyHook(callbackState, invokeState)
		   		local first = true
		   		repeat
		   			if not first then coroutine.yield() end
		   			local present = invokeState.Get("Author_HookName_Present")
		   			local success, dependencyDone = invokeState.Get("Author_Plugin_HookName", "Done")
		   			first = false
		   		until (not present) or (success and dependencyDone)
		   		-- Do work here, our dependency has finished
		   	end
		3) Yielding inside of a hook may also be used to set custom invokeState values
			An Example:
			function MyHook(callbackState, invokeState)
				local myPart = Instance.new("Part")
				
				-- Will add Part to this hooks' table in the invokeState
				coroutine.yield({ Part = myPart })
				
				-- Can retrieve the part like this
				local success, part = invokeState.Get("Author_Plugin_HookName", "Part")
			end
]]
function publicAPI.AddHook(hookType: string, registrant: string, hook: (...any) -> nil, hookState: { any }?) : string
	if not ValidateArgTypes(
		"AddHook", 
		{"hookType", hookType, "string"},
		{"registrant", registrant, "string"},
		{"hook", hook, "function"},
		{"hookState", hookState, "table?"}
		) then return end
	hookState = hookState or {}
	if not publicAPI.IsHookTypeValid(hookType, "AddHook") then return end
	local token = internalAPI.AddHook(hookType, registrant, hook, hookState) 
	return `{hookType}_{token}`
end

--[[
	[Args]
		   Title // Description                                            // Example        //
		-------- // ------------------------------------------------------ // -------------- // 
		   token // Value returned from corresponding call to AddHook      // n/a            //
]]
function publicAPI.RemoveHook(token: string)
	if not ValidateArgTypes(
		"RemoveHook",
		{"token", token, "string"}
		) then return end
	local splitToken = string.split(token, "_")
	if #splitToken ~= 2 then warn("Token provided to RemoveHook is invalid!") return end
	
	local hookType = splitToken[1]
	local realToken = splitToken[2]
	
	if not publicAPI.IsHookTypeValid(hookType, "RemoveHook") then return end
	
	internalAPI.RemoveHook(hookType, realToken)
end

--[[
	[Args] 
		   Title // Description                                       // Example                                                //
	    -------- // ------------------------------------------------- // ------------------------------------------------------ //
		    name // Name of the API extension                         // "MyPluginAPI"                                          //
		  author // Name/alias for the author(s) of the API extension // "Sprix"                                                //
		contents // Table of functions exposed via the API extension  // { HelloWorld = function() print("Hello, World!") end } //
	[Returns]
		1 - Token which may be used to securely de-register the APIExtension
	[Notes]
		1) Contents table is recursively frozen - plan accordingly!
		2) Name & Author pair *MUST* be unique
		3) Will invoke all APIExtensionLoadedCallbacks before returning
]]
function publicAPI.AddAPIExtension(name: string, author: string, contents: APIExtension) : string
	if not ValidateArgTypes("AddAPIExtension", {"name", name, "string"}, {"author", author, "string"}, {"contents", contents, "table"}) then return end
	return internalAPI.AddAPIExtension(name, author, internalAPI.DeepFreeze(contents))
end

--[[
	[Args]
		 Title // Description                                       // Example       //
		------ // ------------------------------------------------- // ------------- //
		  name // Name of the API extension                         // "MyPluginAPI" //
		author // Name/alias for the author(s) of the API extension // "Sprix"       //
	[Returns]
		1 - Table exposed via the API extension, nil if it doesn't exist or has yet to be registered
	[Notes]
		1) See AddAPIExtensionLoadedCallback if you need to run code whenever specific extension(s) are loaded 
]]
function publicAPI.GetAPIExtension(name: string, author: string) : APIExtension?
	if not ValidateArgTypes("GetAPIExtension", {"name", name, "string"}, {"author", author, "string"}) then return end
	return internalAPI.GetAPIExtension(name, author)
end

--[[
	[Args]
		Title // Description                                               //
		----- // --------------------------------------------------------- //
		token // Value returned from corresponding call to AddAPIExtension // 
]]
function publicAPI.RemoveAPIExtension(token: string)
	if not ValidateArgTypes("RemoveAPIExtension", {"token", token, "string"}) then return end
	return internalAPI.RemoveAPIExtension(token)
end

return table.freeze(publicAPI)]]></ProtectedString>
					<string name="ScriptGuid">{86981B60-78BC-43F2-9E01-DCEFBBA27E29}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Public</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX8057AB9204814C329F5B848D894EB33E">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local AttributesMap = require(script.Parent.AttributesMap)
local PropAttributeTypes = require(script.Parent.PropAttributeTypes)

local GlobalPropAttributes = {
	GlobalVariables = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	OnProp = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	ScriptMove = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	Index = { PropAttributeTypes.OPTIONAL_INT, nil },
	CanShatter = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	Tag = { PropAttributeTypes.STRING, nil },
	TagOffset = { PropAttributeTypes.VECTOR3, nil },
	StaticTag = { PropAttributeTypes.STRING, nil },
	HasTopBarrier = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	Indestructible = { PropAttributeTypes.EXPRESSION, nil },
	NoPropDamage = { PropAttributeTypes.EXPRESSION, nil },
	IsSpawned = { PropAttributeTypes.EXPRESSION, nil },
	Color0 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color1 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color2 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color3 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color4 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color5 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Material0 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material1 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material2 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material3 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material4 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material5 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Type = { PropAttributeTypes.STRING, nil },
	AltProp = { PropAttributeTypes.STRING, nil },
	AltPropModel = { PropAttributeTypes.STRING, nil },
	FadeOutCondition = { PropAttributeTypes.STRING, nil },
	CollisionGroup = { PropAttributeTypes.STRING, nil },
	TagButton = { PropAttributeTypes.EXPRESSION, nil },
	MultiGlass = { PropAttributeTypes.BOOL, nil },
}

local testAttributeCompatibility = function(attributeType, value, objectName, attributeName)
	if attributeType == "NUMBER" then
		if type(value) == "number" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must contain a number type.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "INT" then
		if type(value) == "number" then
			if value == math.round(value) then
				return true
			else
				warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be an integer.")
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type (integer)."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "EXPRESSION" then
		if type(value) == "boolean" or type(value) == "string" or type(value) == "number" then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a boolean, string, or number type."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "STATE_VALUE" then
		if type(value) == "string" then
			if string.find(value, "%s") == nil then
				return true
			else
				warn("The " .. objectName .. " object's " .. attributeName .. " attribute must not contain whitespace.")
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a string type with no whitespace."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "STRING" then
		if type(value) == "string" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must contain a string type.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "NETWORK_ID" then
		if type(value) == "string" then
			local int = tonumber(value)
			if not int or int ~= math.round(int) or int < 1 or int > 999 then
				warn(
					"The "
						.. objectName
						.. " object's "
						.. attributeName
						.. " attribute must contain a number type between 1 and 999."
				)
			end
		elseif type(value) == "number" then
			if value == math.round(value) and value >= 1 and value <= 999 then
				return true
			else
				warn(
					"The "
						.. objectName
						.. " object's "
						.. attributeName
						.. " attribute must contain a number type between 1 and 999."
				)
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type between 1 and 999."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "NETWORK_ID_STRING" then
		if value == "" then
			return true
		end
		local num = tonumber(value)
		if num == math.round(num) and num >= 1 and num <= 999 then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. ' attribute must contain a string type of a number between 1 and 999 or be blank "".'
			)
			warn("Found value: " .. tostring(value))
		end
		return false
	elseif attributeType == "OPTIONAL_BOOL" then
		if value == nil or type(value) == "boolean" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be a boolean or nil.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "OPTIONAL_MISSION_COLOR" then
		if value == nil or typeof(value) == "Color3" or type(value) == "string" then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must be a nil, Color3, or a string."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "OPTIONAL_MATERIAL" then
		if value == nil or type(value) == "string" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be a nil or a string.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "VECTOR3" then
		if typeof(value) == "Vector3" then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type (integer)."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "OPTIONAL_INT" then
		if value == nil then
			return true
		elseif type(value) == "number" then
			if value == math.round(value) then
				return true
			else
				warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be nil or an integer.")
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type (integer)."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "BOOL" then
		if type(value) == "boolean" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be a boolean")
			warn("Found type: " .. type(value))
		end
		return false
	else
		error(`Attribute type does not exist: {tostring(attributeType)}`)
	end
end

return {
	Validate = function(className, instanceName, attributes, includeDefaults)
		if className == "Folder" then
			return attributes
		end

		if attributes.IKnowWhatImDoingDoNotValidate == true then
			warn(`Instance {instanceName} of Class {className} is intentionally opting out of attribute validation`)
			return attributes
		elseif attributes.Type == "StateScript" or instanceName == "StateScriptPart" then
			return attributes
		end

		local name = className == "BoolValue" and attributes.Type or instanceName
		if not AttributesMap[name] then
			return attributes -- If not included in the prop list, just return the normal attributes list
		elseif attributes.AltProp or attributes.AltPropModel then
			return attributes -- Skip validation for AltProp/AltPropModel
		else
			local newAttributes = {}
			local attributeTypes = AttributesMap[name]
			for attName, tableOfInfo in pairs(attributeTypes) do -- add attributes specifically listed in AttributesMap.lua
				if not attributes[attName] then
					if includeDefaults then
						newAttributes[attName] = tableOfInfo[2]
					end
					continue
				end
				local givenValue = attributes[attName]
				local attributeTypeName = ""
				for i, v in pairs(PropAttributeTypes) do
					if tableOfInfo[1] == v then
						attributeTypeName = i
					end
				end
				if attributeTypeName == "" then
					error(`attribute type does not exist: {name} {attName}`)
				end
				if not testAttributeCompatibility(attributeTypeName, givenValue, name, attName) then
					if includeDefaults then
						newAttributes[attName] = attributeTypes[attName][2]
					else
						continue
					end
				end
				-- If the value isn't default or is and the includeDefaults value is set to true, then add it to the list
				if (tableOfInfo[2] == givenValue and includeDefaults) or tableOfInfo[2] ~= givenValue then
					newAttributes[attName] = givenValue
				end
			end
			for attribute, value in pairs(attributes) do -- add the remaining attributes that are defined in the global attributes table above
				if GlobalPropAttributes[attribute] then
					local tableOfInfo = GlobalPropAttributes[attribute]
					local attributeTypeName = ""
					for i, v in pairs(PropAttributeTypes) do
						if tableOfInfo[1] == v then
							attributeTypeName = i
						end
					end
					if testAttributeCompatibility(attributeTypeName, value, name, attribute) then
						newAttributes[attribute] = value
					else
						newAttributes[attribute] = nil -- set to nil if it doesn't fit properly
					end
				elseif not attributeTypes[attribute] then
					warn("Unknown attribute will be discarded:", attribute, name)
				end
			end

			return newAttributes
		end
	end,
}
]]></ProtectedString>
				<string name="ScriptGuid">{FBB434A6-523A-4AC5-BC02-182BD4F434E2}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeValidation</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX31A4BF5F142043CEB84CCE2F2AD0F1B4">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- NOTE: Do not edit this file manually. Use PropCompiler.py.
AttributeType = require(script.Parent.PropAttributeTypes)
return {
	AccessPoint = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	AmmoBox = {
	},
	BadgeReader = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CustomBadges = {AttributeType.STRING, ""},
		UseITBadge = {AttributeType.BOOL, false},
		UseLeadSecurityBadge = {AttributeType.BOOL, false},
		UseSecurityBadge = {AttributeType.BOOL, false},
	},
	BarredWindow = {
		GlassMaterial = {AttributeType.STRING, "SmoothPlastic"},
		GlassTransparency = {AttributeType.NUMBER, 0.8},
		HorizontalSpacing = {AttributeType.NUMBER, 2},
		VerticalSpacing = {AttributeType.NUMBER, 2},
	},
	BoxStack2 = {
	},
	CandlePlate = {
	},
	CardboardBox = {
	},
	CardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		LightLevel = {AttributeType.INT, 1},
		Blocked = {AttributeType.EXPRESSION, ""},
		LockdownReason = {AttributeType.EXPRESSION, nil},
	},
	CeilingAccessPoint = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	CircuitBoxLarge = {
		ClientExaminedVariable = {AttributeType.STATE_VALUE, ""},
		ExaminedVariable = {AttributeType.STATE_VALUE, ""},
		RewiredVariable = {AttributeType.STATE_VALUE, ""},
	},
	ClientExplosionEffect = {
		Active = {AttributeType.EXPRESSION, ""},
		Intensity = {AttributeType.NUMBER, 1},
	},
	ClimbablePipe = {
	},
	ClothingRack = {
		Active = {AttributeType.EXPRESSION, ""},
		Disguise = {AttributeType.STRING, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		ClientUsedVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, 0},
	},
	CodeCardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		CodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		WrongCodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeSeed = {AttributeType.INT, 1},
		PromptText = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		ReaderEnabled = {AttributeType.EXPRESSION, "1"},
		AltPromptActive = {AttributeType.EXPRESSION, ""},
		AltPromptSwitchTime = {AttributeType.NUMBER, 1},
	},
	CodeKeypad = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		PromptText = {AttributeType.STRING, ""},
		WrongCodeVariable = {AttributeType.STATE_VALUE, ""},
		ReadoutText = {AttributeType.EXPRESSION, ""},
		RewireTime = {AttributeType.NUMBER, 12},
		PromptSubtitle = {AttributeType.STRING, ""},
		KeypadEnabled = {AttributeType.EXPRESSION, "1"},
		NoiseEnabled = {AttributeType.EXPRESSION, ""},
		CodeVariable = {AttributeType.STATE_VALUE, ""},
		RewiredVariable = {AttributeType.STATE_VALUE, ""},
		CodeSeed = {AttributeType.INT, 1},
		InteractionAlertLevel = {AttributeType.EXPRESSION, ""},
	},
	CombatCuttableFence = {
	},
	CustomMissionLoadPoint = {
	},
	DecorativeDepositBox1 = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativeDepositBox2 = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativeDepositBox3 = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativeDepositBoxHalf = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativePipe = {
		RingSpace = {AttributeType.NUMBER, 8},
		Corner = {AttributeType.BOOL, false},
		BendTop = {AttributeType.BOOL, false},
	},
	DecorativeVent = {
		BendBottom = {AttributeType.INT, 0},
		BendTop = {AttributeType.INT, 0},
		RingSpace = {AttributeType.NUMBER, 8},
		RingDepth = {AttributeType.NUMBER, 0},
	},
	DepositBox1 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DepositBox2 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DepositBox3 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DeskPhoneCallable = {
		CallAcceptedVariable = {AttributeType.STATE_VALUE, ""},
		CallIgnoredVariable = {AttributeType.STATE_VALUE, ""},
		IsCalling = {AttributeType.EXPRESSION, ""},
		CallTime = {AttributeType.INT, 15},
	},
	DeskSafe = {
		ItemTagString = {AttributeType.STRING, ""},
		Item = {AttributeType.STRING, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
	},
	DisguiseTrigger = {
		Active = {AttributeType.EXPRESSION, ""},
		Disguise = {AttributeType.STRING, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		ClientUsedVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, 0},
	},
	DomeCamera = {
		AngleMax = {AttributeType.STRING, "0"},
		AngleMin = {AttributeType.STRING, "0"},
		Exterior = {AttributeType.BOOL, true},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		NetworkDestination = {AttributeType.NETWORK_ID_STRING, ""},
		CamSet = {AttributeType.STRING, ""},
		CameraArea = {AttributeType.STRING, ""},
		AngleDown = {AttributeType.NUMBER, 0},
		Wireless = {AttributeType.BOOL, true},
		CamNumber = {AttributeType.INT, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		LocationKey = {AttributeType.STRING, ""},
		MapFloorOffset = {AttributeType.INT, 0},
		WarpPoint = {AttributeType.STRING, nil},
	},
	DoorArmored = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorArmoredElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorCombatSpawn = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, ""},
	},
	DoorGlass = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorGlassFramed = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorGlassRustic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorMetal = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		EasyKick = {AttributeType.BOOL, nil},
		Jammed = {AttributeType.BOOL, nil},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorMetalElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorPushLeft = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorWood = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoorWoodElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDelayed = {AttributeType.BOOL, nil},
		OpenWhileAlarmedVariable = {AttributeType.STATE_VALUE, nil},
	},
	DoubleVaultDoor = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	Elevator = {
	},
	ElevatorCallButton = {
		CallVariable = {AttributeType.STATE_VALUE, ""},
		DisabledInCombat = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
	},
	ElevatorCardReader = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DisabledInCombat = {AttributeType.BOOL, false},
	},
	EventGift = {
	},
	EventPumpkin = {
		CounterVariable = {AttributeType.STATE_VALUE, ""},
	},
	FallingLadder = {
		LiftScale = {AttributeType.NUMBER, 0.8},
		CanShoot = {AttributeType.BOOL, false},
		LoweredVariable = {AttributeType.STATE_VALUE, ""},
	},
	Flare = {
		PlacedVariable = {AttributeType.STATE_VALUE, FlarePlaced},
	},
	FloorAccessCover = {
		CanOpen = {AttributeType.EXPRESSION, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
	},
	Flowerpot = {
		Seed = {AttributeType.INT, 0},
	},
	FlyingHelicopter = {
	},
	FreestandingSafe = {
		Seed = {AttributeType.INT, 1},
		CanInteract = {AttributeType.EXPRESSION, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
	},
	GarageDoor = {
		Height = {AttributeType.EXPRESSION, "0"},
	},
	GlassKitchenTable = {
	},
	HackableComputer = {
		MonitorOffset = {AttributeType.VECTOR3, Vector3.new(0, 0, 0)},
		MonitorAngle = {AttributeType.NUMBER, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 0},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, 0},
		OldMonitor = {AttributeType.BOOL, false},
		PhysicalAccessBlocked = {AttributeType.EXPRESSION, 0},
	},
	HeavySecurityDoor = {
		ServerExplosiveFullDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveNoDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosivePartialDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveFullDamageVariable = {AttributeType.STATE_VALUE, ""},
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	Helicopter = {
		ActiveCondition = {AttributeType.EXPRESSION, ""},
		StopAttemptDialogue = {AttributeType.STRING, ""},
		StartupTime = {AttributeType.EXPRESSION, 60},
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		PoliceShutdownVariable = {AttributeType.STATE_VALUE, ""},
		QuadBlade = {AttributeType.BOOL, false},
	},
	HiddenWallSafe = {
		PromptVisible = {AttributeType.EXPRESSION, ""},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		Seed = {AttributeType.INT, 1},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.INT, 0},
		ItemRotationY = {AttributeType.INT, 0},
		ItemRotationZ = {AttributeType.INT, 0},
		Image = {AttributeType.INT, 0},
		SafeLocatedVariable = {AttributeType.STATE_VALUE, ""},
		CoverColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		OffsetX = {AttributeType.NUMBER, 0},
		KeyItem = {AttributeType.BOOL, false},
		CoverMaterial = {AttributeType.STRING, ""},
		SafeTag = {AttributeType.STRING, ""},
		HiddenShuffleId = {AttributeType.STRING, ""},
		Reinforced = {AttributeType.EXPRESSION, ""},
		ReinforcedColor0 = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(1, 1, 1)},
		ReinforcedColor1 = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(1, 1, 1)},
	},
	HighSecurityCardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		LightLevel = {AttributeType.INT, 1},
		Blocked = {AttributeType.EXPRESSION, ""},
		LockdownReason = {AttributeType.EXPRESSION, nil},
		CanRewire = {AttributeType.BOOL, false},
	},
	IndustrialShelvesSmall = {
		BoxSeed = {AttributeType.INT, 0},
		BoxDensity = {AttributeType.NUMBER, 0},
		BoxColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
	},
	InteractionBlocker = {
		ServerActive = {AttributeType.EXPRESSION, "1"},
		ClientActive = {AttributeType.EXPRESSION, nil},
	},
	IntroCam = {
	},
	Ladder = {
		Decorative = {AttributeType.BOOL, false},
	},
	LandscapePhotoHorizontalRectangle = {
		Image = {AttributeType.INT, 0},
	},
	LandscapePhotoSquare = {
		Image = {AttributeType.INT, 0},
	},
	LandscapePhotoVerticalThird = {
		Image = {AttributeType.INT, 0},
		OffsetX = {AttributeType.NUMBER, 0},
	},
	Laptop = {
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, 0},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
	},
	LaptopOld = {
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, 0},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
	},
	LaundryBasket = {
		Active = {AttributeType.EXPRESSION, ""},
		Disguise = {AttributeType.STRING, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		ClientUsedVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, 0},
	},
	LeverageMove = {
		MoveDist = {AttributeType.EXPRESSION, 0},
		Prop = {AttributeType.STRING, ""},
		MovedToEndVariable = {AttributeType.STATE_VALUE, ""},
		MovedFromStartVariable = {AttributeType.STATE_VALUE, ""},
		VisibleCondition = {AttributeType.EXPRESSION, "1"},
		Heavy = {AttributeType.BOOL, true},
	},
	LongCoffeeTable = {
		Seed = {AttributeType.INT, 0},
	},
	LootCash = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LootCash2 = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LootThermite = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
	},
	LootWeapons = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LowVent = {
		Blocked = {AttributeType.EXPRESSION, ""},
	},
	MetalDetector = {
		PowerLevel = {AttributeType.EXPRESSION, ""},
	},
	MinimapBlock = {
	},
	Monitor = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
	},
	NetworkSwitch = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	NoDropZone = {
		BlockPickups = {AttributeType.BOOL, false},
	},
	OldMonitor = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
	},
	OneWayTrespass = {
		Condition = {AttributeType.EXPRESSION, ""},
		EnforceClass = {AttributeType.STRING, ""},
		MajorTrespass = {AttributeType.BOOL, false},
		SetMetaTagsOnWarp = {AttributeType.STRING, nil},
		ConfrontationDialogue = {AttributeType.STRING, nil},
	},
	PortableMetalDetector = {
		PowerLevel = {AttributeType.EXPRESSION, ""},
	},
	PowerBoxLarge = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		InvestigatorTag = {AttributeType.STRING, nil},
	},
	PowerBoxPortable = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		Locked = {AttributeType.BOOL, false},
		ObjectName = {AttributeType.STRING, ""},
		PowerAreaParent = {AttributeType.STATE_VALUE, ""},
		ManualInvestigationBot = {AttributeType.EXPRESSION, ""},
		InvestigatorTag = {AttributeType.STRING, nil},
	},
	PowerBoxSmall = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		Locked = {AttributeType.BOOL, false},
		ObjectName = {AttributeType.STRING, ""},
		PowerAreaParent = {AttributeType.STATE_VALUE, ""},
		ManualInvestigationBot = {AttributeType.EXPRESSION, ""},
		InvestigatorTag = {AttributeType.STRING, nil},
	},
	PropBase = {
	},
	RadioStation = {
		SocialEngineeringLevel = {AttributeType.INT, 1},
		DistractionDisabled = {AttributeType.EXPRESSION, ""},
		DistractionActive = {AttributeType.EXPRESSION, ""},
		DistractionVariable = {AttributeType.STATE_VALUE, ""},
		DistractionDialogue = {AttributeType.STRING, ""},
		DistractionSubtitle = {AttributeType.STRING, ""},
		DistractionSuspicious = {AttributeType.EXPRESSION, ""},
		Enabled = {AttributeType.EXPRESSION, "1"},
	},
	ScalablePlanter = {
		PlantHeight = {AttributeType.NUMBER, 3},
		PlantWidth = {AttributeType.NUMBER, 0},
	},
	ScalableWallPlanter = {
		PlantWidth = {AttributeType.NUMBER, 1},
		PlantHeight = {AttributeType.NUMBER, 2},
	},
	SearchableFilingCabinets = {
		FilesSpawned = {AttributeType.EXPRESSION, ""},
		KeyItem = {AttributeType.BOOL, false},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemTagString = {AttributeType.STRING, ""},
	},
	SecurityCamera = {
		AngleMax = {AttributeType.STRING, "0"},
		AngleMin = {AttributeType.STRING, "0"},
		Exterior = {AttributeType.BOOL, true},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		NetworkDestination = {AttributeType.NETWORK_ID_STRING, ""},
		CamSet = {AttributeType.STRING, ""},
		CameraArea = {AttributeType.STRING, ""},
		AngleDown = {AttributeType.NUMBER, 0},
		Wireless = {AttributeType.BOOL, true},
		CamNumber = {AttributeType.INT, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		LocationKey = {AttributeType.STRING, ""},
		MapFloorOffset = {AttributeType.INT, 0},
		CycleTime = {AttributeType.NUMBER, 0},
		WarpPoint = {AttributeType.STRING, nil},
	},
	ServerRack = {
		CanPickup = {AttributeType.BOOL, false},
		ItemTagString = {AttributeType.STRING, ""},
		PickupVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STRING, ""},
	},
	ServerRackWideTerminal = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Disconnected = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
		UseOldMonitor = {AttributeType.OPTIONAL_BOOL, false},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
		SecurityKeyNeeded = {AttributeType.EXPRESSION, ""},
		SecurityKeyInsertedVariable = {AttributeType.STATE_VALUE, ""},
	},
	StaticAmmoBox = {
	},
	SurfaceText = {
		TextKey = {AttributeType.STRING, ""},
		Font = {AttributeType.STRING, ""},
		HorizontalAlignment = {AttributeType.INT, 2},
		TextColor3 = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(1, 1, 1)},
	},
	TableGlass = {
	},
	TableGlassLarge = {
	},
	TableGlassTall = {
	},
	ThermiteBurn = {
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		StartedVariable = {AttributeType.STATE_VALUE, ""},
		BurnTime = {AttributeType.EXPRESSION, 90},
	},
	ThinBush = {
	},
	TimelockCodePanel = {
		GlobalCountdownState = {AttributeType.STATE_VALUE, ""},
		CompletedVariable = {AttributeType.STATE_VALUE, ""},
		TimelockEnabled = {AttributeType.EXPRESSION, ""},
		SetState = {AttributeType.STATE_VALUE, ""},
		CountTime = {AttributeType.NUMBER, 60},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		SetValue = {AttributeType.EXPRESSION, ""},
	},
	TrespassZoneDisplay = {
		Enabled = {AttributeType.BOOL, true},
	},
	TriggerLocalChat = {
		Id = {AttributeType.STRING, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		StealthOnly = {AttributeType.BOOL, false},
	},
	TriggerVision = {
		Hold = {AttributeType.NUMBER, 0},
		Dist = {AttributeType.NUMBER, 40},
		ZoneSize = {AttributeType.NUMBER, 0.8},
		Active = {AttributeType.EXPRESSION, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerZone = {
		IsGlobal = {AttributeType.BOOL, false},
		IsLocal = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
		HighlightZone = {AttributeType.BOOL, false},
		UpdateFrequency = {AttributeType.NUMBER, 1},
		ClearOnInactive = {AttributeType.BOOL, false},
		Disguise = {AttributeType.STRING, nil},
		SetMetaTags = {AttributeType.STRING, nil},
		PlayersOutsideZoneVariable = {AttributeType.STATE_VALUE, ""},
	},
	TutorialText = {
		HorizontalOffset = {AttributeType.NUMBER, 0.5},
		VerticalOffset = {AttributeType.NUMBER, 0.5},
		Text = {AttributeType.STRING, ""},
		Visible = {AttributeType.EXPRESSION, 1},
	},
	Van = {
		IsOpen = {AttributeType.EXPRESSION, ""},
		DoorAngleR = {AttributeType.EXPRESSION, 0},
		DoorAngleL = {AttributeType.EXPRESSION, 0},
	},
	VaultOpenRight = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	WallMountedCoreDrill = {
		TriggerTag = {AttributeType.STRING, ""},
		AssembleVariable = {AttributeType.STATE_VALUE, ""},
		FinishedVariable = {AttributeType.STATE_VALUE, ""},
		RemovedVariable = {AttributeType.STATE_VALUE, ""},
		MovePrompt = {AttributeType.BOOL, false},
		PreAssembled = {AttributeType.BOOL, false},
		DrillTime = {AttributeType.EXPRESSION, 60},
	},
	WallSafe = {
		Seed = {AttributeType.INT, 1},
		CanInteract = {AttributeType.EXPRESSION, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
	},
	Window = {
		Bulletproof = {AttributeType.EXPRESSION, false},
		StateValue = {AttributeType.STATE_VALUE, nil},
		StateVariable = {AttributeType.STATE_VALUE, ""},
		GlassColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		NoFrame = {AttributeType.BOOL, false},
		SlideOpen = {AttributeType.EXPRESSION, ""},
		SlideDist = {AttributeType.NUMBER, 0},
	},
	WindowClimb = {
		Blocked = {AttributeType.EXPRESSION, ""},
		Vertical = {AttributeType.BOOL, false},
		BlockSide1 = {AttributeType.EXPRESSION, ""},
		BlockSide2 = {AttributeType.EXPRESSION, ""},
	},
	WoodChair = {
	},
	WoodShootingTarget = {
		TargetDownVariable = {AttributeType.STATE_VALUE, ""},
	},
	WoodTargetWithSensor = {
	},
	LandscapePhotoIds = {
	},
	AccessRequestNode = {
		ServerCondition = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		ToolRequired = {AttributeType.STRING, ""},
		AccessVariable = {AttributeType.STATE_VALUE, ""},
		TriggeredVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		BotServerTag = {AttributeType.STRING, ""},
		AccessOnceVariable = {AttributeType.STATE_VALUE, ""},
		AccessTime = {AttributeType.NUMBER, 1},
	},
	AlarmButton = {
	},
	ArmoredTruck = {
	},
	BagSpawn = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
		BagColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		BagType = {AttributeType.STRING, "Backpack"},
		ModelHidden = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0.5},
		ItemRemovedVariable = {AttributeType.STRING, ""},
		Contents = {AttributeType.STRING, ""},
		SearchedVariable = {AttributeType.STATE_VALUE, ""},
		FlatTrigger = {AttributeType.BOOL, nil},
		NoPickup = {AttributeType.BOOL, nil},
		ItemName = {AttributeType.STRING, ""},
		OverrideInternalSpace = {AttributeType.INT, 0},
		ContainerNameOverride = {AttributeType.STRING, nil},
	},
	BasicPart = {
		Material = {AttributeType.STRING, "SmoothPlastic"},
		ColorHex = {AttributeType.STRING, "FFFFFF"},
	},
	BiometricLock = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
		RewireEnabled = {AttributeType.EXPRESSION, ""},
	},
	BotConversationPoint = {
		BotTag0 = {AttributeType.STRING, ""},
		BotTag1 = {AttributeType.STRING, ""},
		TriggerRange = {AttributeType.INT, 40},
		CanStartConversation = {AttributeType.EXPRESSION, ""},
		AngleOffset = {AttributeType.NUMBER, 0},
		LeaveDelay0 = {AttributeType.NUMBER, 0},
		LeaveDelay1 = {AttributeType.NUMBER, 0},
		SlowPace = {AttributeType.BOOL, false},
		CrossArms = {AttributeType.BOOL, false},
		OverhearRange = {AttributeType.INT, 25},
		Dialogue0 = {AttributeType.STRING, nil},
		Dialogue0Speaker = {AttributeType.INT, nil},
		Dialogue0Time = {AttributeType.NUMBER, nil},
		Dialogue0Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue1 = {AttributeType.STRING, nil},
		Dialogue1Speaker = {AttributeType.INT, nil},
		Dialogue1Time = {AttributeType.NUMBER, nil},
		Dialogue1Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue2 = {AttributeType.STRING, nil},
		Dialogue2Speaker = {AttributeType.INT, nil},
		Dialogue2Time = {AttributeType.NUMBER, nil},
		Dialogue2Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue3 = {AttributeType.STRING, nil},
		Dialogue3Speaker = {AttributeType.INT, nil},
		Dialogue3Time = {AttributeType.NUMBER, nil},
		Dialogue3Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue4 = {AttributeType.STRING, nil},
		Dialogue4Speaker = {AttributeType.INT, nil},
		Dialogue4Time = {AttributeType.NUMBER, nil},
		Dialogue4Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue5 = {AttributeType.STRING, nil},
		Dialogue5Speaker = {AttributeType.INT, nil},
		Dialogue5Time = {AttributeType.NUMBER, nil},
		Dialogue5Variable = {AttributeType.STATE_VALUE, nil},
	},
	Cabinet = {
		BodyHiddenVariable = {AttributeType.STATE_VALUE, ""},
	},
	ConditionalHighJumpRequired = {
		Climber3Condition = {AttributeType.EXPRESSION, 1},
		Color = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		Material = {AttributeType.STRING, "Plastic"},
	},
	ControlPanel = {
		UsedVariable = {AttributeType.STATE_VALUE, ""},
	},
	CustomReportPoint = {
		Hidden = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		CameraOnly = {AttributeType.BOOL, false},
		AutoAlertBotTag = {AttributeType.STRING, ""},
		Visibility = {AttributeType.NUMBER, 1},
		RaiseAlert = {AttributeType.INT, 1},
		MinAlert = {AttributeType.INT, 1},
		MaxAlert = {AttributeType.INT, 3},
		NotificationMessage = {AttributeType.STRING, ""},
		ReportDialogue = {AttributeType.STRING, ""},
	},
	DebugSpawnLocation = {
		Active = {AttributeType.BOOL, false},
	},
	DynamicNode = {
		Id = {AttributeType.STRING, ""},
		TakedownImmunity = {AttributeType.BOOL, false},
		Anim = {AttributeType.STRING, nil},
		CaptureBot = {AttributeType.EXPRESSION, nil},
		ApproachPace = {AttributeType.INT, nil},
		CustomBehavior = {AttributeType.STRING, nil},
	},
	ElevatorFunctional = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
		PlayerInElevatorVariable = {AttributeType.STATE_VALUE, ""},
		BotInElevator = {AttributeType.STATE_VALUE, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		LinkedElevator = {AttributeType.STRING, ""},
		NoUsing = {AttributeType.BOOL, false},
		NoDropBlocking = {AttributeType.BOOL, false},
		WarpTargetId = {AttributeType.STRING, ""},
		WarpPointId = {AttributeType.STRING, ""},
	},
	EscapeZone = {
		Active = {AttributeType.EXPRESSION, ""},
	},
	FlowStart = {
	},
	FreeTrigger = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		DisabledSubtitle = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 0.5},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		SaveProgress = {AttributeType.BOOL, false},
		Tool = {AttributeType.STRING, ""},
		LinkToProp = {AttributeType.BOOL, false},
		HiddenShuffleId = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetValue = {AttributeType.EXPRESSION, ""},
		SetClientVariable = {AttributeType.STATE_VALUE, ""},
		TagWhileVisible = {AttributeType.BOOL, false},
		Debug = {AttributeType.BOOL, false},
		IncrementClientVariable = {AttributeType.STATE_VALUE, ""},
		IncrementVariable = {AttributeType.STATE_VALUE, ""},
		OmniDir = {AttributeType.BOOL, false},
		TapTrigger = {AttributeType.BOOL, false},
	},
	GuardCombatNode = {
		BotTag = {AttributeType.STRING, nil},
	},
	init = {
	},
	IntercomCode = {
		SocialEngineeringDialogue = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		HostageUse = {AttributeType.STATE_VALUE, ""},
		PickupNode = {AttributeType.STRING, ""},
		PickupVariable = {AttributeType.STATE_VALUE, ""},
		CallCondition = {AttributeType.EXPRESSION, ""},
		CallConditionPrompt = {AttributeType.STRING, ""},
		OpenedWithBluffVariable = {AttributeType.STATE_VALUE, ""},
		OpenedWithHostageVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.NUMBER, 0},
		Responder = {AttributeType.STRING, ""},
	},
	IntercomPanel = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Subtitle = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
	},
	InvestigationStandTrigger = {
		ActiveCondition = {AttributeType.EXPRESSION, ""},
		HighPriority = {AttributeType.BOOL, false},
		BotServerTag = {AttributeType.STRING, ""},
		ArrivalVariableDelay = {AttributeType.NUMBER, 0},
		ArrivalVariable = {AttributeType.STATE_VALUE, ""},
		InvestigatingVariable = {AttributeType.STATE_VALUE, ""},
		Anim = {AttributeType.STRING, ""},
		Timeout = {AttributeType.NUMBER, 0},
		CallDialogue = {AttributeType.STRING, ""},
	},
	InvestigationTrigger = {
	},
	ItemDeposit = {
		SubtitleKey = {AttributeType.STRING, ""},
		DepositedVariable = {AttributeType.STATE_VALUE, ""},
		ItemTagForDeposit = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		TitleKey = {AttributeType.STRING, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ClientEnabled = {AttributeType.EXPRESSION, ""},
		MissingToolSubtitle = {AttributeType.STRING, ""},
		MissingToolTitle = {AttributeType.STRING, ""},
		Item = {AttributeType.STRING, ""},
		SetMetaTags = {AttributeType.STRING, nil},
	},
	ItemSpawn = {
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		ModelHidden = {AttributeType.BOOL, false},
		FlatTrigger = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0},
		PickupCondition = {AttributeType.EXPRESSION, ""},
		KeyItem = {AttributeType.BOOL, false},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		IsSpawned = {AttributeType.EXPRESSION, ""},
		HasAmmo = {AttributeType.BOOL, false},
	},
	KillZone = {
		BotServerTag = {AttributeType.STRING, ""},
		KillerInZone = {AttributeType.BOOL, false},
		TargetInZone = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		KillCountVariable = {AttributeType.STATE_VALUE, ""},
	},
	LeaningCover = {
		AllowSpawning = {AttributeType.EXPRESSION, false},
		Enabled = {AttributeType.EXPRESSION, true},
		SpawnsIgnoreProximity = {AttributeType.BOOL, false},
		UseFromAdjacentRoom = {AttributeType.BOOL, false},
		HoldDoor = {AttributeType.BOOL, false},
		ReverseDoor = {AttributeType.BOOL, false},
		CoverTag = {AttributeType.STRING, ""},
		HoldPriority = {AttributeType.EXPRESSION, 0},
		LeanRight = {AttributeType.BOOL, false},
		OnlyAssignFromSpawner = {AttributeType.BOOL, false},
	},
	LeaveMissionPoint = {
	},
	LootCountZone = {
	},
	LootGeneric = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
		BagColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		BagType = {AttributeType.STRING, "Backpack"},
		ModelHidden = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0.5},
		ItemRemovedVariable = {AttributeType.STRING, ""},
		Contents = {AttributeType.STRING, ""},
	},
	MissionEndZone = {
		PlayersExitedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRequired = {AttributeType.STRING, ""},
		ItemSecuredVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		OpenForAll = {AttributeType.EXPRESSION, ""},
		HighlightZone = {AttributeType.BOOL, true},
		AltItem0 = {AttributeType.STRING, nil},
		AltItem1 = {AttributeType.STRING, nil},
		AltItem2 = {AttributeType.STRING, nil},
		AltItem0Variable = {AttributeType.STATE_VALUE, nil},
		AltItem1Variable = {AttributeType.STATE_VALUE, nil},
		AltItem2Variable = {AttributeType.STATE_VALUE, nil},
	},
	MissionExit = {
	},
	PathfindingBlocker = {
		BotCollisions = {AttributeType.BOOL, nil},
	},
	PlaceholderProp = {
	},
	PointOfInterest = {
		Icon = {AttributeType.STRING, ""},
		IconScale = {AttributeType.NUMBER, 1},
	},
	PowerRoomProp1 = {
		PowerArea = {AttributeType.STRING, ""},
		DetectSabotage = {AttributeType.BOOL, true},
		DamagedVariable = {AttributeType.STATE_VALUE, ""},
		Health = {AttributeType.INT, 0},
	},
	PowerRoomProp2 = {
		PowerArea = {AttributeType.STRING, ""},
		DetectSabotage = {AttributeType.BOOL, true},
		DamagedVariable = {AttributeType.STATE_VALUE, ""},
		Health = {AttributeType.INT, 0},
	},
	RandomBotSpawnLocation = {
		StartingSpawnOnly = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, true},
	},
	RewireablePanel = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		RewireEnabled = {AttributeType.EXPRESSION, "1"},
		ObjectName = {AttributeType.STRING, ""},
		DifficultRewire = {AttributeType.BOOL, false},
	},
	SawCutPoint = {
		UsedVariable = {AttributeType.STATE_VALUE, ""},
	},
	ScriptedExplosion = {
		BlastRadius = {AttributeType.NUMBER, 20},
		Active = {AttributeType.EXPRESSION, ""},
	},
	SearchableClipboard = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetClientVariable = {AttributeType.STATE_VALUE, ""},
	},
	SearchableFile = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
	},
	SearchablePaperTray = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
	},
	ShuffleTarget = {
		ShuffleTag = {AttributeType.STRING, ""},
		MatchVariable = {AttributeType.STATE_VALUE, ""},
		MatchValue = {AttributeType.EXPRESSION, nil},
		ResolvePriority = {AttributeType.INT, nil},
	},
	SoundSource = {
		SoundId = {AttributeType.EXPRESSION, "0"},
		Volume = {AttributeType.NUMBER, 0.5},
		Looped = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		SoundLength = {AttributeType.NUMBER, 0},
		RollOffMaxDistance = {AttributeType.NUMBER, 10000},
		RollOffMinDistance = {AttributeType.NUMBER, 10},
	},
	SpawnLocation = {
	},
	StandingCover = {
		AllowSpawning = {AttributeType.EXPRESSION, false},
		Enabled = {AttributeType.EXPRESSION, true},
		SpawnsIgnoreProximity = {AttributeType.BOOL, false},
		UseFromAdjacentRoom = {AttributeType.BOOL, false},
		HoldDoor = {AttributeType.BOOL, false},
		ReverseDoor = {AttributeType.BOOL, false},
		CoverTag = {AttributeType.STRING, ""},
		HoldPriority = {AttributeType.EXPRESSION, 0},
		OnlyAssignFromSpawner = {AttributeType.BOOL, false},
	},
	StateScriptPart = {
	},
	SwitchPanel = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		TitleKey = {AttributeType.STRING, ""},
	},
	ToolTrigger = {
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		DefaultSubtitle = {AttributeType.STRING, ""},
		DefaultTitle = {AttributeType.STRING, ""},
		DisabledSubtitle = {AttributeType.STRING, ""},
		DisabledTitle = {AttributeType.STRING, ""},
		DrillEnabled = {AttributeType.BOOL, false},
		DrillStand = {AttributeType.BOOL, false},
		DrillSubtitle = {AttributeType.STRING, ""},
		DrillTitle = {AttributeType.STRING, ""},
		DrillTime = {AttributeType.NUMBER, 10},
		DrillXOffset = {AttributeType.NUMBER, 0},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		IncrementClientVariable = {AttributeType.STATE_VALUE, ""},
		SawEnabled = {AttributeType.BOOL, false},
		SawTitle = {AttributeType.STRING, ""},
		SawSubtitle = {AttributeType.STRING, ""},
		SawTime = {AttributeType.NUMBER, 8},
		SawXOffset = {AttributeType.NUMBER, 0},
		ScrewdriverEnabled = {AttributeType.BOOL, false},
		ScrewdriverSubtitle = {AttributeType.STRING, ""},
		ScrewdriverTitle = {AttributeType.STRING, ""},
		ScrewdriverXOffset = {AttributeType.NUMBER, 0},
		SetClientVariable = {AttributeType.STATE_VALUE, ""},
		SetValue = {AttributeType.EXPRESSION, 1},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		IncrementVariable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerHit = {
	},
	TriggerRoom = {
		Active = {AttributeType.EXPRESSION, ""},
		PlayersInRoomVariable = {AttributeType.STATE_VALUE, ""},
		ClientInRoomVariable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerRoomBot = {
		BotServerTag = {AttributeType.STRING, ""},
		ActiveCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerThreshhold = {
		PlayersBeforeThreshholdVariable = {AttributeType.STATE_VALUE, ""},
		PlayersAfterThreshholdVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerZoneBot = {
		RagdollCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		DeathCountVariable = {AttributeType.STATE_VALUE, ""},
		WalkingCountVariable = {AttributeType.STATE_VALUE, ""},
		ConciousCountVariable = {AttributeType.STATE_VALUE, ""},
		CountVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	VisionBlocker = {
	},
	WarpPoint = {
		WarpPointId = {AttributeType.STRING, ""},
		WarpTargetId = {AttributeType.STRING, ""},
		WarpOnHit = {AttributeType.EXPRESSION, ""},
		WarpKeepsOffset = {AttributeType.BOOL, true},
		WarpOnIncrement = {AttributeType.EXPRESSION, ""},
		WarpHostages = {AttributeType.BOOL, true},
	},
	AlarmedBehaviorOverride = {
		BotServerTag = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
	},
	AlertRaiseCondition = {
		Amount = {AttributeType.INT, 1},
		MinValue = {AttributeType.INT, 1},
		MaxValue = {AttributeType.INT, 3},
		Reason = {AttributeType.STRING, ""},
		Condition = {AttributeType.EXPRESSION, ""},
	},
	BodyAltTrigger = {
		BotServerTag = {AttributeType.STRING, ""},
		HoldTime = {AttributeType.NUMBER, 1},
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		TriggerNotification = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		BotClientTag = {AttributeType.STRING, ""},
		ClientVisible = {AttributeType.EXPRESSION, "1"},
		ServerEnabled = {AttributeType.EXPRESSION, "1"},
	},
	BotAltTrigger = {
		BotClientTag = {AttributeType.STRING, ""},
		BotServerTag = {AttributeType.STRING, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		AllowHostages = {AttributeType.BOOL, false},
		TriggerNotification = {AttributeType.STRING, ""},
		TriggerLocalNotification = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		TriggerClientVariable = {AttributeType.STATE_VALUE, ""},
		TitleKey = {AttributeType.STRING, ""},
		AllowPatroling = {AttributeType.BOOL, false},
		ClientVisible = {AttributeType.EXPRESSION, "1"},
		HoldTime = {AttributeType.NUMBER, 1},
		SubtitleKey = {AttributeType.STRING, ""},
	},
	BotItemSpawn = {
		Condition = {AttributeType.EXPRESSION, ""},
		Item = {AttributeType.STRING, ""},
		ItemTag = {AttributeType.STRING, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	BotStateTracker = {
		IncapacitationCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		DeathCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientKillCountVariable = {AttributeType.STATE_VALUE, ""},
		FleeCountVariable = {AttributeType.STATE_VALUE, ""},
		TotalCountVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	CombatSpawner = {
		ReinforcementPool = {AttributeType.STRING, ""},
		TimeBetweenSpawns = {AttributeType.EXPRESSION, ""},
		EnemyWeapons = {AttributeType.STRING, "S97|S97|480 MCS|F57|K45Shield"},
		SpawnTags = {AttributeType.STRING, ""},
		FlowMap = {AttributeType.STRING, ""},
		SpawnSquads = {AttributeType.BOOL, false},
		EnemyType = {AttributeType.STRING, "Swat"},
		AllowDespawn = {AttributeType.BOOL, false},
		SpawnsBlockedVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		SpawnCap = {AttributeType.EXPRESSION, 6},
		CustomCombatData = {AttributeType.STRING, ""},
		EnemyWeaponsWave1 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave2 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave3 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave4 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave5 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave6 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave7 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave8 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave9 = {AttributeType.EXPRESSION, nil},
		CurrentWave = {AttributeType.EXPRESSION, nil},
		-- Custom outfit stuff to combat spawns :3
		CustomShirtId = {AttributeType.NUMBER, nil},
		CustomPantsId = {AttributeType.NUMBER, nil},
		CustomHairStyle = {AttributeType.STRING, nil},
		CustomHairColor = {AttributeType.OPTIONAL_MISSION_COLOR, ""},
		CustomAccessories = {AttributeType.STRING, nil},
		CustomBeardStyle = {AttributeType.STRING, nil},
		CustomBeardStyle = {AttributeType.STRING, nil},
		CustomSkinTone = {AttributeType.OPTIONAL_MISSION_COLOR, ""},
	},
	CombatWaveSpawner = {
	},
	ConditionalStateUpdate = {
		Watch = {AttributeType.EXPRESSION, ""},
		Condition = {AttributeType.EXPRESSION, ""},
		InactiveVariable = {AttributeType.STATE_VALUE, ""},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
	},
	ConversationGenericSocialEngineering = {
		BotServerTag = {AttributeType.STRING, ""},
		Visible = {AttributeType.EXPRESSION, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, 0},
		IntimidationLevel = {AttributeType.INT, 0},
		Icon = {AttributeType.STRING, "ChatGeneric"},
		Text = {AttributeType.STRING, ""},
		Dialogue = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		ClientNotification = {AttributeType.STRING, ""},
		Notification = {AttributeType.STRING, ""},
		NotificationDelay = {AttributeType.NUMBER, 2.5},
		Disguise = {AttributeType.STRING, ""},
	},
	ConversationResponseCustomBehavior = {
		BotServerTag = {AttributeType.STATE_VALUE, ""},
		DisableReason = {AttributeType.EXPRESSION, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		Dialogue = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
	},
	CoverFillSpawner = {
		CoverSearchLimit = {AttributeType.INT, 5},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
		SpawnsBlockedVariable = {AttributeType.STATE_VALUE, ""},
		FillFrequency = {AttributeType.NUMBER, 6},
		ReinforcementPool = {AttributeType.STRING, ""},
		CoverTags = {AttributeType.STRING, ""},
		SpawnTags = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, "Mission_AlarmRaised"},
		SpawnCap = {AttributeType.EXPRESSION, "8"},
		EnemyType = {AttributeType.STRING, "Swat"},
		EnemyWeapons = {AttributeType.STRING, "F57|S97|480 MCS"},
		ServerTag = {AttributeType.STRING, nil},
		CustomCombatData = {AttributeType.STRING, ""},
		EnemyWeaponsWave1 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave2 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave3 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave4 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave5 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave6 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave7 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave8 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave9 = {AttributeType.EXPRESSION, nil},
		CurrentWave = {AttributeType.EXPRESSION, nil},
		-- Custom outfit stuff to combat spawns :3
		CustomShirtId = {AttributeType.NUMBER, nil},
		CustomPantsId = {AttributeType.NUMBER, nil},
		CustomHairStyle = {AttributeType.STRING, nil},
		CustomHairColor = {AttributeType.OPTIONAL_MISSION_COLOR, ""},
		CustomAccessories = {AttributeType.STRING, nil},
		CustomBeardStyle = {AttributeType.STRING, nil},
		CustomBeardStyle = {AttributeType.STRING, nil},
		CustomSkinTone = {AttributeType.OPTIONAL_MISSION_COLOR, ""},
	},
	CustomBehaviorCondition = {
		Priority = {AttributeType.STRING, "Custom1"},
		BotServerTag = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
		LoopApply = {AttributeType.BOOL, false},
		Condition = {AttributeType.EXPRESSION, false},
	},
	CustomConversation = {
	},
	CustomHack = {
		DeployCost = {AttributeType.INT, 20},
		DeployTime = {AttributeType.INT, 10},
		NodeId = {AttributeType.NETWORK_ID, 1},
		NameKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		DescriptionKey = {AttributeType.STRING, ""},
		BlockDeallocation = {AttributeType.BOOL, false},
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		PauseCondition = {AttributeType.EXPRESSION, ""},
		Priority = {AttributeType.INT, 0},
		Difficulty = {AttributeType.EXPRESSION, ""},
		Suspicion = {AttributeType.INT, 1},
		PrimaryHack = {AttributeType.BOOL, false},
		Visible = {AttributeType.EXPRESSION, "1"},
		DeployedVariable = {AttributeType.STATE_VALUE, ""},
		DeployedOnceVariable = {AttributeType.STATE_VALUE, ""},
		ScriptedBehavior = {AttributeType.STRING, ""},
		DisableReason = {AttributeType.EXPRESSION, ""},
		IconId = {AttributeType.EXPRESSION, 0},
		IsDeployedVariable = {AttributeType.STATE_VALUE, ""},
	},
	DelayedStateUpdate = {
		Watch = {AttributeType.EXPRESSION, ""},
		DelayTime = {AttributeType.EXPRESSION, 5},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		OnlyMatch = {AttributeType.BOOL, false},
	},
	HackableDoor = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	HackableElevator = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	HackingNodeStatus = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		DisabledVariable = {AttributeType.STATE_VALUE, ""},
		CompromisedVariable = {AttributeType.STATE_VALUE, ""},
	},
	HiddenShuffle = {
		HiddenShuffleId = {AttributeType.STRING, ""},
		FrontCount = {AttributeType.INT, 0},
		BackCount = {AttributeType.INT, 0},
		RevealCount = {AttributeType.INT, 1},
		RevealCountVariable = {AttributeType.STATE_VALUE, ""},
		FailCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientFailCountVariable = {AttributeType.STATE_VALUE, ""},
		Seed = {AttributeType.INT, 1},
		RevealAllCondition = {AttributeType.EXPRESSION, ""},
	},
	ItemStateTracker = {
		GroundCountVariable = {AttributeType.STATE_VALUE, ""},
		TotalHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		BotHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		ItemTag = {AttributeType.STRING, ""},
	},
	ItemSwapCondition = {
		Condition = {AttributeType.EXPRESSION, ""},
		SwapItemType = {AttributeType.STRING, ""},
		SwapItemTag = {AttributeType.STRING, ""},
		TargetItemTag = {AttributeType.STRING, ""},
	},
	LerpOperation = {
		OutputVariable = {AttributeType.STATE_VALUE, ""},
		Value0 = {AttributeType.EXPRESSION, ""},
		Value1 = {AttributeType.EXPRESSION, ""},
		Delta = {AttributeType.EXPRESSION, 0.5},
		AlwaysUpdate = {AttributeType.EXPRESSION, false},
		UpdateClock = {AttributeType.EXPRESSION, "0"},
	},
	MissionCompletionTrigger = {
		Condition = {AttributeType.EXPRESSION, ""},
		Timeout = {AttributeType.NUMBER, 1},
		CompleteVariable = {AttributeType.STATE_VALUE, ""},
	},
	MissionFailedTrigger = {
		Condition = {AttributeType.EXPRESSION, ""},
		Timeout = {AttributeType.NUMBER, 1},
		FailedVariable = {AttributeType.STATE_VALUE, ""},
	},
	NetworkRouter = {
		NetworkId = {AttributeType.NETWORK_ID, 999},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	Notification = {
		Condition = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
	},
	RandomBotSpawner = {
		SpawningActive = {AttributeType.EXPRESSION, ""},
		SpawnTimeMin = {AttributeType.NUMBER, 4},
		SpawnTimeMax = {AttributeType.NUMBER, 10},
		Behavior = {AttributeType.STRING, ""},
		Class = {AttributeType.STRING, ""},
		CivilianHighlight = {AttributeType.BOOL, false},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		NodesBreak = {AttributeType.STRING, ""},
		EnforceClass = {AttributeType.STRING, ""},
		Profile = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
		Outfit = {AttributeType.STRING, ""},
		Nodes = {AttributeType.STRING, ""},
		HostageDifficulty = {AttributeType.NUMBER, 0},
		ObjectiveHighlight = {AttributeType.BOOL, false},
		Weapon = {AttributeType.STRING, ""},
	},
	ReinforcementPool = {
		PoolName = {AttributeType.STRING, ""},
		WaveResetTimeMinimum = {AttributeType.NUMBER, 0},
		WaveStateVariable = {AttributeType.STATE_VALUE, ""},
		WaveVariable = {AttributeType.STATE_VALUE, ""},
		PoolLimit = {AttributeType.EXPRESSION, ""},
		RemainingVariable = {AttributeType.STATE_VALUE, ""},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
		WaveResetTime = {AttributeType.EXPRESSION, ""},
		WaveResetTimeDecrease = {AttributeType.NUMBER, 0},
		WaveResetThreshold = {AttributeType.NUMBER, 1},
		WaveResetMaxTime = {AttributeType.EXPRESSION, ""},
	},
	ScriptedBotSpawn = {
		TemplateId = {AttributeType.STRING, ""},
		Condition = {AttributeType.EXPRESSION, ""},
	},
	ScriptedTakedown = {
		Trigger = {AttributeType.EXPRESSION, ""},
		BotServerTag = {AttributeType.STRING, ""},
		Lethal = {AttributeType.BOOL, false},
	},
	SearchPatternCondition = {
		Condition = {AttributeType.EXPRESSION, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	ServerChat = {
		Active = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		Delay = {AttributeType.NUMBER, 0},
		Chance = {AttributeType.NUMBER, 1},
		TriggerOnce = {AttributeType.BOOL, false},
	},
	SniperSpawner = {
		Active = {AttributeType.EXPRESSION, ""},
		Nodes = {AttributeType.STRING, ""},
		InitialSpawns = {AttributeType.EXPRESSION, 0},
		RespawnRate = {AttributeType.EXPRESSION, 20},
	},
	StateScript = {
	},
	TargetLureHack = {
	},
	TimerComponent = {
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetFormattedVariable = {AttributeType.STATE_VALUE, ""},
		StartValue = {AttributeType.EXPRESSION, 0},
		TargetValue = {AttributeType.EXPRESSION, 60},
		Increment = {AttributeType.EXPRESSION, 1},
		Offset = {AttributeType.EXPRESSION, ""},
		Enabled = {AttributeType.EXPRESSION, ""},
		Paused = {AttributeType.EXPRESSION, ""},
		Frequency = {AttributeType.EXPRESSION, ""},
	},
	TrackBotsDown = {
	},
	TrackItemHeldServer = {
	},
	TrackNodeReserved = {
	},
	AutoConversationTrigger = {
		BotClientTag = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	BlackoutScreen = {
		Active = {AttributeType.EXPRESSION, ""},
		Speed = {AttributeType.NUMBER, nil},
	},
	FileUITrigger = {
		Trigger = {AttributeType.EXPRESSION, ""},
		Lines = {AttributeType.STRING, ""},
	},
	GameCredits = {
	},
	HackingNodeHighlight = {
		HackDesc = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeTraversal = {AttributeType.BOOL, false},
		NodeId = {AttributeType.NETWORK_ID, 0},
		ObjectiveType = {AttributeType.INT, 1},
	},
	LocalChat = {
		DelayStart = {AttributeType.NUMBER, 0},
		Active = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		TriggerOnce = {AttributeType.BOOL, false},
		StealthOnly = {AttributeType.BOOL, false},
		CombatOnly = {AttributeType.BOOL, false},
	},
	LocalStateComponents = {
	},
	LocalWeaponTracker = {
		TotalAmmoVariable = {AttributeType.STATE_VALUE, ""},
		LoadedAmmoVariable = {AttributeType.STATE_VALUE, ""},
		HoldingWeaponVariable = {AttributeType.STATE_VALUE, ""},
	},
	LocationCard = {
		Subtitle = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	MusicController = {
		ActivePriority = {AttributeType.EXPRESSION, "1"},
		TrackId = {AttributeType.EXPRESSION, 0},
		NoLoop = {AttributeType.BOOL, false},
		Volume = {AttributeType.NUMBER, 0.5},
		MusicType = {AttributeType.STRING, Stealth},
		PersistOnReload = {AttributeType.BOOL, false},
	},
}
]]></ProtectedString>
				<string name="ScriptGuid">{488251C4-3F75-4F9F-8BE0-CD2C0BECA508}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributesMap</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXEB0E3C8731824581B99EEB34D8C2B714">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local toolbar = plugin:CreateToolbar("Mission Exporter")
local ExportButton = toolbar:CreateButton("Exporter", "Exporter", "rbxassetid://86828934223336")

local Api = require(script.Parent.API.Main)
local Exporter = require(script.Parent.Writing.Main)

local CurrentPlugin = nil

ExportButton.Click:Connect(function()
	if CurrentPlugin ~= Exporter then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = Exporter
		plugin:Activate(true)
		Exporter.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

local function disablePlugin()
	Exporter.Clean()
	CurrentPlugin = nil
end

local function unloadPlugin()
	Api.Clean()
	disablePlugin()
end

plugin.Unloading:Connect(unloadPlugin)
plugin.Deactivation:Connect(disablePlugin)

Api.Init()]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{BB34EE9F-E340-4348-9D55-365FD223FB41}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX918FBE44D8A54282B02D594316F8FFE9">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local PropAttributeTypes

PropAttributeTypes = {
	NUMBER = 1,
	INT = 2,
	EXPRESSION = 3,
	STATE_VALUE = 4,
	STRING = 5,
	NETWORK_ID = 6,
	NETWORK_ID_STRING = 7,
	OPTIONAL_BOOL = 8,
	OPTIONAL_MISSION_COLOR = 9,
	OPTIONAL_MATERIAL = 10,
	VECTOR3 = 11,
	OPTIONAL_INT = 12,
	BOOL = 13,
	CFRAME = 14,
}

return PropAttributeTypes
]]></ProtectedString>
				<string name="ScriptGuid">{51B30DEC-7E5D-44F6-9E49-05781E5B9F1D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PropAttributeTypes</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXBDC328A1A0424AE2B14C372121E1CDA3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Reading</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX42FDB86DF4EC494E974B8DFCE66212D0">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceTypes = require(script.Parent.Parent.Types.InstanceTypes)
local ReadInstance = require(script.Parent.ReadInstance)
local Materials = require(script.Parent.Parent.Types.Materials)
local PartTypes = require(script.Parent.Parent.Types.PartTypes)
local NormalId = require(script.Parent.Parent.Types.NormalId)
local MeshType = require(script.Parent.Parent.Types.MeshType)
local RenderFidelity = require(script.Parent.Parent.Types.RenderFidelity)
local CollisionFidelity = require(script.Parent.Parent.Types.CollisionFidelity)

local VersionConfig = require(script.Parent.Parent.Util.VersionConfig)

local SIGNED_INT_BOUND = StringConversion.GetMaxNumber(3) / 2
local INT_BOUND = StringConversion.GetMaxNumber(4)
local BOUNDED_FLOAT_BOUND = StringConversion.GetMaxNumber(3)
local SHORT_BOUNDED_FLOAT_BOUND = StringConversion.GetMaxNumber(2)

local Read

local denormalize = function(value)
	return value * (2 * math.pi) - math.pi
end

local InstanceKeys = {}
for i, v in pairs(InstanceTypes) do
	InstanceKeys[v] = i
end

local function CreateEnumReader(enum, map)
	local ids = {}
	for i, v in map do
		ids[v] = i
	end
	return function(str, cursor)
		local num = StringConversion.StringToNumber(str, cursor, 1)
		return enum[ids[num]], cursor + 1
	end
end

local function NewlineGSub(capture)
	if capture == "&n" then
		return "\n"
	elseif capture == "&r" then
		return "\r"
	elseif capture == "&t" then
		return utf8.char(9)
	end
	return "&"
end

Read = {
	Bool = function(str, cursor) -- returns the value read as a boolean. 1 symbol
		return string.sub(str, cursor, cursor) == "b", cursor + 1
	end,

	ShortInt = function(str, cursor) -- returns the value read as a short integer. 2 symbols
		return StringConversion.StringToNumber(str, cursor, 2), cursor + 2
	end,

	Int = function(str, cursor) -- returns the value read as an integer. 4 symbols
		return StringConversion.StringToNumber(str, cursor, 4), cursor + 4
	end,

	LongInt = function(str, cursor) -- returns the value read as an integer. 6 symbols
		return StringConversion.StringToNumber(str, cursor, 6), cursor + 6
	end,

	SignedInt = function(str, cursor) -- returns the value read as a signed integer. 3 symbols
		return StringConversion.StringToNumber(str, cursor, 3) - math.floor(SIGNED_INT_BOUND), cursor + 3
	end,

	Float = function(str, cursor) -- returns the value read as a float. 5 symbols
		local beforeDecimal, cursor = Read.SignedInt(str, cursor)
		local afterDecimal = StringConversion.StringToNumber(str, cursor, 2) / SHORT_BOUNDED_FLOAT_BOUND
		return afterDecimal + beforeDecimal, cursor + 2
	end,

	Vector3 = function(str, cursor) -- returns the value read as a Vector3. 24 symbols
		local X, cursor = Read.Float(str, cursor)
		local Y, cursor = Read.Float(str, cursor)
		local Z, cursor = Read.Float(str, cursor)
		return Vector3.new(X, Y, Z), cursor
	end,

	CFrame = function(str, cursor) -- returns the value read as a CFrame. 36 symbols
		local X, cursor = Read.Float(str, cursor)
		local Y, cursor = Read.Float(str, cursor)
		local Z, cursor = Read.Float(str, cursor)
		local rx, cursor = Read.BoundedFloat(str, cursor)
		rx = denormalize(rx)
		local ry, cursor = Read.BoundedFloat(str, cursor)
		ry = denormalize(ry)
		local rz, cursor = Read.BoundedFloat(str, cursor)
		rz = denormalize(rz)
		return CFrame.new(X, Y, Z) * CFrame.fromEulerAnglesXYZ(rx, ry, rz), cursor
	end,

	BoundedFloat = function(str, cursor) -- returns the value read as a bounded float between 0-1. 3 symbols.
		return StringConversion.StringToNumber(str, cursor, 3) / BOUNDED_FLOAT_BOUND, cursor + 3
	end,

	ShortBoundedFloat = function(str, cursor) -- returns the value read as a bounded float between 0-1. 4 symbols.
		return StringConversion.StringToNumber(str, cursor, 2) / SHORT_BOUNDED_FLOAT_BOUND, cursor + 2
	end,

	Color3 = function(str, cursor)
		local R, cursor = Read.ShortBoundedFloat(str, cursor)
		local G, cursor = Read.ShortBoundedFloat(str, cursor)
		local B, cursor = Read.ShortBoundedFloat(str, cursor)
		return Color3.new(R, G, B), cursor
	end,

	String = function(str, cursor)
		local length, cursor = Read.Int(str, cursor)
		local value = str:sub(cursor, cursor + length - 1)

		if VersionConfig.ReplaceNewlines then
			value = value:gsub("&.", NewlineGSub)
		end

		return value, cursor + length
	end,

	ColorMap = function(str, cursor)
		local colorMap = {}
		local colorMapLength
		colorMapLength, cursor = Read.ShortInt(str, cursor)
		for i = 1, colorMapLength do
			colorMap[i], cursor = Read.Color3(str, cursor)
		end
		return colorMap, cursor
	end,

	StringMap = function(str, cursor)
		local stringMap = {}
		local stringMapLength
		stringMapLength, cursor = Read.ShortInt(str, cursor)
		for i = 1, stringMapLength do
			stringMap[i], cursor = Read.String(str, cursor)
		end
		return stringMap, cursor
	end,

	Mission = function(str, cursor)
		if str:sub(1, 3) == "!!!" then
			local code = str:match("!!!.-!!!(.+)")
			if not code then
				error("Malformed opening comment")
			end
			str = code
		end

		local colorMap
		colorMap, cursor = Read.ColorMap(str, cursor)
		local stringMap
		stringMap, cursor = Read.StringMap(str, cursor)
		local mission = Read.Instance(str, cursor, colorMap, stringMap)

		-- Reading Color3s from TableMissionSetup
		local ImportedMissionSetup = game:GetService("HttpService")
			:JSONDecode(mission:FindFirstChild("TableMissionSetup").Value)

		for i, v in pairs(ImportedMissionSetup["Colors"]) do
			ImportedMissionSetup["Colors"][i] = Color3.new(v[1], v[2], v[3])
		end

		if game:GetService("RunService"):IsStudio() and not _G.Common then -- If the mission is read using the plugin, then create a MissionSetup ModuleScript
			local StringMissionSetup = mission:FindFirstChild("StringMissionSetup")
			local MissionSetup = Instance.new("ModuleScript")
			MissionSetup.Name = "MissionSetup"
			MissionSetup.Parent = mission
			MissionSetup.Source = StringMissionSetup.Value
		end

		return mission
	end,

	Instance = function(str, cursor, colorMap, stringMap)
		local InstanceId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		if InstanceId ~= InstanceTypes.Nil then
			local InstanceType = InstanceKeys[InstanceId]
			local object, cursor = ReadInstance[InstanceType](str, cursor, Read, colorMap, stringMap)
			while StringConversion.StringToNumber(str, cursor, 1) ~= 0 do
				local child
				child, cursor = Read.Instance(str, cursor, colorMap, stringMap)
				if child ~= nil then
					child.Parent = object
				end
			end
			return object, cursor + 1
		else
			return nil, cursor
		end
	end,

	Material = CreateEnumReader(Enum.Material, Materials),
	PartType = CreateEnumReader(Enum.PartType, PartTypes),
	NormalId = CreateEnumReader(Enum.NormalId, NormalId),
	MeshType = CreateEnumReader(Enum.MeshType, MeshType),
	RenderFidelity = CreateEnumReader(Enum.RenderFidelity, RenderFidelity),
	CollisionFidelity = CreateEnumReader(Enum.CollisionFidelity, CollisionFidelity),
}

return Read
]]></ProtectedString>
					<string name="ScriptGuid">{983FC902-3C5A-4ABC-86B9-9B3A6C3CA92F}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Read</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX11F8585AC4EE4BBFB0DBDEDAE2472603">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local InsertService = game:GetService("InsertService")

local ENABLE_ARBITRARY_MESHES = true

local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceProperties = require(script.Parent.Parent.Types.InstanceProperties)
local DefaultProperties = require(script.Parent.Parent.Types.DefaultProperties)
local AttributeTypes = require(script.Parent.Parent.Types.AttributeTypes)
local AttributeValidation = require(script.Parent.Parent.AttributeValidation)

local AttributeKeys = {}
for i, v in pairs(AttributeTypes) do
	AttributeKeys[v] = i
end

local WithAttributes = function(DefaultReader)
	return function(str, cursor, Read, colorMap, stringMap)
		local newInstance
		newInstance, cursor = DefaultReader(str, cursor, Read, colorMap, stringMap)
		local attributeId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		while not (attributeId == 0) do
			local typeName = AttributeKeys[attributeId]
			local nameMapIndex
			nameMapIndex, cursor = Read.ShortInt(str, cursor)
			local name = stringMap[nameMapIndex]
			local value
			if typeName == "Color3" then
				local colorMapIndex
				colorMapIndex, cursor = Read.ShortInt(str, cursor)
				value = colorMap[colorMapIndex]
			elseif typeName == "String" then
				local valueMapIndex
				valueMapIndex, cursor = Read.ShortInt(str, cursor)
				value = stringMap[valueMapIndex]
			else
				value, cursor = Read[typeName](str, cursor)
			end
			newInstance:SetAttribute(name, value)
			attributeId = StringConversion.StringToNumber(str, cursor, 1)
			cursor += 1
		end
		local attributes = newInstance:GetAttributes()
		attributes = AttributeValidation.Validate(newInstance.ClassName, newInstance.Name, attributes, true)
		for i, v in pairs(attributes) do
			newInstance:SetAttribute(i, v)
		end
		return newInstance, cursor
	end
end

local ReadInstance

local CreateInstanceReader = function(instanceType, properties)
	local defaults = DefaultProperties[instanceType]

	local InstanceReader = function(str, cursor, Read, colorMap, stringMap)
		local newInstance = Instance.new(instanceType)
		if defaults then
			for k, v in defaults do
				newInstance[k] = v
			end
		end
		for i, v in pairs(properties) do -- sets all Instance properties to their default values as defined in InstanceProperties.lua
			newInstance[v[1]] = v[3]
		end
		local propertyId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		while not (propertyId == 0) do
			local typeName = properties[propertyId][1]
			local valueType = properties[propertyId][2]
			if valueType == "Color3" then
				local colorMapIndex
				colorMapIndex, cursor = Read.ShortInt(str, cursor)
				newInstance[typeName] = colorMap[colorMapIndex]
			elseif valueType == "String" then
				local stringMapIndex
				stringMapIndex, cursor = Read.ShortInt(str, cursor)
				newInstance[typeName] = stringMap[stringMapIndex]
			else
				newInstance[typeName], cursor = Read[valueType](str, cursor)
			end
			propertyId = StringConversion.StringToNumber(str, cursor, 1)
			cursor += 1
		end
		return newInstance, cursor
	end
	return InstanceReader
end

local CachedUserMeshFolder = game.ReplicatedStorage:FindFirstChild("Assets")
if CachedUserMeshFolder then
	CachedUserMeshFolder = CachedUserMeshFolder:FindFirstChild("LoadedMeshes")
	if not CachedUserMeshFolder then
		CachedUserMeshFolder = Instance.new("Folder")
		CachedUserMeshFolder.Name = "LoadedMeshes"
		CachedUserMeshFolder.Parent = game.ReplicatedStorage.Assets
	end
end

local CreateProtectedInstanceReader = function(instanceType, properties)
	local defaults = DefaultProperties[instanceType]

	local InstanceReader = function(str, cursor, Read, colorMap, stringMap)
		local newProperties = {}
		if defaults then
			for k, v in defaults do
				newProperties[k] = v
			end
		end
		for i, v in pairs(properties) do -- sets all Instance properties to their default values as defined in InstanceProperties.lua
			newProperties[v[1]] = v[3]
		end
		local propertyId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		while not (propertyId == 0) do
			local typeName = properties[propertyId][1]
			local valueType = properties[propertyId][2]
			if valueType == "Color3" then
				local colorMapIndex
				colorMapIndex, cursor = Read.ShortInt(str, cursor)
				newProperties[typeName] = colorMap[colorMapIndex]
			elseif valueType == "String" then
				local stringMapIndex
				stringMapIndex, cursor = Read.ShortInt(str, cursor)
				newProperties[typeName] = stringMap[stringMapIndex]
			else
				newProperties[typeName], cursor = Read[valueType](str, cursor)
			end
			propertyId = StringConversion.StringToNumber(str, cursor, 1)
			cursor += 1
		end

		local newInstance = Instance.new("Part")
		local instanceInitialized = false
		local meshId = newProperties.MeshId
		local id = meshId and newProperties.MeshId:match("%d+")
		if id and #id > 3 then
			meshId = id
		end
		newProperties.MeshId = nil

		local cachedMeshPart = meshId
			and (
				(
					game.ReplicatedStorage:FindFirstChild("Assets")
					and game.ReplicatedStorage.Assets:FindFirstChild("ImportParts")
					and game.ReplicatedStorage.Assets.ImportParts:FindFirstChild(meshId)
				) or (CachedUserMeshFolder and CachedUserMeshFolder:FindFirstChild(meshId))
			)
		if cachedMeshPart then
			newInstance = cachedMeshPart:Clone()
			newProperties.CollisionFidelity = nil
			newProperties.RenderFidelity = nil
			for k, v in newProperties do
				newInstance[k] = v
			end
			instanceInitialized = true
		elseif meshId and ENABLE_ARBITRARY_MESHES then
			-- CreateMeshPartAsync is likely less reliable than cloning, so prefer using ImportParts when possible
			local success, instOrReason = pcall(function()
				local part = InsertService:CreateMeshPartAsync(
					`rbxassetid://{meshId}`,
					newProperties["CollisionFidelity"] or Enum.CollisionFidelity.Default,
					newProperties["RenderFidelity"] or Enum.RenderFidelity.Automatic
				)
				if CachedUserMeshFolder then
					local copy = part:Clone()
					copy.Name = meshId
					copy.Parent = CachedUserMeshFolder
				end
				return part
			end)
			newProperties.CollisionFidelity = nil
			newProperties.RenderFidelity = nil
			if success then
				newInstance = instOrReason
				for k, v in newProperties do
					newInstance[k] = v
				end
				instanceInitialized = true
			end
		end

		if not instanceInitialized then
			for k, v in newProperties do
				pcall(function()
					newInstance[k] = v
				end)
			end
		end

		return newInstance, cursor
	end
	return InstanceReader
end

ReadInstance = {
	Model = WithAttributes(CreateInstanceReader("Model", InstanceProperties.Model)),
	Folder = WithAttributes(CreateInstanceReader("Folder", InstanceProperties.Folder)),
	Part = WithAttributes(CreateInstanceReader("Part", InstanceProperties.Part)),
	PartNoAttributes = CreateInstanceReader("Part", InstanceProperties.Part),
	BoolValue = WithAttributes(CreateInstanceReader("BoolValue", InstanceProperties.BoolValue)),
	WedgePart = CreateInstanceReader("WedgePart", InstanceProperties.WedgePart),
	StringValue = CreateInstanceReader("StringValue", InstanceProperties.StringValue),
	MeshPart = WithAttributes(CreateProtectedInstanceReader("MeshPart", InstanceProperties.MeshPart)),
	UnionOperation = WithAttributes(CreateProtectedInstanceReader("UnionOperation", InstanceProperties.UnionOperation)),
	Texture = CreateInstanceReader("Texture", InstanceProperties.Texture),
	BlockMesh = CreateInstanceReader("BlockMesh", InstanceProperties.BlockMesh),
	PointLight = CreateInstanceReader("PointLight", InstanceProperties.PointLight),
	SpotLight = CreateInstanceReader("SpotLight", InstanceProperties.SpotLight),
	SurfaceLight = CreateInstanceReader("SurfaceLight", InstanceProperties.SurfaceLight),
	SpecialMesh = CreateInstanceReader("SpecialMesh", InstanceProperties.SpecialMesh),
	Decal = CreateInstanceReader("Decal", InstanceProperties.Decal),
	Fire = CreateInstanceReader("Fire", InstanceProperties.Fire),
	Smoke = CreateInstanceReader("Smoke", InstanceProperties.Smoke),
	Attachment = CreateInstanceReader("Attachment", InstanceProperties.Attachment),
}

return ReadInstance
]]></ProtectedString>
					<string name="ScriptGuid">{E6C130E8-61A0-48F3-88EF-88A0F08357E2}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">ReadInstance</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXC9414CF6FD964BB7A374F5AFE3EB00E6">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local CHARACTER_SET = {
	"b",
	"c",
	"d",
	"f",
	"g",
	"h",
	"j",
	"k",
	"m",
	"p",
	"q",
	"r",
	"t",
	"v",
	"w",
	"x",
	"y",
	"3",
	"4",
	"6",
	"7",
	"8",
	"9",
	"!",
	'"',
	"#",
	"$",
	"%",
	"&",
	"'",
	"(",
	")",
	"*",
	"+",
	",",
	"-",
	".",
	"/",
	":",
	";",
	"<",
	"=",
	">",
	"?",
	"@",
	"B",
	"C",
	"D",
	"F",
	"G",
	"H",
	"J",
	"K",
	"M",
	"P",
	"Q",
	"R",
	"T",
	"V",
	"W",
	"X",
	"Y",
	"[",
	"\\",
	"]",
	"^",
	"_",
	"`",
	"{",
	"|",
	"}",
	"~",
}

local characterKeys = {}
local characterValues = {}
for i, v in pairs(CHARACTER_SET) do
	characterKeys[v] = i - 1
	characterValues[i - 1] = v
end

local CHAR_COUNT = #CHARACTER_SET
return {
	StringToNumber = function(str, cursor, size)
		local total = 0
		for i = cursor, cursor + size - 1 do
			local char = str:sub(cursor, cursor)
			total = total * CHAR_COUNT + characterKeys[char]
			cursor += 1
		end
		return total
	end,

	NumberToString = function(number, charCount)
		local str = ""
		local iteration = 0
		while number >= 0 and iteration < charCount do
			local value = number % CHAR_COUNT
			str = characterValues[value] .. str
			number = math.floor(number / CHAR_COUNT)
			iteration += 1
		end
		return str
	end,

	GetMaxNumber = function(charCount)
		return math.pow(CHAR_COUNT, charCount) - 1
	end,
}
]]></ProtectedString>
				<string name="ScriptGuid">{F61DFE12-1D8A-4A6F-B18C-24791A33F4C4}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StringConversion</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX165D597B341C468FAE533CB10F855F33">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Types</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX666C385C88BB43ADB7DCC0C929FFB48F">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local AttributeTypes

AttributeTypes = {
	Float = 1,
	Int = 2,
	String = 3,
	Bool = 4,
	Color3 = 5,
	Vector3 = 6,
	LongInt = 7,
	SignedInt = 8,
	CFrame = 9,
}

return AttributeTypes
]]></ProtectedString>
					<string name="ScriptGuid">{2AF60565-05C0-4C79-B548-F006C764A247}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">AttributeTypes</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX10A35745622A411F913278B3B418C31A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	Default = 0,
	Hull = 1,
	Box = 2,
	PreciseConvexDecomposition = 3,
}
]]></ProtectedString>
					<string name="ScriptGuid">{6B2B08C4-61B2-49CA-8BF2-24CB27593B32}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">CollisionFidelity</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX538282B7F7FE40D7B5CA80674B5550F0">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	Part = {
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
	},
}
]]></ProtectedString>
					<string name="ScriptGuid">{D71939E2-E1FA-4903-BF6B-B904CC76A3B3}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">DefaultProperties</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1CBE49532132469B94BCC440E2E955F4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local InstanceProperties

-- Format:
-- [TypeName], [ValueType], [DefaultValue]
-- eg. "Position", "Vector3", "Vector3.new(0, 0, 0)"

InstanceProperties = { -- any changes to this table should be changed in InstanceTypes.lua
	Model = {
		{ "Name", "String", "Model" },
	},
	Folder = {
		{ "Name", "String", "Folder" },
	},
	Part = {
		{ "Name", "String", "Part" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
		{ "Shape", "PartType", "Block" },
	},
	BoolValue = {
		{ "Name", "String", "Value" },
		{ "Value", "Bool", false },
	},
	WedgePart = {
		{ "Name", "String", "Wedge" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
	},
	StringValue = {
		{ "Name", "String", "StringValue" },
		{ "Value", "String", "" },
	},
	MeshPart = {
		{ "Name", "String", "Part" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
		{ "MeshId", "String", "" },
		{ "TextureID", "String", "" },
		{ "RenderFidelity", "RenderFidelity", "Automatic" },
		{ "CollisionFidelity", "CollisionFidelity", "Default" },
	},
	UnionOperation = {
		{ "Name", "String", "Part" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
		{ "MeshId", "String", "" },
	},
	Texture = {
		{ "Name", "String", "Texture" },
		{ "Color3", "Color3", Color3.new() },
		{ "OffsetStudsU", "Float", 0 },
		{ "OffsetStudsV", "Float", 0 },
		{ "StudsPerTileU", "Float", 0 },
		{ "StudsPerTileV", "Float", 0 },
		{ "Texture", "String", "" },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "ZIndex", "Int", 0 },
		{ "Face", "NormalId", "Front" },
	},
	BlockMesh = {
		{ "Scale", "Vector3", Vector3.new(1, 1, 1) },
		{ "Offset", "Vector3", Vector3.new(0, 0, 0) },
	},
	PointLight = {
		{ "Name", "String", "PointLight" },
		{ "Brightness", "Float", 1 },
		{ "Color", "Color3", Color3.new(1, 1, 1) },
		{ "Enabled", "Bool", true },
		{ "Range", "Float", 20 },
		{ "Shadows", "Bool", false },
	},
	SpotLight = {
		{ "Name", "String", "SpotLight" },
		{ "Angle", "Float", 90 },
		{ "Brightness", "Float", 1 },
		{ "Color", "Color3", Color3.new(1, 1, 1) },
		{ "Enabled", "Bool", true },
		{ "Face", "NormalId", Enum.NormalId.Front },
		{ "Range", "Float", 16 },
		{ "Shadows", "Bool", false },
	},
	SurfaceLight = {
		{ "Name", "String", "SurfaceLight" },
		{ "Angle", "Float", 90 },
		{ "Brightness", "Float", 1 },
		{ "Color", "Color3", Color3.new(1, 1, 1) },
		{ "Enabled", "Bool", true },
		{ "Face", "NormalId", Enum.NormalId.Front },
		{ "Range", "Float", 16 },
		{ "Shadows", "Bool", false },
	},
	SpecialMesh = {
		{ "Name", "String", "Mesh" },
		{ "MeshId", "String", "" },
		{ "MeshType", "MeshType", Enum.MeshType.FileMesh },
		{ "Offset", "Vector3", Vector3.new(0, 0, 0) },
		{ "Scale", "Vector3", Vector3.new(1, 1, 1) },
		{ "VertexColor", "Vector3", Vector3.new(1, 1, 1) },
		{ "TextureId", "String", "" },
	},
	Decal = {
		{ "Name", "String", "Mesh" },
		{ "Color3", "Color3", Color3.new() },
		{ "Texture", "String", "" },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "ZIndex", "Int", 0 },
		{ "Face", "NormalId", "Front" },
	},
	Fire = {
		{ "Name", "String", "Mesh" },
		{ "Color", "Color3", Color3.new() },
		{ "Enabled", "Bool", true },
		{ "Heat", "Float", 9 },
		{ "SecondaryColor", "Color3", Color3.new() },
		{ "Size", "Float", 5 },
		{ "TimeScale", "Float", 1 },
	},
	Smoke = {
		{ "Name", "String", "Mesh" },
		{ "Color", "Color3", Color3.new() },
		{ "Enabled", "Bool", true },
		{ "Opacity", "Float", 1 },
		{ "RiseVelocity", "Float", 1 },
		{ "Size", "Float", 1 },
		{ "TimeScale", "Float", 1 },
	},
	Attachment = {
		{ "Name", "String", "Mesh" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Visible", "Bool", false },
	},
}

return InstanceProperties
]]></ProtectedString>
					<string name="ScriptGuid">{0D5FD4B3-A35B-4581-B57C-6D76D478F232}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">InstanceProperties</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA0F3339730AE42D4BEBB3E0DDA47C85C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local InstanceTypes = {
	Nil = 1,
	Model = 2,
	Folder = 3,
	Part = 4,
	PartNoAttributes = 5,
	BoolValue = 6,
	WedgePart = 7,
	StringValue = 8,
	MeshPart = 9,
	UnionOperation = 10,
	Texture = 11,
	BlockMesh = 12,
	PointLight = 13,
	SpotLight = 14,
	SurfaceLight = 15,
	SpecialMesh = 16,
	Decal = 17,
	Fire = 18,
	Smoke = 19,
	Attachment = 20,
}

return InstanceTypes
]]></ProtectedString>
					<string name="ScriptGuid">{8CCEDF8A-9247-4091-86BF-CBEC8D697478}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">InstanceTypes</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX70FFEC339D5C48D2A2BADE8A3341090B">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local Materials

Materials = {
	Asphalt = 1,
	Basalt = 2,
	Brick = 3,
	Cobblestone = 4,
	Concrete = 5,
	CorrodedMetal = 6,
	CrackedLava = 7,
	DiamondPlate = 8,
	Fabric = 9,
	Foil = 10,
	ForceField = 11,
	Glacier = 12,
	Glass = 13,
	Granite = 14,
	Grass = 15,
	Ground = 16,
	Ice = 17,
	LeafyGrass = 18,
	Limestone = 19,
	Marble = 20,
	Metal = 21,
	Mud = 22,
	Neon = 23,
	Pavement = 24,
	Pebble = 25,
	Plastic = 26,
	Rock = 27,
	Salt = 28,
	Sand = 29,
	Sandstone = 30,
	Slate = 31,
	SmoothPlastic = 32,
	Snow = 33,
	Wood = 34,
	WoodPlanks = 35,
	ClayRoofTiles = 36,
	Carpet = 37,
	Cardboard = 38,
	CeramicTiles = 39,
	RoofShingles = 40,
	Leather = 41,
	Plaster = 42,
	Rubber = 43,
}

return Materials
]]></ProtectedString>
					<string name="ScriptGuid">{76054EC3-5832-4DE7-B1CD-BD93BA186FC6}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Materials</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3FC4BB23BA6D46B6865F57E30ED3FB56">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	Brick = 1,
	Cylinder = 2,
	FileMesh = 3,
	Head = 4,
	Sphere = 5,
	Toros = 6,
	Wedge = 7,
}
]]></ProtectedString>
					<string name="ScriptGuid">{1F0851A4-DE84-4974-9153-B02417EF06C2}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">MeshType</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7A805B0078414FF09DD7FF58B36C08F2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	Top = 1,
	Bottom = 2,
	Left = 3,
	Right = 4,
	Front = 5,
	Back = 6,
}
]]></ProtectedString>
					<string name="ScriptGuid">{26ED080A-3376-4AEA-932D-5BF7795F381D}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">NormalId</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX746E42215E0F4F768811C01C0F03ECC4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local PartTypes

PartTypes = {
    Ball = 1,
    Cylinder = 2,
    Block = 3,
    Wedge = 4,
    CornerWedge = 5
}

return PartTypes]]></ProtectedString>
					<string name="ScriptGuid">{0D57C02F-993C-4941-B2A8-604AFA1C8273}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">PartTypes</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB2C628FB87C84A00B3CA1D129844E4BC">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	Automatic = 0,
	Precise = 1,
	Performance = 2
}
]]></ProtectedString>
					<string name="ScriptGuid">{A8D18243-E833-4763-A3B2-2E2BFF9A5EEB}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">RenderFidelity</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX9F85A4B1629945E99D8DFFD988C53C29">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Util</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX8E8833C66D5F45B1AAEC99936119998D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local module = {
	Create = require(script.Parent._ActorCreation._Create),

	State = require(script.Parent._ActorState._State),
	Derived = require(script.Parent._ActorState._Derived),
	DerivedTable = require(script.Parent._ActorState._DerivedTable),
	Watch = require(script.Parent._ActorState._Watch),

	Spring = require(script.Parent._ActorAnim._ActorSpring),
	Cubic = require(script.Parent._ActorAnim._Cubic),

	OnChange = require(script.Parent._OnChange),
}

return module]]></ProtectedString>
					<string name="ScriptGuid">{CBC1BD57-F109-4622-A16B-AD385FB61E40}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Actor</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8998AB94572D4ABFA532A28A4FFC76F2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local AxisAlign = {}

local VECTOR_UP = Vector3.new(0, 1, 0)

function AxisAlign.BestMatch(cfr, axis)
	local comp = axis or VECTOR_UP
	
	local v0, v1, v2 = cfr:VectorToWorldSpace(VECTOR_UP), cfr:VectorToWorldSpace(Vector3.new(1, 0, 0)), cfr:VectorToWorldSpace(Vector3.new(0, 0, 1))
	local d0, d1, d2 = v0:Dot(comp), v1:Dot(comp), v2:Dot(comp)
	
	if d0 < 0 then
		d0 = -d0
		v0 = -v0
	end
	if d1 < 0 then
		d1 = -d1
		v1 = -v1
	end
	if d2 < 0 then
		d2 = -d2
		v2 = -v2
	end
	
	if d1 > d0 then
		d1, d0 = d0, d1
		v1, v0 = v0, v1
	end
	if d2 > d0 then
		d2, d0 = d0, d2
		v2, v0 = v0, v2
	end
	
	return v0, v1, v2
end

function AxisAlign.CameraAlign(cfr, axis)
	local _, v0, v1 = AxisAlign.BestMatch(cfr, axis)
	
	local cam = workspace.CurrentCamera.CFrame.LookVector
	if math.abs(v1:Dot(cam)) > math.abs(v0:Dot(cam)) then
		v0 = v1
	end
	
	local flat = Vector3.new(v0.X, 0, v0.Z).Unit
	return flat, flat:Cross(VECTOR_UP)
end

return AxisAlign
]]></ProtectedString>
					<string name="ScriptGuid">{6CC6DDDF-CCE6-4237-B430-8DFD0176F95F}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">AxisAlign</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX78FBE47633A344E9A4AD1B5751AEDA3F">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local Actor = require(script.Parent.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

return function(props)
	local enabled = props.Enabled or State(false)
	
	return Create("TextButton", {
		BorderSizePixel = 0,
		Size = props.Size or UDim2.new(0, 200, 0, 40),
		Text = props.Text,
		BackgroundTransparency = Derived(function(e)
			return e and 0 or 0.5
		end, enabled),
		BackgroundColor3 = Derived(function(e)
			return e and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
		end, enabled),
		TextColor3 = Derived(function(e)
			return e and Color3.new(0, 0, 0) or Color3.new(1, 1, 1)
		end, enabled),
		
		TextSize = 20,
		Font = Enum.Font.SciFi,
		
		Activated = props.Activated,
		Position = props.Position,
		AnchorPoint = props.AnchorPoint
	})
end]]></ProtectedString>
					<string name="ScriptGuid">{58910045-53A9-4274-8408-E933A1929A4C}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Button</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX41213B406E9C4304B1E089B20857E630">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local CHARACTER_SET = {	'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'm', 'p', 'q', 'r', 't', 'v', 'w', 'x', 'y',
						'3', '4', '6', '7', '8', '9', '!', '\"', '#', '$', '%', '&', '\'',	'(', ')', '*', '+', ',', '-', '.', '/',
						':', ';', '<', '=', '>', '?', '@', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'P', 'Q', 'R', 'T', 'V', 'W', 'X', 'Y',
						'[', '\\', ']', '^', '_', '`', '{', '|', '}', '~'}

local characterKeys = {}
local characterValues = {}
for i, v in pairs(CHARACTER_SET) do
    characterKeys[v] = i - 1;
    characterValues[i - 1] = v;
end

local CHAR_COUNT = #CHARACTER_SET
return {
	StringToNumber = function(str, cursor, size)
		local total = 0
		for i = cursor, cursor + size - 1 do
			local char = str:sub(cursor, cursor)
			total = total * CHAR_COUNT + characterKeys[char]
			cursor += 1
		end 
		return total
	end,
	
	NumberToString = function(number, charCount)
		local str = ""
		local iteration = 0
		while number >= 0 and iteration < charCount do
			local value = number % CHAR_COUNT
			str = characterValues[value] .. str
			number = math.floor(number / CHAR_COUNT)
			iteration += 1
		end
		return str
	end,

	GetMaxNumber = function(charCount)
		return math.pow(CHAR_COUNT, charCount) - 1
	end,
}]]></ProtectedString>
					<string name="ScriptGuid">{B7AA6099-ACCE-4CE1-8412-32ACC5148986}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StringConversion</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1E830AF9A8394869A07C73648A326D85">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	VersionNumber = 1,
	VersionNumber_API = 0,
	ReplaceNewlines = true,
}
]]></ProtectedString>
					<string name="ScriptGuid">{C5967FC7-DCA4-4AC9-AB1C-26519CBD899E}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">VersionConfig</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF074D2B721EC4D68A421D91A24176C18">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local STASH_LINK_NAME = "StashLink"

local module = {}

module.GetStashRoot = function()
    local root = game.ReplicatedStorage:FindFirstChild("StashRoot")
    if not root then
        root = Instance.new("Folder")
        root.Name = "StashRoot"
        root.Parent = game.ReplicatedStorage
    end
    return root
end

module.Hide = function(part)
    if part:FindFirstChild(STASH_LINK_NAME) then
        return false
    end

    local originalParent = part.Parent
    part.Parent = module.GetStashRoot()
    local folder = Instance.new("Folder")
    folder.Parent = originalParent
    folder.Name = part.Name
    local link = Instance.new("ObjectValue")
    link.Value = part
    link.Name = STASH_LINK_NAME
    link.Parent = folder

    return folder
end

module.Reveal = function(part)
    local link = part:FindFirstChild(STASH_LINK_NAME)
    if not link then
        return false
    end

    local val = link.Value
    val.Parent = part.Parent
    part:Destroy()

    return val
end

module.IsHidden = function(part)
    return part:FindFirstChild(STASH_LINK_NAME) ~= nil
end

module.TempReveal = function(part)
    local revealed = module.Reveal(part)
    if revealed then
        revealed:SetAttribute("TempRevealed", true)
    end
end

module.HideTempRevealedParts = function(root)
    if not root then
        return
    end
    for _, part in root:GetChildren() do
        if part:GetAttribute("TempRevealed") then
            part:SetAttribute("TempRevealed", nil)
            module.Hide(part)
        end
    end
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{E14A9DC5-8B9D-4A1B-A98F-3B69CC14DAB2}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">VisibilityToggle</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB6FDFA15A6604B76BF21F5154E365336">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local ZoneUtil = {}

function ZoneUtil.InZone(zone, pos)
	local floorMatch = zone:FindFirstChild("Floor") == nil
	local roofMatch = false

	for _, part in pairs(zone:GetChildren()) do
		local rel = part.CFrame:PointToObjectSpace(pos)

		if math.abs(rel.X) <= part.Size.X / 2 and math.abs(rel.Z) <= part.Size.Z / 2 then
			if part.Name == "Roof" and rel.Y <= 0 then
				roofMatch = true
			elseif part.Name == "Floor" and rel.Y >= 0 then
				floorMatch = true
			end

			if floorMatch and roofMatch then
				return true
			end
		end
	end
	
	return false
end

function ZoneUtil.GetZone(pos)
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, zone in pairs(LevelBase.Cells:GetChildren()) do
		if ZoneUtil.InZone(zone, pos) then
			return zone
		end
	end
end

return ZoneUtil]]></ProtectedString>
					<string name="ScriptGuid">{322B45BA-D5A7-409B-8D41-0DEABFCF36C5}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">ZoneUtil</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXDE2B3BC258F0412587EEEE50DCA5505E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_ActorAnim</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXB3DDFC0295B745D1836D4C9BCF541839">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local AnimRunner = require(script.Parent._Anim)

local numberClose = function(x, y)
	return math.abs(x - y) < 0.01
end
local vectorClose = function(x, y)
	return (x - y).magnitude < 0.01
end
local udim2Close = function(x, y)
	local rel = x - y
	return math.abs(rel.X.Offset) <= 1 and math.abs(rel.Y.Offset) <= 1 and math.abs(rel.X.Scale) < 0.01 and math.abs(rel.Y.Scale) < 0.01 
end

local function getStartingVelocityByType(value)
	if typeof(value) == "number" then
		return 0, numberClose
	elseif typeof(value) == "Vector3" then
		return Vector3.new(), vectorClose
	--elseif typeof(value) == "UDim2" then
	--	return UDim2.new(), udim2Close
	end
end

local Spring = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		if self._IsClose(self._Value, self.T) then
			self._Value = self.T
			return true
		end
		if dt > 0.03 then dt = 0.03 end
		local accel = (self.T - self._Value) * self._Force - self.V * self._Damping
		local vel = self.V
		self.V = self.V + accel * dt * self._Speed
		self._Value = self._Value + (self.V + vel) * dt * 0.5 * self._Speed
		return false
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		self._Value = self._Follow._Value -- Position
		self.T = self._Follow._Value -- Target
		self.V, self._IsClose = getStartingVelocityByType(self._Follow._Value)
	end
}
Spring.__index = Spring

return function(follow, force, damping, speed)
	local self = {}
	self._StateType = "_Spring"
	self._Active = false
	self._Follow = follow
	self._Force = force or 50
	self._Damping = damping or 10
	self._Speed = speed or 1
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Spring)
	return self
end]]></ProtectedString>
						<string name="ScriptGuid">{EC7D2682-DF36-4139-8064-C8A3D7CB797B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_ActorSpring</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7BD0DA38C98F45139B30ACBE106DA8D0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Update = require(script.Parent.Parent._ActorState._Update)

local Anim = {}
Anim._List = {}
Anim._Active = false

function Anim:Start(data)
	self._List[data] = true
	data._Active = true
	if self._Active then return end
	self._Active = true
	self._StepEvent = RunService.RenderStepped:Connect(function(dt)
		for data in pairs(self._List) do
			if data:_Step(dt) then
				self._List[data] = nil
				data._Active = false
			end
			Update(data)
		end
		if not next(self._List) then
			self._Active = false
			self._StepEvent:Disconnect()
			self._StepEvent = nil
		end
	end)
end

return Anim]]></ProtectedString>
						<string name="ScriptGuid">{4AC593D6-A4F5-4BA6-99D3-9A08BCE601BE}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Anim</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3CB468E5F6B541E9BECC14AD92B9983A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
						<string name="ScriptGuid">{38DC42BE-4198-4181-A971-7D610445A21B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Cubic</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXECD36A42CE79456CA2F04376180FEA0E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
						<string name="ScriptGuid">{F9E5E3B0-1EEC-4F1E-8749-D02BCD1E138B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Linear</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXC7BF4451E8F148DC9BF7A857F0B4E8C3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_ActorCreation</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX65AB4A60F8654230902FD269F961208D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local TABLE = "table"
local SCRIPT_SIGNAL = "RBXScriptSignal"
local INST = "Instance"
local DEBUG = "Debug"
local TEMP_STATE = "TempState"

local HandleStateCleanup = require(script.Parent:WaitForChild("_HandleStateCleanup"))


local function processChildren(parent, item, stateLink)
	if typeof(item) == INST then
		item.Parent = parent
		return
	end
	if item._DerivedTable then
		item:_Init()
		item.OnAdd = function(_, instance)
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		item.OnRemove = function(_, instance)
			if typeof(instance) == INST then
				instance:Destroy()
			end
		end
		for _, instance in pairs(item._Value) do
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		if stateLink then
			table.insert(stateLink, item)
		end
	else
		for _, c in pairs(item) do
			processChildren(parent, c, stateLink)
		end
	end
end

return function(className, props, children, autoCleanup)
	local instance = Instance.new(className)

	local stateLink
	if autoCleanup then
		stateLink = {}
	end

	for name, value in pairs(props) do
		if name == DEBUG or name == TEMP_STATE then continue end

		if typeof(value) == TABLE then
			if value._StateType then
				value._Link[instance] = name
				if value._Init then
					value:_Init()
				end
				instance[name] = value._Value
				if autoCleanup then
					table.insert(stateLink, value)
				end
			end
		elseif typeof(name) == TABLE then
			if name._OnChange then
				local propName = name._Property
				instance:GetPropertyChangedSignal(propName):Connect(function() value(instance[propName]) end)
				value(props[propName] or instance[propName])
			end
		elseif typeof(instance[name]) == SCRIPT_SIGNAL then
			instance[name]:Connect(value)
		else
			instance[name] = value
		end
	end

	if children then
		processChildren(instance, children, autoCleanup and stateLink)
	end

	if autoCleanup and next(stateLink) then
		instance.AncestryChanged:Connect(function()
			if instance.Parent == nil then
				if props.Debug then
					warn("Cleanup:", props.Debug, stateLink)
				end
				for _, dep in pairs(stateLink) do
					dep._Link[instance] = nil
					HandleStateCleanup(dep)
				end
			end
		end)
	end

	return instance
end]]></ProtectedString>
						<string name="ScriptGuid">{9398F97B-78A5-4B07-84DF-6363E00B1A1F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Create</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5662D1522B6F477EA621920751B47F72">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local cleanup
cleanup = function(state)
	if state.Debug then
		warn(state.Debug, state._Temp, state._GetDependencies ~= nil, next(state._Dependent), next(state._Link))
	end
	if not state._Persist and state._GetDependencies and not next(state._Dependent) and not next(state._Link) then
		if state.Debug then
			warn("Cleanup", state.Debug, state:_GetDependencies())
		end
		state._Initialized = false
		for _, dep in pairs(state:_GetDependencies()) do
			dep._Dependent[state] = nil
			cleanup(dep)
		end
	end
end

return cleanup]]></ProtectedString>
						<string name="ScriptGuid">{F3CCD9BB-A453-487D-860B-DB3731213DE6}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_HandleStateCleanup</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8250A08AA0544EE7B6DD1BD5E9C78F78">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_ActorState</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXA652362C7E144309AD5168F790972EAE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Derived = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		local newValue = self._Eval(unpack(values))
		if newValue ~= self._Value then
			self._Value = newValue
			return true
		end
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Derived.__index = Derived

return function(eval, ...)
	local self = {}
	self._StateType = "_Derived"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Derived)
	return self
end]]></ProtectedString>
						<string name="ScriptGuid">{260E749E-4389-4F55-83D7-6334662A3E2B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Derived</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX12584A03F32640429656DC351AE59E07">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local DerivedTable = {
	_Update = function(self)
		local changed = false
		local input = self._Input._Value

		for k, v in pairs(input) do
			local li = self._LastInput[k]
			if v ~= li then
				changed = true
				if li and self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = v
				self._Value[k] = self._Eval(k, v)
				if self.OnAdd then
					self.OnAdd(k, self._Value[k])
				end
			end
		end

		for k, v in pairs(self._LastInput) do
			if not input[k] then
				if self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = nil
				changed = true
			end
		end

		return changed
	end,
	_GetDependencies = function(self)
		return { self._Input }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Input._Dependent[self] = true
		if self._Input._Init then
			self._Input:_Init()
		end
		self:_Update()
	end
}
DerivedTable.__index = DerivedTable

return function(eval, input, onAdd, onRemove)
	local self = {}
	self._StateType = "_DerivedTable"
	self._DerivedTable = true
	self._Eval = eval
	self._Value = {}
	self._LastInput = {}
	self._Input = input
	self._Temp = input._Temp
	self._Priority = input._Priority + 1

	self.OnAdd = onAdd
	self.OnRemove = onRemove

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, DerivedTable)
	return self
end]]></ProtectedString>
						<string name="ScriptGuid">{7731004C-E98D-4B16-9405-EBE5A9CFCE00}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_DerivedTable</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4C2D4CB6DDED4E9D98D14263E0A9A8CA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Update = require(script.Parent:WaitForChild("_Update"))

local State = {
	set = function(self, value)
		if self._Value == value then
			return
		end
		self._Value = value
		Update(self)
	end,
}
State.__index = State

return function(value)
	local self = {}
	self._StateType = "_State"
	self._State = true
	self._Value = value
	self._Priority = 0
	self._Dependent = {}
	self._Link = {}
	self._Temp = false

	setmetatable(self, State)
	return self
end
]]></ProtectedString>
						<string name="ScriptGuid">{2257AE25-6A8A-445D-9BFD-5A70FECDB57B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_State</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF3E1A075345C4286B1D7DCA4BB491F73">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(base)
	local list = {}

	for instance, prop in pairs(base._Link) do
		instance[prop] = base._Value
	end

	for dep in pairs(base._Dependent) do
		list[dep] = true
	end

	local best = next(list)
	while best do
		local priority = best._Priority
		for dep in pairs(list) do
			if dep._Priority < priority then
				best = dep
				priority = best._Priority
			end
		end
		list[best] = nil

		if best:_Update() then -- this updated and we need to change it's dependencies
			for instance, prop in pairs(best._Link) do
				instance[prop] = best._Value
			end
			for dep in pairs(best._Dependent) do
				list[dep] = true
			end
		end

		best = next(list)
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{E3E0DD50-BD35-4C0F-934D-5E5FF4940AEF}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Update</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDB7BC7A7373948F9B5CB3768303C166B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Watch = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		-- Make Watch Callback
        self._Eval(unpack(values))
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Watch.__index = Watch

return function(eval, ...)
	local self = {}
	self._StateType = "_Watch"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Watch)

    -- Unlike other state components, we want to init this one immediataly as it will never connect to an instance
    -- Any dependencies will never be released, only use this for debugging or if you're sure those state components don't need to be gced
    self:_Init()

	return self
end]]></ProtectedString>
						<string name="ScriptGuid">{49E3B2B2-61E8-43D3-A142-5BD165BA1C3F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">_Watch</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX6D024EC3931B4EE0920C70FF5A60F843">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return function(prop)
	return {
		_OnChange = true,
		_Property = prop,
	}
end]]></ProtectedString>
					<string name="ScriptGuid">{536894D3-3DA5-4C7E-97B7-56419177CF34}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_OnChange</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6256CF6AD96148788B3B1234E6C32474">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Writing</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXB50C26A729C2474EABC95306FD4A230A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ScriptEditorService = game:GetService("ScriptEditorService")
local UserInputService = game:GetService("UserInputService")

local InternalAPI = require(script.Parent.Parent.API.Internal)
local Write = require(script.Parent.Write)
local StringConversion = require(script.Parent.Parent.StringConversion)
local Read = require(script.Parent.Parent.Reading.Read)

local Button = require(script.Parent.Parent.Util.Button)
local VisibilityToggle = require(script.Parent.Parent.Util.VisibilityToggle)
local VersionConfig = require(script.Parent.Parent.Util.VersionConfig)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable

local MAX_PASTE_SIZE = 199999
local PASTE_INFO_SIZE = 7
local PASTE_SIZE = MAX_PASTE_SIZE - PASTE_INFO_SIZE

local VERSION_NUMBER = VersionConfig.VersionNumber

local GIST_PREFIX = [[!!! 
How to play custom missions:

1) Join the game and find "Custom Mission" in the mission menu
2) Start a custom mission lobby
3) Go to the table and open the custom mission loader
4) Copy the URL of this page into the box and hit enter. It will NOT work if you copy the contents of this page instead of the URL.

Mission Name:
Creator:
Version:
Briefing:

!!!]]

local module = {}

local function GetMission()
	local mission = workspace:FindFirstChild("DebugMission") or game.ReplicatedStorage:FindFirstChild("DebugMission")
	if not mission then
		error("No mission found: Mission must be named 'DebugMission' and placed in workspace or ReplicatedStorage")
	end

	for _, p in mission:GetChildren() do
		VisibilityToggle.TempReveal(p)
	end

	local missionClone = mission:Clone()
	VisibilityToggle.HideTempRevealedParts(mission)

	InternalAPI.InvokeHook("PreSerialize", missionClone)
	InternalAPI.InvokeHook("PreSerializeMissionSetup", missionClone:FindFirstChild("MissionSetup"))

	return missionClone
end

local function GetMissionCode()
	local mission = GetMission()
	local code = Write.Mission(mission)
	mission:Destroy()
	return code
end

module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	local CodeState = State("")
	local Pastes = State({})

	Pastes = Derived(function(code)
		local codeChunks = {}
		local first = 1
		local current = PASTE_SIZE -- leaving space for paste information
		local currentPaste = 1
		local maxPastes = math.ceil(#code / current)
		local mapId = math.random(1, StringConversion.GetMaxNumber(2)) -- A 3 character integer that can be used to identify maps
		while first < #code do
			local prePaste = ""
			prePaste = StringConversion.NumberToString(VERSION_NUMBER, 1)
			prePaste = prePaste .. Write.ShortInt(mapId)
			prePaste = prePaste .. Write.ShortInt(currentPaste)
			prePaste = prePaste .. Write.ShortInt(maxPastes)
			codeChunks[#codeChunks + 1] = prePaste .. code:sub(first, current)
			first += PASTE_SIZE
			current += PASTE_SIZE
			currentPaste += 1
		end
		return codeChunks
	end, CodeState)

	local apiDevEnabled = workspace:GetAttribute("APIDev")

	module.UI = Create("ScreenGui", {
		Parent = game:GetService("CoreGui"),
		Archivable = false,
	}, {
		Button({
			Size = UDim2.new(0, 200, 0, 30),
			Enabled = module.EnabledState,
			Position = UDim2.new(0, 50, 0, 50),
			Text = "Generate Code",
			Activated = function()
				local code = GetMissionCode()

				if not workspace:FindFirstChild("DebugMission") then
					local model = Read.Mission(code, 1)
					model.Parent = workspace
				end
				CodeState:set(code)
			end,
		}),
		if workspace:GetAttribute("ReadDocs")
			then Button({
				Size = UDim2.new(0, 200, 0, 30),
				Enabled = module.EnabledState,
				Position = UDim2.new(0, 270, 0, 50),
				Text = "Gist Code",
				Activated = function()
					local code = GetMissionCode()

					if not workspace:FindFirstChild("DebugMission") then
						local model = Read.Mission(code, 1)
						model.Parent = workspace
					end

					local output = ""
					output = StringConversion.NumberToString(VERSION_NUMBER, 1)
					output = output .. Write.ShortInt(math.random(1, 100))
					output = output .. Write.ShortInt(1)
					output = output .. Write.ShortInt(1)
					output = output .. code
					output = GIST_PREFIX .. output

					if workspace:FindFirstChild("CustomMissionCode") then
						workspace.CustomMissionCode:Destroy()
					end

					local s = Instance.new("Script")
					s.Name = "CustomMissionCode"
					ScriptEditorService:UpdateSourceAsync(s, function()
						return output
					end)
					s.Parent = workspace
					ScriptEditorService:OpenScriptDocumentAsync(s)
				end,
			})
			else nil,
		if apiDevEnabled
			then
			Button({
				Size = UDim2.new(0, 200, 0, 30),
				Enabled = module.EnabledState,
				Position = UDim2.new(0, 50, 1, -50),
				AnchorPoint = Vector2.new(0, 1),
				Text = "Preserialize Preview",
				Activated = function()
					local preprocessed = GetMission()
					preprocessed.Name = `{preprocessed.Name}_Preserialized`
					preprocessed.Parent = workspace
				end,
			})
			else nil,
		Create("ScrollingFrame", {
			Size = UDim2.new(0, 200, 1, apiDevEnabled and -180 or -130),
			Position = UDim2.new(0, 50, 0, 80),
			BackgroundColor3 = Color3.new(0, 0, 0),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 0,
			Visible = Derived(function(code)
				if code == "" then
					return false
				else
					return true
				end
			end, CodeState),
			CanvasSize = Derived(function(code)
				return UDim2.new(0, 180, 0, 34 * (math.ceil(#code / PASTE_SIZE)))
			end, CodeState),
		}, {
			DerivedTable(function(index, value)
				local textBox = Create("TextBox", {
					ClearTextOnFocus = false,
					Size = UDim2.new(0, 80, 0, 20),
					Position = UDim2.new(0, 10, 0, 5),
					TextEditable = false,
					TextScaled = false,
					TextSize = 10,
					ClipsDescendants = true,
					TextWrapped = false,
					BackgroundTransparency = 1,
					TextColor3 = Color3.new(255, 255, 255),
					BorderSizePixel = 5,
					Text = value,
				})

				local selector = Create("Frame", {
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 200, 0, 50),
					Position = UDim2.new(0, 0, 0, (index - 1) * 34 + 4),
				}, {
					textBox,
					Create("TextButton", {
						Size = UDim2.new(0, 90, 0, 20),
						Position = UDim2.new(0, 100, 0, 5),
						Text = "Select " .. tostring(index),
						FontFace = Font.fromEnum(Enum.Font.SciFi),
						BackgroundColor3 = Color3.new(255, 255, 255),
						BorderColor3 = Color3.new(0, 0, 0),
						TextScaled = false,
						TextSize = 14,
						TextStrokeColor3 = Color3.new(0, 0, 0),
						BorderSizePixel = 0,
						Activated = function()
							textBox:CaptureFocus()
							textBox.SelectionStart = 0
							textBox.CursorPosition = #value + 1
						end,
					}),
				})
				return selector
			end, Pastes),
		}),
	})
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	module.UI:Destroy()
	module.UI = nil
end

return module
]]></ProtectedString>
					<string name="ScriptGuid">{73D496B3-5B49-4F5B-98F7-10D5CD512BBA}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX72A5CC8BEB4343E78407F25F3B89EA7F">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceTypes = require(script.Parent.Parent.Types.InstanceTypes)
local WriteInstance = require(script.Parent.WriteInstance)
local Materials = require(script.Parent.Parent.Types.Materials)
local PartTypes = require(script.Parent.Parent.Types.PartTypes)
local NormalId = require(script.Parent.Parent.Types.NormalId)
local MeshType = require(script.Parent.Parent.Types.MeshType)
local RenderFidelity = require(script.Parent.Parent.Types.RenderFidelity)
local CollisionFidelity = require(script.Parent.Parent.Types.CollisionFidelity)

local VersionConfig = require(script.Parent.Parent.Util.VersionConfig)

local Write

local SHORTEST_INT_BOUND = StringConversion.GetMaxNumber(1)
local SHORT_INT_BOUND = StringConversion.GetMaxNumber(2)
local INT_BOUND = StringConversion.GetMaxNumber(4)
local LONG_INT_BOUND = StringConversion.GetMaxNumber(6)
local SIGNED_INT_BOUND = math.floor(StringConversion.GetMaxNumber(3) / 2)
local BOUNDED_FLOAT_BOUND = StringConversion.GetMaxNumber(3)
local SHORT_BOUNDED_FLOAT_BOUND = math.floor(StringConversion.GetMaxNumber(2))

local normalize = function(value) -- normalizes an angle in radians (from -pi to pi) to 0-1
	return (value + math.pi) / (math.pi * 2)
end

local function CreateEnumWriter(keys)
	return function(value)
		local index = keys[value.Name] or 1
		return StringConversion.NumberToString(index, 1)
	end
end

local ESCAPED_NEWLINES_ACTIVE = VersionConfig.ReplaceNewlines
local TAB_CHAR = utf8.char(9)

Write = {
	Bool = function(bool) -- 1 character
		return if bool then "b" else "c"
	end,

	ShortInt = function(num) -- 2 characters
		if num > SHORT_INT_BOUND then
			return StringConversion.NumberToString(SHORT_INT_BOUND, 2)
		elseif num < 0 then
			return StringConversion.NumberToString(0, 2)
		else
			return StringConversion.NumberToString(num, 2)
		end
	end,

	Int = function(num) -- 4 characters
		if num > INT_BOUND then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(INT_BOUND, 4)
		elseif num < 0 then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(0, 4)
		else
			return StringConversion.NumberToString(num, 4)
		end
	end,

	LongInt = function(num)
		if num > LONG_INT_BOUND then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(LONG_INT_BOUND, 6)
		elseif num < 0 then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(0, 6)
		else
			return StringConversion.NumberToString(num, 6)
		end
	end,

	SignedInt = function(num) -- 3 characters
		if num > SIGNED_INT_BOUND then
			return StringConversion.NumberToString(SIGNED_INT_BOUND * 2, 3)
		elseif num < SIGNED_INT_BOUND * -1 then
			return StringConversion.NumberToString(0, 3)
		else
			return StringConversion.NumberToString(num + SIGNED_INT_BOUND, 3)
		end
	end,

	Float = function(num) -- 5 characters, 3 before decimal, 2 after
		local beforeDecimalStr = Write.SignedInt(math.floor(num))
		local afterDecimalStr =
			StringConversion.NumberToString(math.round((num - math.floor(num)) * SHORT_INT_BOUND), 2)
		return beforeDecimalStr .. afterDecimalStr
	end,

	Vector3 = function(vector) -- 24 characters, 8 for each float of X, Y, & Z
		return Write.Float(vector.X) .. Write.Float(vector.Y) .. Write.Float(vector.Z)
	end,

	CFrame = function(frame) -- 27 characters, 15 for position, 12 for rotation
		local rx, ry, rz = frame:ToEulerAnglesXYZ()
		return Write.Float(frame.X)
			.. Write.Float(frame.Y)
			.. Write.Float(frame.Z)
			.. Write.BoundedFloat(normalize(rx))
			.. Write.BoundedFloat(normalize(ry))
			.. Write.BoundedFloat(normalize(rz))
	end,

	BoundedFloat = function(num) -- 3 characters
		if num > 1 then
			num = 1
		end
		if num < 0 then
			num = 0
		end
		return StringConversion.NumberToString(math.round(num * BOUNDED_FLOAT_BOUND), 3)
	end,

	ShortBoundedFloat = function(num) -- 2 characters
		if num > 1 then
			num = 1
		end
		if num < 0 then
			num = 0
		end
		return StringConversion.NumberToString(math.round(num * SHORT_BOUNDED_FLOAT_BOUND), 2)
	end,

	Color3 = function(color) -- 6 characters
		return Write.ShortBoundedFloat(color.R) .. Write.ShortBoundedFloat(color.G) .. Write.ShortBoundedFloat(color.B)
	end,

	String = function(str) -- 4 + length characters
		if ESCAPED_NEWLINES_ACTIVE then
			str = str:gsub("&", "&&"):gsub("\n", "&n"):gsub("\r", "&r"):gsub(TAB_CHAR, "&t")
		end
		return Write.Int(#str) .. str
	end,

	ColorMap = function(colorMap)
		local colorStr = ""
		for i, v in pairs(colorMap) do
			colorStr = colorStr .. Write.Color3(v)
		end
		return Write.ShortInt(#colorMap) .. colorStr
	end,

	StringMap = function(stringMap)
		local stringStr = ""
		for i, v in pairs(stringMap) do
			stringStr = stringStr .. Write.String(v)
		end
		return Write.ShortInt(#stringMap) .. stringStr
	end,

	Mission = function(mission)
		local str = ""

		local MissionSetup = require(mission:FindFirstChild("MissionSetup"):Clone())

		while mission:FindFirstChild("StringMissionSetup") do
			mission:FindFirstChild("StringMissionSetup"):Destroy()
		end
		while mission:FindFirstChild("TableMissionSetup") do
			mission:FindFirstChild("TableMissionSetup"):Destroy()
		end

		-- setting Color3s into tables for encoding
		for i, v in pairs(MissionSetup["Colors"]) do
			MissionSetup["Colors"][i] = { v.R, v.G, v.B }
		end

		local json = game:GetService("HttpService"):JSONEncode(MissionSetup)

		local TableMissionSetup = Instance.new("StringValue")
		TableMissionSetup.Name = "TableMissionSetup"
		TableMissionSetup.Value = json
		TableMissionSetup.Parent = mission

		local StringMissionSetup = Instance.new("StringValue")
		StringMissionSetup.Name = "StringMissionSetup"
		StringMissionSetup.Value = mission:FindFirstChild("MissionSetup").Source
		StringMissionSetup.Parent = mission

		-- Numeric index so as to not have the size collide with existing values
		local colorMap = { [0] = 0 }
		local stringMap = { [0] = 0 }

		str, colorMap, stringMap = Write.Instance(mission, colorMap, stringMap)

		colorMap[0] = nil
		stringMap[0] = nil

		local colorMapArr = {}
		local stringMapArr = {}

		for colHex, colidx in pairs(colorMap) do
			colorMapArr[colidx] = Color3.fromHex(colHex)
		end

		for str, stridx in pairs(stringMap) do
			stringMapArr[stridx] = str
		end

		local colorMapStr = Write.ColorMap(colorMapArr)
		local stringMapStr = Write.StringMap(stringMapArr)

		return colorMapStr .. stringMapStr .. str
	end,

	Instance = function(object, colorMap, stringMap)
		local className = object.ClassName
		if InstanceTypes[object.ClassName] ~= nil then
			if next(object:GetAttributes()) == nil and object.ClassName == "Part" then
				className = className .. "NoAttributes"
			end
			local instanceType = StringConversion.NumberToString(InstanceTypes[className], 1)
			local objectProperties, colorMap, stringMap = WriteInstance[className](object, Write, colorMap, stringMap)
			local childrenProperties = ""
			for i, v in pairs(object:GetChildren()) do
				childrenProperties = childrenProperties .. Write.Instance(v, colorMap, stringMap)
			end
			return instanceType .. objectProperties .. childrenProperties .. StringConversion.NumberToString(0, 1),
				colorMap,
				stringMap
		else
			return StringConversion.NumberToString(InstanceTypes.Nil, 1), colorMap, stringMap
		end
	end,

	Material = CreateEnumWriter(Materials),
	PartType = CreateEnumWriter(PartTypes),
	NormalId = CreateEnumWriter(NormalId),
	MeshType = CreateEnumWriter(MeshType),
	RenderFidelity = CreateEnumWriter(RenderFidelity),
	CollisionFidelity = CreateEnumWriter(CollisionFidelity),
	--[[
	Material = function(material)
		return StringConversion.NumberToString(Materials[material.Name], 1)
	end,

	PartType = function(pType)
		return StringConversion.NumberToString(PartTypes[pType.Name], 1)
	end,

	NormalId = function(pType)
		return StringConversion.NumberToString(NormalId[pType.Name], 1)
	end,
	]]
}

return Write
]]></ProtectedString>
					<string name="ScriptGuid">{A7C9D14C-94DF-4021-A9AF-36D823EE8B63}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Write</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8EE99E3CA88F4A928B464BF32CAA5028">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceProperties = require(script.Parent.Parent.Types.InstanceProperties)
local AttributeTypes = require(script.Parent.Parent.Types.AttributeTypes)
local AttributeValidation = require(script.Parent.Parent.AttributeValidation)

local function lookupMapIndex(map, value)
	if value == nil then
		return 0
	end
	if typeof(value) == "Color3" then
		value = value:ToHex()
	end
	local idx = map[value]
	if idx == nil then
		idx = (map[0] + 1) -- Size + 1
		map[value] = idx
		map[0] = idx -- Update size
	end
	return idx
end

local WithAttributes = function(DefaultWriter)
	return function(object, Write, colorMap, stringMap)
		local str = DefaultWriter(object, Write, colorMap, stringMap)
		local attributes = object:GetAttributes()
		attributes = AttributeValidation.Validate(object.ClassName, object.Name, attributes, false)
		local attString = ""

		-- Encoding Attributes
		for k, v in pairs(attributes) do
			if k:match("^RBX_") then
				continue
			end

			local attributeType = typeof(v) -- Changing attribute type names to match as they are in the Write file
			if typeof(v) == "number" then
				if v ~= math.round(v) or v < 0 then
					attributeType = "Float"
				else
					attributeType = "LongInt"
				end
			elseif typeof(v) == "boolean" then
				attributeType = "bool"
			end
			attributeType = (string.upper(string.sub(attributeType, 1, 1)) .. string.sub(attributeType, 2, -1))
			if AttributeTypes[attributeType] == nil then -- if the attribute is not in the table, ignore it
				continue
			end

			local index = lookupMapIndex(stringMap, k)
			attString = attString
				.. StringConversion.NumberToString(AttributeTypes[attributeType], 1)
				.. Write.ShortInt(index)

			if attributeType == "Color3" then
				local index = lookupMapIndex(colorMap, v)
				attString = attString .. Write.ShortInt(index)
			elseif attributeType == "String" then
				local index = lookupMapIndex(stringMap, v)
				attString = attString .. Write.ShortInt(index)
			else
				attString = attString .. Write[attributeType](v)
			end
		end
		str = str .. attString .. StringConversion.NumberToString(0, 1)
		return str, colorMap, stringMap
	end
end

local CreateInstanceWriter = function(properties)
	local WriteInstance = function(object, Write, colorMap, stringMap)
		local str = ""
		for i, v in pairs(properties) do
			local value
			if v[1] == "MeshId" and object.ClassName == "UnionOperation" then
				value = object:GetAttribute("MeshId")
			else
				value = object[v[1]]
			end
			local valueType = v[2]
			local defaultValue = v[3]
			if (valueType == "Color3") and (value ~= defaultValue) then
				local index = lookupMapIndex(colorMap, value)
				str = str .. StringConversion.NumberToString(i, 1)
				str = str .. Write.ShortInt(index)
				continue
			elseif (valueType == "String") and (value ~= defaultValue) then
				local index = lookupMapIndex(stringMap, value)
				str = str .. StringConversion.NumberToString(i, 1)
				str = str .. Write.ShortInt(index)
				continue
			elseif value ~= defaultValue then
				str = str .. StringConversion.NumberToString(i, 1)
				str = str .. Write[valueType](value)
			end
		end

		str = str .. StringConversion.NumberToString(0, 1)
		return str, colorMap, stringMap
	end
	return WriteInstance
end

local WriteInstance

WriteInstance = {
	Model = WithAttributes(CreateInstanceWriter(InstanceProperties.Model)),
	Folder = WithAttributes(CreateInstanceWriter(InstanceProperties.Folder)),
	Part = WithAttributes(CreateInstanceWriter(InstanceProperties.Part)),
	PartNoAttributes = CreateInstanceWriter(InstanceProperties.Part),
	BoolValue = WithAttributes(CreateInstanceWriter(InstanceProperties.BoolValue)),
	WedgePart = CreateInstanceWriter(InstanceProperties.WedgePart),
	StringValue = CreateInstanceWriter(InstanceProperties.StringValue),
	MeshPart = WithAttributes(CreateInstanceWriter(InstanceProperties.MeshPart)),
	UnionOperation = WithAttributes(CreateInstanceWriter(InstanceProperties.UnionOperation)),
	Texture = CreateInstanceWriter(InstanceProperties.Texture),
	BlockMesh = CreateInstanceWriter(InstanceProperties.BlockMesh),
	PointLight = CreateInstanceWriter(InstanceProperties.PointLight),
	SpotLight = CreateInstanceWriter(InstanceProperties.SpotLight),
	SurfaceLight = CreateInstanceWriter(InstanceProperties.SurfaceLight),
	SpecialMesh = CreateInstanceWriter(InstanceProperties.SpecialMesh),
	Decal = CreateInstanceWriter(InstanceProperties.Decal),
	Fire = CreateInstanceWriter(InstanceProperties.Fire),
	Smoke = CreateInstanceWriter(InstanceProperties.Smoke),
	Attachment = CreateInstanceWriter(InstanceProperties.Attachment),
}

return WriteInstance
]]></ProtectedString>
					<string name="ScriptGuid">{1F2F31CA-F0D8-480E-820D-D4467E76E015}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">WriteInstance</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>